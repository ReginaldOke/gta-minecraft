<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>JEE TEE AYY SIX</title>
  
  <!-- Add an import map to fix the bare "three" module specifier error -->
  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.module.js",
        "three/examples/jsm/": "https://cdn.jsdelivr.net/npm/three@0.128.0/examples/jsm/"
      }
    }
  </script>

  <style>
    body, html {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background-color: #1a1a1a;
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
      touch-action: none;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    }

    #game-canvas {
      width: 100%;
      height: 100%;
      display: block;
      position: relative;
      z-index: 1;
    }

    #ui-layer {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      z-index: 10;
      padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
      box-sizing: border-box;
    }

    .hud-top {
      display: flex;
      justify-content: space-between;
      padding: 20px;
      font-size: clamp(14px, 2vw, 20px);
      color: white;
      text-shadow: 2px 2px 0 #000, -1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000, 1px 1px 0 #000;
    }

    #hud-left {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    #minimap-container {
      width: 150px;
      height: 150px;
      border: 4px solid #222;
      border-radius: 50%;
      overflow: hidden;
      background: rgba(0, 0, 0, 0.8);
      position: relative;
      box-shadow: 0 0 15px rgba(0, 0, 0, 0.9);
    }

    #minimap {
      width: 100%;
      height: 100%;
    }

    .bar-container {
      width: 200px;
      height: 18px;
      background: rgba(0, 0, 0, 0.6);
      border: 2px solid #000;
      position: relative;
    }

    .bar-fill {
      width: 100%;
      height: 100%;
      transition: width 0.1s;
    }

    #health-fill {
      background: #e53935;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.4; }
    }

    #nos-fill {
      background: linear-gradient(90deg, #0088aa, #00ffcc);
    }

    #car-health-fill {
      background: linear-gradient(90deg, #aa5500, #ffaa00);
    }

    #car-hud {
      display: none;
      margin-top: 5px;
    }

    .bar-label {
      position: absolute;
      left: 5px;
      top: -2px;
      font-size: 14px;
      color: white;
      text-shadow: 1px 1px 0 #000;
      font-weight: bold;
    }

    .stars {
      color: gold;
      letter-spacing: 5px;
      text-align: right;
      font-size: 28px;
    }

    .stars span {
      color: rgba(255, 255, 255, 0.3);
    }

    .cop-flash {
      animation: copFlash 0.4s infinite !important;
    }

    @keyframes copFlash {
      0% { color: red; text-shadow: 0 0 15px red; }
      50% { color: blue; text-shadow: 0 0 15px blue; }
      100% { color: red; text-shadow: 0 0 15px red; }
    }

    #crime-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: radial-gradient(circle, transparent 60%, rgba(255, 0, 0, 0.4) 100%);
      display: none;
      pointer-events: none;
      z-index: 5;
    }

    #crime-text {
      position: fixed;
      top: 25%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #ff3333;
      font-size: 48px;
      text-shadow: 3px 3px 0 #000, -1px -1px 0 #fff;
      font-weight: bold;
      font-style: italic;
      display: none;
      pointer-events: none;
      z-index: 15;
      animation: pulse 0.5s infinite alternate;
    }

    @keyframes pulse {
      from { transform: translate(-50%, -50%) scale(1); }
      to { transform: translate(-50%, -50%) scale(1.1); }
    }

    #objective-text {
      color: #ffcc00;
      font-size: 18px;
      margin-top: 5px;
      animation: blink 2s infinite;
      text-align: right;
      font-weight: bold;
    }

    @keyframes blink {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }

    #demolition-progress {
      position: fixed;
      top: 140px;
      right: 20px;
      text-align: center;
      pointer-events: none;
      z-index: 100;
    }
    #demo-building {
      width: 70px;
      height: 110px;
      background: #2a2a3a;
      border: 2px solid #555;
      border-radius: 3px 3px 0 0;
      position: relative;
      overflow: hidden;
      margin: 0 auto;
      /* Window pattern */
      background-image:
        repeating-linear-gradient(0deg, transparent, transparent 18px, #444 18px, #444 20px),
        repeating-linear-gradient(90deg, transparent, transparent 13px, #444 13px, #444 15px);
    }
    #demo-fill {
      position: absolute;
      bottom: 0;
      left: 0;
      width: 100%;
      height: 0%;
      background: linear-gradient(to top, #ff4400, #ff8800);
      transition: height 0.3s ease;
      opacity: 0.85;
    }
    #demo-pct {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: white;
      font-size: 22px;
      font-weight: bold;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.9);
      z-index: 1;
    }
    #demo-label {
      color: #ff8800;
      font-size: 11px;
      font-weight: bold;
      margin-top: 4px;
      letter-spacing: 2px;
      text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
    }

    #waypoint-arrow {
      display: none;
    }

    #waypoint-dist {
      position: absolute;
      top: 12%;
      left: 50%;
      transform: translateX(-50%);
      color: #ffcc00;
      font-weight: bold;
      font-size: 20px;
      text-shadow: 2px 2px 0 #000, -1px -1px 0 #000;
      z-index: 10;
      pointer-events: none;
    }

    #vignette {
      position: fixed;
      top: 0; left: 0; width: 100%; height: 100%;
      pointer-events: none;
      z-index: 5;
      background: radial-gradient(ellipse at center, transparent 55%, rgba(0,0,0,0.4) 100%);
    }
    #damage-flash {
      position: fixed;
      top: 0; left: 0; width: 100%; height: 100%;
      pointer-events: none;
      z-index: 6;
      background: radial-gradient(ellipse at center, transparent 30%, rgba(200,0,0,0.6) 100%);
      opacity: 0;
      transition: opacity 0.15s ease-out;
    }

    #crosshair {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      display: none;
      pointer-events: none;
      z-index: 100;
      /* Center dot */
      width: 3px;
      height: 3px;
      background: rgba(255, 255, 255, 0.7);
      border-radius: 50%;
      box-shadow: 0 0 2px rgba(0, 0, 0, 0.5);
    }

    /* Horizontal lines (left + right with gap) */
    #crosshair::before {
      content: '';
      position: absolute;
      top: 0px;
      left: -12px;
      width: 7px;
      height: 1.5px;
      background: rgba(255, 255, 255, 0.55);
      box-shadow:
        14px 0 0 rgba(255, 255, 255, 0.55),
        0 0 3px rgba(0, 0, 0, 0.4),
        14px 0 3px rgba(0, 0, 0, 0.4);
      border-radius: 1px;
    }

    /* Vertical lines (top + bottom with gap) */
    #crosshair::after {
      content: '';
      position: absolute;
      left: 0px;
      top: -12px;
      width: 1.5px;
      height: 7px;
      background: rgba(255, 255, 255, 0.55);
      box-shadow:
        0 14px 0 rgba(255, 255, 255, 0.55),
        0 0 3px rgba(0, 0, 0, 0.4),
        0 14px 3px rgba(0, 0, 0, 0.4);
      border-radius: 1px;
    }

    #phone-ui {
      position: fixed;
      bottom: -350px;
      right: 30px;
      width: 280px;
      height: auto;
      min-height: 180px;
      max-height: 50vh;
      background: #111;
      border-radius: 20px 20px 0 0;
      border: 4px solid #444;
      border-bottom: none;
      display: flex;
      flex-direction: column;
      padding: 15px;
      box-sizing: border-box;
      transition: bottom 0.6s cubic-bezier(0.175, 0.885, 0.32, 1.275);
      z-index: 20;
      color: white;
      box-shadow: -5px 5px 20px rgba(0, 0, 0, 0.6);
      overflow-y: auto;
    }

    #phone-ui.active { bottom: 0; }

    .phone-header {
      font-weight: bold;
      font-size: 18px;
      color: #4CAF50;
      border-bottom: 2px solid #333;
      padding-bottom: 8px;
      margin-bottom: 10px;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .phone-header::before {
      content: '';
      display: block;
      width: 10px;
      height: 10px;
      background: #4CAF50;
      border-radius: 50%;
      animation: blink 1s infinite;
    }

    #phone-text {
      font-size: 16px;
      line-height: 1.5;
      color: #eee;
      word-wrap: break-word;
    }

    #mission-success {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.85);
      z-index: 9999;
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      padding-top: 40px;
      padding-bottom: 40px;
      color: white;
      pointer-events: auto;
      font-family: 'Segoe UI', Tahoma, sans-serif;
      -webkit-transform: translateZ(0);
      transform: translateZ(0);
      overflow-y: auto;
      -webkit-overflow-scrolling: touch;
      box-sizing: border-box;
    }

    .ms-title {
      font-size: 64px;
      color: #ffd700;
      text-shadow: 4px 4px 0 #b8860b;
      margin-bottom: 40px;
      transform: scale(0);
      transition: transform 0.6s cubic-bezier(0.175, 0.885, 0.32, 1.275);
      font-weight: 900;
    }

    .ms-item {
      font-size: 28px;
      margin: 15px;
      opacity: 0;
      transform: translateY(30px);
      transition: all 0.5s ease;
      display: flex;
      align-items: center;
      gap: 20px;
      background: rgba(255, 255, 255, 0.1);
      padding: 15px 30px;
      border-radius: 12px;
      width: 450px;
      font-weight: bold;
    }

    .ms-icon { font-size: 36px; }

    .ms-btn {
      margin-top: 50px;
      padding: 20px 60px;
      font-size: 28px;
      background: #4CAF50;
      color: white;
      border: none;
      cursor: pointer;
      border-radius: 12px;
      opacity: 0;
      transition: opacity 0.5s;
      font-weight: bold;
      box-shadow: 0 6px 0 #2e7d32;
    }

    .ms-btn:active {
      transform: translateY(4px);
      box-shadow: 0 2px 0 #2e7d32;
    }

    #start-screen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.85);
      -webkit-transform: translateZ(0);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: white;
      pointer-events: auto;
      z-index: 100;
      text-align: center;
    }

    button.play-btn {
      padding: 20px 60px;
      font-size: 28px;
      background: #ff4500;
      color: white;
      border: none;
      cursor: pointer;
      border-radius: 8px;
      font-weight: bold;
      margin-top: 20px;
      transition: transform 0.1s, background 0.2s;
      font-family: inherit;
      box-shadow: 0 6px 0 #cc3700;
    }

    button.play-btn:active {
      transform: translateY(4px);
      box-shadow: 0 2px 0 #cc3700;
    }

    button.play-btn:hover { background: #ff5e22; }

    #tutorial-overlay {
      position: absolute;
      top: 75%;
      left: 50%;
      transform: translate(-50%, -50%);
      display: none;
      flex-direction: column;
      gap: 15px;
      align-items: center;
      background: rgba(0, 0, 0, 0.8);
      padding: 25px 40px;
      border-radius: 12px;
      pointer-events: none;
      z-index: 10;
      color: white;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      text-align: center;
      transition: opacity 0.5s ease;
      border: 2px solid #555;
    }

    .t-row {
      display: flex;
      gap: 15px;
      align-items: center;
      justify-content: center;
      margin-bottom: 10px;
    }

    .kbd {
      background: #eee;
      color: #111;
      border-radius: 5px;
      padding: 6px 12px;
      font-weight: bold;
      box-shadow: 0 4px 0 #999;
      font-size: 18px;
    }

    .tutorial-text {
      font-size: 20px;
      text-shadow: 1px 1px 0 #000;
      margin: 0;
    }

    #action-msg {
      position: absolute;
      bottom: 20%;
      left: 50%;
      transform: translateX(-50%);
      color: yellow;
      font-size: 24px;
      font-weight: bold;
      text-shadow: 2px 2px 0 #000;
      display: none;
    }

    #mobile-controls {
      display: none;
      position: absolute;
      bottom: 20px;
      left: 20px;
      right: 20px;
      height: 120px;
      pointer-events: auto;
      z-index: 50;
    }

    #joystick-area {
      width: 120px;
      height: 120px;
      background: rgba(255, 255, 255, 0.2);
      border-radius: 50%;
      position: absolute;
      left: 0;
      bottom: 0;
    }

    #joystick-knob {
      width: 50px;
      height: 50px;
      background: rgba(255, 255, 255, 0.6);
      border-radius: 50%;
      position: absolute;
      top: 35px;
      left: 35px;
    }

    .action-btns {
      position: absolute;
      right: 0;
      bottom: 0;
      display: flex;
      gap: 15px;
    }

    .m-btn {
      width: 60px;
      height: 60px;
      border-radius: 50%;
      background: rgba(255, 69, 0, 0.8);
      color: white;
      border: 2px solid #fff;
      font-weight: bold;
      font-size: 11px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    /* Hide tutorial controls overlay on mobile - too cluttered */
    @media (max-width: 768px), (pointer: coarse) {
      #tutorial-overlay { display: none !important; }
      #phone-ui {
        bottom: auto !important;
        top: -350px;
        right: 10px;
        left: 10px;
        width: auto;
        max-height: 35vh;
        border-radius: 0 0 20px 20px;
        border: 4px solid #444;
        border-top: none;
        transition: top 0.6s cubic-bezier(0.175, 0.885, 0.32, 1.275);
      }
      #phone-ui.active { top: 0 !important; bottom: auto !important; }
      .pause-content {
        flex-direction: column !important;
        gap: 15px !important;
        max-width: 90vw !important;
        overflow-y: auto;
        max-height: 60vh;
        padding: 0 10px;
      }
      .pause-title {
        font-size: 42px !important;
        margin-bottom: 10px !important;
      }
      .pause-panel {
        padding: 15px !important;
      }
      .pause-panel h2 {
        font-size: 18px !important;
      }
      .pause-panel p {
        font-size: 14px !important;
        margin: 6px 0 !important;
      }
      #action-msg {
        font-size: 14px !important;
      }
      #start-controls-desktop { display: none !important; }
      #start-controls-mobile { display: block !important; }
      /* Smaller minimap on mobile */
      #minimap-container {
        width: 90px !important;
        height: 90px !important;
        border-width: 2px !important;
      }
      #minimap { width: 90px !important; height: 90px !important; }
      /* Smaller health/NOS bars */
      .bar-container {
        width: 120px !important;
        height: 14px !important;
      }
      .bar-label {
        font-size: 10px !important;
        top: -2px !important;
      }
      /* Smaller score text */
      #score-display {
        font-size: 14px !important;
      }
      /* Smaller block counter */
      #block-counter {
        font-size: 10px !important;
        padding: 2px 5px !important;
      }
      /* Reduce HUD padding */
      .hud-top {
        padding: 8px 10px !important;
        font-size: 12px !important;
      }
      /* Ensure right-side buttons don't overflow */
      #swap-btn { display: none !important; }
      #pause-btn {
        padding: 4px 8px !important;
        font-size: 11px !important;
      }
      /* Smaller wanted stars */
      .stars {
        font-size: 16px !important;
      }
      /* Objective text smaller */
      #objective-text {
        font-size: 12px !important;
        max-width: 45vw;
        text-align: right;
      }
      /* Hotbar: move up well above joystick/action buttons */
      #hotbar {
        bottom: 170px !important;
      }
      #hotbar .hotbar-slot {
        width: 32px !important;
        height: 32px !important;
      }
      /* Mission success screen: fit on mobile */
      .ms-title {
        font-size: 32px !important;
        margin-bottom: 15px !important;
        text-shadow: 2px 2px 0 #b8860b !important;
        text-align: center !important;
        width: 100% !important;
        padding: 0 10px !important;
        box-sizing: border-box !important;
      }
      .ms-item {
        font-size: 16px !important;
        margin: 6px 10px !important;
        padding: 10px 15px !important;
        width: auto !important;
        max-width: 85vw;
        gap: 12px !important;
      }
      .ms-icon { font-size: 24px !important; }
      .ms-btn {
        margin-top: 20px !important;
        padding: 14px 40px !important;
        font-size: 20px !important;
      }
      /* Crosshair: slightly larger on mobile for visibility */
      #crosshair {
        width: 4px !important;
        height: 4px !important;
      }
      #crosshair::before {
        left: -15px !important;
        width: 9px !important;
        box-shadow:
          17px 0 0 rgba(255, 255, 255, 0.55),
          0 0 3px rgba(0, 0, 0, 0.4),
          17px 0 3px rgba(0, 0, 0, 0.4) !important;
      }
      #crosshair::after {
        top: -15px !important;
        height: 9px !important;
        box-shadow:
          0 17px 0 rgba(255, 255, 255, 0.55),
          0 0 3px rgba(0, 0, 0, 0.4),
          0 17px 3px rgba(0, 0, 0, 0.4) !important;
      }
      /* Compact store on mobile ‚Äî 3 columns */
      .store-title {
        font-size: 24px !important;
        margin-bottom: 3px !important;
      }
      .store-balance {
        font-size: 16px !important;
        margin-bottom: 5px !important;
      }
      .store-grid {
        gap: 6px !important;
        padding: 4px !important;
        max-width: 100% !important;
      }
      .store-item {
        padding: 6px 4px !important;
        width: 110px !important;
      }
      .store-item-icon {
        font-size: 22px !important;
        margin-bottom: 2px !important;
      }
      .store-item-name {
        font-size: 10px !important;
        margin-bottom: 1px !important;
      }
      .store-item-price {
        font-size: 11px !important;
      }
      .store-close-btn {
        padding: 16px 30px !important;
        font-size: 18px !important;
        padding-bottom: calc(16px + env(safe-area-inset-bottom, 0px)) !important;
      }
      .store-scroll {
        padding: 10px 0 !important;
      }
      /* Start screen & death screen mobile */
      #start-screen {
        padding: 24px !important;
        box-sizing: border-box !important;
        justify-content: center !important;
      }
      #start-screen h1 {
        font-size: 34px !important;
        letter-spacing: 1px !important;
        margin: 0 !important;
        line-height: 1.2 !important;
        padding: 0 10px !important;
      }
      #start-screen p {
        font-size: 16px !important;
        padding: 0 10px !important;
      }
      #start-controls-mobile {
        font-size: 16px !important;
        line-height: 2 !important;
        margin-top: 16px !important;
      }
      button.play-btn {
        padding: 16px 32px !important;
        font-size: 18px !important;
        max-width: calc(100% - 40px) !important;
        margin-top: 16px !important;
        box-sizing: border-box !important;
      }
      /* Pause screen mobile */
      .pause-title {
        font-size: 36px !important;
        margin-bottom: 10px !important;
        letter-spacing: 2px !important;
      }
      #pause-screen {
        padding: 20px !important;
        box-sizing: border-box !important;
      }
      #pause-screen .play-btn {
        margin-top: 12px !important;
      }
      /* Mobile help modal */
      #mobile-help-modal div {
        font-size: 16px !important;
      }
    }
    .phone-dismiss {
      font-size: 11px; color: #888; text-align: center; margin-top: 8px; cursor: pointer;
    }

    #pause-screen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.85);
      -webkit-transform: translateZ(0);
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: white;
      pointer-events: auto;
      z-index: 150;
      text-align: center;
    }

    .pause-title {
      font-size: 64px;
      color: #ffcc00;
      text-shadow: 4px 4px 0 #b8860b;
      margin-bottom: 20px;
      font-weight: 900;
      letter-spacing: 4px;
    }

    .pause-content {
      display: flex;
      gap: 30px;
      align-items: stretch;
      justify-content: center;
      max-width: 800px;
      margin-bottom: 30px;
    }

    .pause-panel {
      background: rgba(255, 255, 255, 0.1);
      padding: 25px;
      border-radius: 12px;
      border: 2px solid #555;
      text-align: left;
      flex: 1;
    }

    .pause-panel h2 {
      color: #4CAF50;
      margin-top: 0;
      border-bottom: 2px solid #333;
      padding-bottom: 10px;
      font-size: 24px;
    }

    .pause-panel p {
      font-size: 18px;
      line-height: 1.6;
      margin: 10px 0;
    }

    #store-ui {
      position: fixed; top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(0,0,0,0.95); display: none; z-index: 9999;
      flex-direction: column; align-items: center; color: white;
      overflow: hidden;
    }
    .store-scroll {
      flex: 1; min-height: 0; width: 100%; overflow-y: auto; -webkit-overflow-scrolling: touch;
      display: flex; flex-direction: column; align-items: center;
      padding: 15px 0;
    }
    .store-title { font-size: 48px; color: #4CAF50; text-shadow: 3px 3px 0 #1b5e20; margin-bottom: 10px; flex-shrink: 0; }
    .store-balance { font-size: 24px; color: #ffcc00; margin-bottom: 15px; flex-shrink: 0; }
    .store-grid { display: flex; flex-wrap: wrap; gap: 15px; justify-content: center; max-width: 700px; padding: 10px;
      align-content: flex-start;
    }
    .store-item {
      background: rgba(255,255,255,0.08); border: 2px solid #333; border-radius: 10px;
      padding: 15px; width: 140px; text-align: center; cursor: pointer; transition: all 0.2s;
      pointer-events: auto;
    }
    .store-item:hover { border-color: #4CAF50; background: rgba(76,175,80,0.15); }
    .store-item.owned { border-color: #666; opacity: 0.5; }
    .store-item.cant-afford { border-color: #600; opacity: 0.6; }
    .store-item-icon { font-size: 36px; margin-bottom: 8px; }
    .store-item-name { font-size: 14px; font-weight: bold; margin-bottom: 5px; }
    .store-item-price { font-size: 16px; color: #ffcc00; }
    .store-close-btn {
      flex-shrink: 0; width: 100%;
      padding: 18px 40px; font-size: 22px; background: #c62828;
      color: white; border: none; cursor: pointer; pointer-events: auto;
      border-top: 3px solid #e53935; box-sizing: border-box;
      font-weight: bold; letter-spacing: 2px;
    }
    .store-close-btn:hover { background: #e53935; }

    .float-text {
      position: absolute; color: #22ff22; font-size: 22px; font-weight: bold;
      text-shadow: 2px 2px 0 #000, -1px -1px 0 #000; pointer-events: none; z-index: 50;
      transition: all 1s ease-out; white-space: nowrap;
    }
  </style>
</head>

<body>
  <canvas id="game-canvas"></canvas>

  <div id="crime-overlay"></div>
  <div id="crime-text">CRIME REPORTED!</div>

  <div id="phone-ui" style="display:none;">
    <div class="phone-header">Message from: Boss</div>
    <div id="phone-text"></div>
    <div class="phone-dismiss" id="phone-dismiss"></div>
  </div>

  <div id="mission-success"></div>

  <div id="store-ui">
    <div class="store-scroll" id="store-scroll">
      <div class="store-title">WEAPON SHOP</div>
      <div class="store-balance" id="store-balance">$0</div>
      <div class="store-grid" id="store-grid"></div>
    </div>
    <button class="store-close-btn" onclick="closeStore()" ontouchstart="event.preventDefault(); closeStore();">LEAVE SHOP</button>
  </div>

  <div id="vignette"></div>
  <div id="damage-flash"></div>
  <div id="ui-layer">
    <div class="hud-top">
      <div id="hud-left">
        <div id="minimap-container"><canvas id="minimap" width="150" height="150"></canvas></div>
        <div id="score-display">$0</div>
        <div id="block-counter" style="display:none; background:rgba(0,0,0,0.6); border:1px solid #888; border-radius:4px; padding:3px 8px; color:white; font-size:12px; cursor:pointer; pointer-events:auto; margin-top:3px; font-family:monospace;" onclick="toggleBlockSelector()">üß± 0</div>
        <div class="bar-container">
          <div id="health-fill" class="bar-fill"></div><span class="bar-label">HP</span>
        </div>
        <div id="car-hud">
          <div class="bar-container">
            <div id="car-health-fill" class="bar-fill"></div><span class="bar-label">CAR HP</span>
          </div>
          <div class="bar-container" style="margin-top:5px;">
            <div id="nos-fill" class="bar-fill"></div><span class="bar-label">NOS</span>
          </div>
        </div>
      </div>
      <div>
        <div style="text-align: right; margin-bottom: 5px;">
          <button id="swap-btn" onclick="cycleWeapon()" style="display:none; background: rgba(255,180,0,0.3); border: 1px solid #ffcc00; color: #ffcc00; border-radius: 4px; padding: 5px 10px; cursor: pointer; font-weight: bold; pointer-events: auto; margin-right: 6px;">Swap</button><button id="desktop-build-btn" onclick="toggleBuildMode()" style="display:none; background: rgba(255,204,0,0.3); border: 1px solid #ffcc00; color: #ffcc00; border-radius: 4px; padding: 5px 10px; cursor: pointer; font-weight: bold; pointer-events: auto; margin-right: 6px;">Build [Shift]</button><button id="pause-btn" onclick="togglePause()" ontouchstart="event.preventDefault(); event.stopPropagation(); togglePause();" style="background: rgba(255,255,255,0.2); border: 1px solid #fff; color: white; border-radius: 4px; padding: 5px 10px; cursor: pointer; font-weight: bold; pointer-events: auto;">Pause [P]</button>
        </div>
        <div id="wanted-level" class="stars"><span id="s1">‚òÖ</span><span id="s2">‚òÖ</span><span id="s3">‚òÖ</span><span id="s4">‚òÖ</span><span id="s5">‚òÖ</span></div>
        <div id="objective-text">MISSION 1: ROB THE BANK</div>
        <div id="car-counter" style="display:none; gap:4px; justify-content:center; margin-top:5px;"></div>
      </div>
    </div>
    <div id="demolition-progress" style="display:none;">
      <div id="demo-building">
        <div id="demo-fill"></div>
        <div id="demo-pct">0%</div>
      </div>
      <div id="demo-label">DEMOLITION</div>
    </div>
    <div id="crosshair"></div>
    <div id="waypoint-arrow">
      <div id="waypoint-dist"></div>
    </div>
    <div id="action-msg"></div>

    <div id="tutorial-overlay">
      <div class="t-row"><span class="kbd">W</span><span class="kbd">A</span><span class="kbd">S</span><span class="kbd">D</span><span class="tutorial-text" style="margin-left:15px;">Move / Drive / Fly</span></div>
      <div class="t-row"><span class="tutorial-text">Click: Shoot (on foot) / NOS Boost (in vehicle)</span></div>
      <div class="t-row"><span class="kbd" style="padding: 6px 30px;">SPACE</span><span class="tutorial-text">Jump (on foot & in vehicle) / Climb (Plane)</span></div>
      <div class="t-row"><span class="kbd" style="padding: 6px 14px;">Enter</span><span class="tutorial-text">Enter Vehicles & Planes / Rob Bank</span></div>
      <div class="t-row"><span class="kbd" style="padding: 6px 10px;">Shift</span><span class="tutorial-text">Swap Weapon / Build Mode / Right-Click Place</span></div>
    </div>
  </div>

  <!-- Mobile Controls Layer -->
  <div id="mobile-controls">
    <div id="joystick-area">
      <div id="joystick-knob"></div>
    </div>
    <div class="action-btns">
      <button id="btn-build" class="m-btn" style="display:none; background:rgba(255,204,0,0.4); font-size:12px;">Build</button>
      <button id="btn-interact" class="m-btn" style="display:none;">Drive</button>
      <button id="btn-jump" class="m-btn">Jump</button>
    </div>
  </div>

  <div id="mobile-help-modal" style="display:none; position:absolute; top:0; left:0; right:0; bottom:0; z-index:100; background:rgba(0,0,0,0.85); color:white; font-family:sans-serif;">
    <div style="position:absolute; top:50%; left:0; right:0; transform:translateY(-50%); text-align:center; padding:0 30px;">
      <div style="font-size:20px; line-height:2.5; text-align:left; max-width:300px; margin:0 auto;">
        <div>Use joystick to move</div>
        <div>Drag screen to look around</div>
        <div>Tap to shoot</div>
      </div>
      <div style="margin-top:40px; font-size:14px; color:#888;">Tap anywhere to continue</div>
    </div>
  </div>

  <div id="start-screen">
    <h1 style="font-size: 54px; color: gold; text-shadow: 5px 5px 0 #000, -2px -2px 0 #b8860b; margin: 0; letter-spacing: 2px;">JEE TEE AYY SIX</h1>
    <div id="start-controls-desktop" style="margin-top: 24px; display: flex; flex-direction: column; gap: 20px; align-items: center;">
      <div style="display:flex; align-items:center; gap:10px;"><span class="kbd" style="font-size:18px; padding:6px 12px;">W</span><span class="kbd" style="font-size:18px; padding:6px 12px;">A</span><span class="kbd" style="font-size:18px; padding:6px 12px;">S</span><span class="kbd" style="font-size:18px; padding:6px 12px;">D</span><span style="color:#ccc; font-size:18px; margin-left:6px;">Move / Drive</span></div>
      <div style="display:flex; align-items:center; gap:10px;"><span class="kbd" style="font-size:18px; padding:6px 12px;">Mouse</span><span style="color:#888; font-size:18px;">Look & Aim</span></div>
      <div style="display:flex; align-items:center; gap:10px;"><span class="kbd" style="font-size:18px; padding:6px 12px;">Click</span><span style="color:#888; font-size:18px;">Shoot / NOS Boost</span></div>
      <div style="display:flex; align-items:center; gap:10px;"><span class="kbd" style="font-size:18px; padding:6px 16px;">Space</span><span style="color:#888; font-size:18px;">Jump / Fly</span></div>
      <div style="display:flex; align-items:center; gap:10px;"><span class="kbd" style="font-size:18px; padding:6px 16px;">Enter</span><span style="color:#888; font-size:18px;">Drive / Interact</span></div>
      <div style="display:flex; align-items:center; gap:10px;"><span class="kbd" style="font-size:18px; padding:6px 12px;">Shift</span><span style="color:#888; font-size:18px;">Swap Weapon / Build</span></div>
    </div>
    <div id="start-controls-mobile" style="margin-top: 24px; display: none; text-align: center; font-size: 20px; line-height: 2.2; color: #ccc;">
      <div>üïπÔ∏è Left stick to move</div>
      <div>üëÜ Drag to look around</div>
      <div>üëä Tap to shoot</div>
      <div id="grenade-hint" style="display:none;">üî® Long hold to throw grenade</div>
    </div>
    <button id="start-btn" class="play-btn">START MISSION 1</button>
  </div>

  <div id="pause-screen">
    <div class="pause-title">PAUSED</div>
    <div class="pause-content">
      <div class="pause-panel">
        <h2>Controls</h2>
        <p><b>W, A, S, D:</b> Move / Drive / Fly</p>
        <p><b>Mouse:</b> Look & Shoot</p>
        <p><b>SPACE:</b> Jump / NOS / Swim / Climb</p>
        <p><b>Enter:</b> Enter Vehicles & Planes</p>
        <p><b>P / ESC:</b> Pause / Unpause</p>
      </div>
      <div class="pause-panel">
        <h2>Current Mission</h2>
        <p id="pause-mission-text">Waiting for instructions...</p>
      </div>
    </div>
    <button class="play-btn" onclick="togglePause()">RESUME</button>
    <div style="position:absolute; bottom:20px; left:0; right:0; text-align:center; font-size:12px; color:#888; font-family:sans-serif;">Music by: Bread Club</div>
  </div>

  <!-- Minecraft-style Hotbar -->
  <div id="hotbar" style="display:none; position:fixed; bottom:10px; left:50%; transform:translateX(-50%); z-index:50; pointer-events:none; gap:2px; align-items:center;">
    <div class="hotbar-slot" style="width:44px; height:44px; border:2px solid #555; border-radius:4px; display:flex; flex-direction:column; align-items:center; justify-content:center; color:white; font-family:monospace; cursor:pointer; pointer-events:auto; transition:border-color 0.1s;"></div>
    <div class="hotbar-slot" style="width:44px; height:44px; border:2px solid #555; border-radius:4px; display:flex; flex-direction:column; align-items:center; justify-content:center; color:white; font-family:monospace; cursor:pointer; pointer-events:auto; transition:border-color 0.1s;"></div>
    <div class="hotbar-slot" style="width:44px; height:44px; border:2px solid #555; border-radius:4px; display:flex; flex-direction:column; align-items:center; justify-content:center; color:white; font-family:monospace; cursor:pointer; pointer-events:auto; transition:border-color 0.1s;"></div>
    <div class="hotbar-slot" style="width:44px; height:44px; border:2px solid #555; border-radius:4px; display:flex; flex-direction:column; align-items:center; justify-content:center; color:white; font-family:monospace; cursor:pointer; pointer-events:auto; transition:border-color 0.1s;"></div>
    <div class="hotbar-slot" style="width:44px; height:44px; border:2px solid #555; border-radius:4px; display:flex; flex-direction:column; align-items:center; justify-content:center; color:white; font-family:monospace; cursor:pointer; pointer-events:auto; transition:border-color 0.1s;"></div>
    <div class="hotbar-slot" style="width:44px; height:44px; border:2px solid #555; border-radius:4px; display:flex; flex-direction:column; align-items:center; justify-content:center; color:white; font-family:monospace; cursor:pointer; pointer-events:auto; transition:border-color 0.1s;"></div>
    <div class="hotbar-slot" style="width:44px; height:44px; border:2px solid #555; border-radius:4px; display:flex; flex-direction:column; align-items:center; justify-content:center; color:white; font-family:monospace; cursor:pointer; pointer-events:auto; transition:border-color 0.1s;"></div>
    <div class="hotbar-slot" style="width:44px; height:44px; border:2px solid #555; border-radius:4px; display:flex; flex-direction:column; align-items:center; justify-content:center; color:white; font-family:monospace; cursor:pointer; pointer-events:auto; transition:border-color 0.1s;"></div>
    <div class="hotbar-slot" style="width:44px; height:44px; border:2px solid #555; border-radius:4px; display:flex; flex-direction:column; align-items:center; justify-content:center; color:white; font-family:monospace; cursor:pointer; pointer-events:auto; transition:border-color 0.1s;"></div>
  </div>

  <div id="block-selector" style="display:none; position:fixed; top:50%; left:50%; transform:translate(-50%,-50%); background:rgba(20,20,20,0.95); border:2px solid #888; border-radius:8px; padding:15px; z-index:200; pointer-events:auto; max-width:350px;">
    <div style="color:white; font-size:16px; font-weight:bold; text-align:center; margin-bottom:10px;">Select Block</div>
    <div id="block-grid" style="display:grid; grid-template-columns: repeat(5, 1fr); gap:8px;"></div>
    <div style="text-align:center; margin-top:10px;"><button onclick="closeBlockSelector()" style="background:#555; color:white; border:none; padding:5px 15px; border-radius:4px; cursor:pointer;">Close</button></div>
  </div>

  <script type="module">
    import * as THREE from 'three';
    import { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'three/examples/jsm/postprocessing/UnrealBloomPass.js';

    // --- Performance Pre-allocated Vectors ---
    const _tv1 = new THREE.Vector3();
    const _tv2 = new THREE.Vector3();
    const _tv3 = new THREE.Vector3();
    const _tv4 = new THREE.Vector3();
    const _tv5 = new THREE.Vector3();
    const _tv6 = new THREE.Vector3();
    const _upVec = new THREE.Vector3(0, 1, 0);
    const _lightOffset = new THREE.Vector3(120, 250, 80);

    // --- Custom Shader Uniforms ---
    let customUniforms = { time: { value: 0 } };

    // --- Math & Noise ---
    function hash2D(x, z) {
      let h = Math.sin(x * 12.9898 + z * 78.233) * 43758.5453123;
      return h - Math.floor(h);
    }

    function smoothNoise(x, z) {
      let ix = Math.floor(x);
      let iz = Math.floor(z);
      let fx = x - ix;
      let fz = z - iz;
      let h00 = hash2D(ix, iz);
      let h10 = hash2D(ix + 1, iz);
      let h01 = hash2D(ix, iz + 1);
      let h11 = hash2D(ix + 1, iz + 1);
      let ux = fx * fx * (3 - 2 * fx);
      let uz = fz * fz * (3 - 2 * fz);
      return h00 * (1 - ux) * (1 - uz) + h10 * ux * (1 - uz) + h01 * (1 - ux) * uz + h11 * ux * uz;
    }

    // --- REALISTIC PBR Textures ---
    function createTex(type) {
      const c = document.createElement('canvas'); c.width = 64; c.height = 64;
      const ctx = c.getContext('2d');
      const b = document.createElement('canvas'); b.width = 64; b.height = 64;
      const btx = b.getContext('2d');
      const r = document.createElement('canvas'); r.width = 64; r.height = 64;
      const rtx = r.getContext('2d');
      
      btx.fillStyle = '#888888'; btx.fillRect(0, 0, 64, 64);
      rtx.fillStyle = '#dddddd'; rtx.fillRect(0, 0, 64, 64);
      
      let drawNoise = (cctx, color1, color2, density) => {
        for (let x = 0; x < 64; x += 4) {
          for (let y = 0; y < 64; y += 4) {
            if (Math.random() > density) {
              cctx.fillStyle = Math.random() > 0.5 ? color1 : color2;
              cctx.fillRect(x, y, 4, 4);
            }
          }
        }
      };
      
      if (type === 'ROAD' || type === 'HIGHWAY') {
        ctx.fillStyle = type === 'ROAD' ? '#2c2c2c' : '#333333'; ctx.fillRect(0, 0, 64, 64);
        drawNoise(ctx, '#353535', '#222222', 0.5);
        drawNoise(btx, '#aaaaaa', '#666666', 0.5);
      } else if (type === 'GRASS') {
        ctx.fillStyle = '#4da62a'; ctx.fillRect(0, 0, 64, 64);
        drawNoise(ctx, '#5cc435', '#3d8820', 0.5);
        drawNoise(btx, '#ffffff', '#444444', 0.2);
        rtx.fillStyle = '#ffffff'; rtx.fillRect(0, 0, 64, 64);
      } else if (type === 'WATER') {
        ctx.fillStyle = '#1a7ab5'; ctx.fillRect(0, 0, 64, 64);
        drawNoise(ctx, '#2896d4', '#156a9e', 0.7);
        drawNoise(btx, '#ffffff', '#444444', 0.6);
        rtx.fillStyle = '#111111'; rtx.fillRect(0, 0, 64, 64);
      } else if (type === 'WOOD') {
        ctx.fillStyle = '#6b5136'; ctx.fillRect(0, 0, 64, 64);
        drawNoise(ctx, '#7a5d3e', '#59442d', 0.5);
        ctx.fillStyle = '#423221'; btx.fillStyle = '#444';
        for (let i = 4; i < 64; i += 16) {
          ctx.fillRect(i, 0, 2, 64); btx.fillRect(i, 0, 2, 64);
        }
      } else if (type === 'LEAVES') {
        ctx.fillStyle = '#2d8c1a'; ctx.fillRect(0, 0, 64, 64);
        for (let x = 0; x < 64; x += 4) {
          for (let y = 0; y < 64; y += 4) {
            let ran = Math.random();
            if (ran > 0.8) { ctx.fillStyle = '#1a4d10'; btx.fillStyle = '#222'; }
            else if (ran > 0.4) { ctx.fillStyle = Math.random() > 0.5 ? '#3ba828' : '#228815'; btx.fillStyle = '#eee'; }
            else continue;
            ctx.fillRect(x, y, 4, 4); btx.fillRect(x, y, 4, 4);
          }
        }
      } else if (type === 'BRICK' || type === 'BRICK_RED' || type === 'BRICK_BROWN') {
        let base = '#606060', dark = '#505050', light = '#707070', mortar = '#383838';
        if (type === 'BRICK_RED') { base = '#8c3830'; dark = '#7a2c24'; light = '#a04a40'; mortar = '#aaaaaa'; }
        if (type === 'BRICK_BROWN') { base = '#5a3e2c'; dark = '#483020'; light = '#6a4e3a'; mortar = '#444444'; }
        ctx.fillStyle = base; ctx.fillRect(0, 0, 64, 64);
        btx.fillStyle = '#cccccc'; btx.fillRect(0, 0, 64, 64);
        drawNoise(ctx, light, dark, 0.5);
        ctx.fillStyle = mortar; btx.fillStyle = '#222222';
        for (let y = 0; y < 64; y += 16) {
          ctx.fillRect(0, y, 64, 2); btx.fillRect(0, y, 64, 2);
          let off = (y / 16) % 2 === 0 ? 0 : 8;
          for (let x = 0; x <= 64; x += 16) {
            ctx.fillRect(x + off, y, 2, 16); btx.fillRect(x + off, y, 2, 16);
          }
        }
      } else if (type === 'GLASS' || type === 'GLASS_BLUE' || type === 'GLASS_DARK') {
        let base = '#7ab8dd', frame = '#5a99bb';
        if (type === 'GLASS_BLUE') { base = '#4a7ea8'; frame = '#3a6688'; }
        if (type === 'GLASS_DARK') { base = '#152028'; frame = '#0a0f14'; }
        ctx.fillStyle = base; ctx.fillRect(0, 0, 64, 64);
        ctx.fillStyle = 'rgba(255,255,255,0.4)'; ctx.fillRect(8, 8, 16, 4); ctx.fillRect(8, 12, 4, 12);
        ctx.strokeStyle = frame; ctx.lineWidth = 4; ctx.strokeRect(2, 2, 60, 60);
        btx.fillStyle = '#ffffff'; btx.fillRect(0, 0, 64, 64);
        btx.fillStyle = '#444'; btx.fillRect(2, 2, 60, 60);
        rtx.fillStyle = '#111111'; rtx.fillRect(0, 0, 64, 64);
      } else if (type === 'CONCRETE' || type === 'CONCRETE_DARK' || type === 'PLASTER_LIGHT' || type === 'PLASTER_WARM') {
        let base = '#787878', d1 = '#888888', d2 = '#686868';
        if (type === 'CONCRETE_DARK') { base = '#3a3a3a'; d1 = '#484848'; d2 = '#2c2c2c'; }
        if (type === 'PLASTER_LIGHT') { base = '#c8c0b4'; d1 = '#d4ccc2'; d2 = '#b8b0a4'; }
        if (type === 'PLASTER_WARM') { base = '#c49458'; d1 = '#d4a468'; d2 = '#b48448'; }
        ctx.fillStyle = base; ctx.fillRect(0, 0, 64, 64);
        drawNoise(ctx, d1, d2, 0.7);
        drawNoise(btx, '#aaaaaa', '#666666', 0.7);
        ctx.strokeStyle = d2; ctx.lineWidth = 2; ctx.strokeRect(1, 1, 62, 62);
      } else if (type === 'SIDEWALK') {
        ctx.fillStyle = '#a0a0a0'; ctx.fillRect(0, 0, 64, 64);
        drawNoise(ctx, '#b0b0b0', '#909090', 0.6);
        // Paving pattern
        ctx.strokeStyle = '#808080'; ctx.lineWidth = 2;
        ctx.strokeRect(2, 2, 30, 30); ctx.strokeRect(34, 2, 28, 30);
        ctx.strokeRect(2, 34, 30, 28); ctx.strokeRect(34, 34, 28, 28);
        drawNoise(btx, '#aaaaaa', '#666666', 0.7);
      } else if (type === 'RAIL') {
        ctx.fillStyle = '#444444'; ctx.fillRect(0, 0, 64, 64);
        ctx.fillStyle = '#666666'; ctx.fillRect(0, 28, 64, 8);
        ctx.fillStyle = '#888888'; ctx.fillRect(0, 30, 64, 4);
        drawNoise(ctx, '#555555', '#333333', 0.6);
        drawNoise(btx, '#999999', '#555555', 0.6);
        rtx.fillStyle = '#333333'; rtx.fillRect(0, 0, 64, 64);
      } else if (type === 'GOLD') {
        ctx.fillStyle = '#d4af37'; ctx.fillRect(0, 0, 64, 64);
        ctx.fillStyle = '#f1c40f'; ctx.fillRect(4, 4, 56, 56);
        btx.fillStyle = '#555'; btx.fillRect(0, 0, 64, 64);
        btx.fillStyle = '#fff'; btx.fillRect(4, 4, 56, 56);
        rtx.fillStyle = '#222222'; rtx.fillRect(0, 0, 64, 64);
      } else if (type === 'LIGHT') {
        ctx.fillStyle = '#ffffff'; ctx.fillRect(0, 0, 64, 64);
        ctx.fillStyle = '#ffffaa'; ctx.fillRect(8, 8, 48, 48);
      } else if (type === 'DIRT') {
        ctx.fillStyle = '#79553a'; ctx.fillRect(0, 0, 64, 64);
        drawNoise(ctx, '#8b6343', '#664730', 0.5);
        drawNoise(btx, '#ffffff', '#222222', 0.4);
      } else if (type === 'STEEL') {
        ctx.fillStyle = '#555555'; ctx.fillRect(0, 0, 64, 64);
        drawNoise(ctx, '#666', '#444', 0.5);
        ctx.strokeStyle = '#333'; ctx.lineWidth = 4; ctx.strokeRect(0, 0, 64, 64);
        rtx.fillStyle = '#555555'; rtx.fillRect(0, 0, 64, 64);
      } else if (type === 'STONE') {
        ctx.fillStyle = '#808080'; ctx.fillRect(0, 0, 64, 64);
        drawNoise(ctx, '#999', '#6a6a6a', 0.4);
        drawNoise(btx, '#aaa', '#555', 0.5);
      } else if (type === 'IRON_ORE') {
        ctx.fillStyle = '#808080'; ctx.fillRect(0, 0, 64, 64);
        drawNoise(ctx, '#999', '#6a6a6a', 0.4);
        // Iron ore spots (tan/beige)
        for (let i = 0; i < 8; i++) { let ox = Math.floor(Math.random()*52)+4, oy = Math.floor(Math.random()*52)+4; ctx.fillStyle = '#c8a882'; ctx.fillRect(ox, oy, 8, 8); ctx.fillStyle = '#d4b896'; ctx.fillRect(ox+2, oy+2, 4, 4); }
        drawNoise(btx, '#aaa', '#555', 0.5);
      } else if (type === 'COAL_ORE') {
        ctx.fillStyle = '#808080'; ctx.fillRect(0, 0, 64, 64);
        drawNoise(ctx, '#999', '#6a6a6a', 0.4);
        // Coal spots (black)
        for (let i = 0; i < 8; i++) { let ox = Math.floor(Math.random()*52)+4, oy = Math.floor(Math.random()*52)+4; ctx.fillStyle = '#1a1a1a'; ctx.fillRect(ox, oy, 8, 8); ctx.fillStyle = '#2a2a2a'; ctx.fillRect(ox+2, oy+2, 4, 4); }
        drawNoise(btx, '#aaa', '#555', 0.5);
      } else if (type === 'DIAMOND_ORE') {
        ctx.fillStyle = '#808080'; ctx.fillRect(0, 0, 64, 64);
        drawNoise(ctx, '#999', '#6a6a6a', 0.4);
        // Diamond spots (light blue/cyan)
        for (let i = 0; i < 6; i++) { let ox = Math.floor(Math.random()*52)+4, oy = Math.floor(Math.random()*52)+4; ctx.fillStyle = '#4de8e0'; ctx.fillRect(ox, oy, 8, 8); ctx.fillStyle = '#7df4ef'; ctx.fillRect(ox+2, oy+2, 4, 4); }
        drawNoise(btx, '#aaa', '#555', 0.5);
      }
      const texMap = new THREE.CanvasTexture(c); texMap.magFilter = THREE.NearestFilter; texMap.minFilter = THREE.NearestFilter;
      const texBump = new THREE.CanvasTexture(b); texBump.magFilter = THREE.NearestFilter; texBump.minFilter = THREE.NearestFilter;
      const texRough = new THREE.CanvasTexture(r); texRough.magFilter = THREE.NearestFilter; texRough.minFilter = THREE.NearestFilter;
      return { map: texMap, bumpMap: texBump, roughnessMap: texRough };
    }

    function buildPBRMaterial(texObj, baseParams = {}) {
      return new THREE.MeshStandardMaterial({
        map: texObj.map, bumpMap: texObj.bumpMap, bumpScale: 0.08, roughnessMap: texObj.roughnessMap, ...baseParams
      });
    }

    // --- Bright Daytime Skybox ---
    function createSkyTexture() {
      const c = document.createElement('canvas'); c.width = 2048; c.height = 1024;
      const ctx = c.getContext('2d');
      let grad = ctx.createLinearGradient(0, 0, 0, 1024);
      grad.addColorStop(0, "#1a5fa8");
      grad.addColorStop(0.2, "#3a8fd4");
      grad.addColorStop(0.4, "#6cb4e8");
      grad.addColorStop(0.48, "#9dd5f5");
      grad.addColorStop(0.5, "#c8e8fa");
      grad.addColorStop(0.52, "#a8d4a0");
      grad.addColorStop(0.6, "#6aaa5c");
      grad.addColorStop(1, "#2d5a27");
      ctx.fillStyle = grad; ctx.fillRect(0, 0, 2048, 1024);
      // Sun
      ctx.fillStyle = "#fffde0"; ctx.fillRect(1000, 180, 80, 80);
      ctx.fillStyle = "rgba(255, 253, 200, 0.3)"; ctx.fillRect(980, 160, 120, 120);
      ctx.fillStyle = "rgba(255, 253, 200, 0.15)"; ctx.fillRect(950, 130, 180, 180);
      // Fluffy clouds
      ctx.fillStyle = "rgba(255, 255, 255, 0.75)";
      for (let i = 0; i < 70; i++) {
        let cx = Math.random() * 2048, cy = Math.random() * 180 + 160, cw = Math.random() * 180 + 60, ch = Math.random() * 25 + 10;
        for (let j = 0; j < 6; j++) {
          let ox = (Math.random() - 0.5) * cw * 0.7;
          let oy = (Math.random() - 0.5) * ch;
          let sw = Math.random() * cw * 0.5 + 20;
          let sh = Math.random() * ch * 0.5 + 6;
          ctx.fillRect(Math.floor((cx + ox) / 8) * 8, Math.floor((cy + oy) / 8) * 8, Math.floor(sw / 8) * 8, Math.floor(sh / 8) * 8);
        }
      }
      ctx.fillStyle = "rgba(255, 255, 255, 0.4)";
      for (let i = 0; i < 40; i++) {
        let cx = Math.random() * 2048, cy = Math.random() * 120 + 200;
        let cw = Math.random() * 80 + 30, ch = Math.random() * 12 + 5;
        ctx.fillRect(Math.floor(cx / 8) * 8, Math.floor(cy / 8) * 8, Math.floor(cw / 8) * 8, Math.floor(ch / 8) * 8);
      }
      return new THREE.CanvasTexture(c);
    }

    // --- Constants & Globals ---
    const CHUNK_SIZE = 48;
    const VIEW_DISTANCE = 4;
    const ROAD_WIDTH = 12;
    const ZONE_DOWNTOWN_R = 200;
    const ZONE_URBAN_R = 450;
    const ZONE_SUBURBAN_R = 750;
    const ZONE_RURAL_R = 1000;
    const AIRPORT_X = 350;
    const AIRPORT_Z = -300;
    const ISLAND_X = -400;
    const ISLAND_Z = 400;

    function getZone(wx, wz) {
      let dist = Math.sqrt(wx * wx + wz * wz);
      let apDist = Math.sqrt((wx - AIRPORT_X) * (wx - AIRPORT_X) + (wz - AIRPORT_Z) * (wz - AIRPORT_Z));
      if (apDist < 130) return 'AIRPORT';
      let isDist = Math.sqrt((wx - ISLAND_X) * (wx - ISLAND_X) + (wz - ISLAND_Z) * (wz - ISLAND_Z));
      if (isDist < 80) return 'ISLAND';
      if (dist < ZONE_DOWNTOWN_R) return 'DOWNTOWN';
      if (dist < ZONE_URBAN_R) return 'URBAN';
      if (dist < ZONE_SUBURBAN_R) return 'SUBURBAN';
      if (dist < ZONE_RURAL_R) return 'RURAL';
      return 'OCEAN';
    }
    const TYPES = {
      EMPTY: 0, GRASS: 1, ROAD: 2, BRICK: 3, GLASS: 4, CONCRETE: 5, GOLD: 6, LIGHT: 7, WOOD: 8, DIRT: 9, STEEL: 10, WATER: 11, LEAVES: 12, HIGHWAY: 13, BLUE: 14, WHITE: 15, RED: 16, BRICK_RED: 17, BRICK_BROWN: 18, PLASTER_LIGHT: 19, PLASTER_WARM: 20, CONCRETE_DARK: 21, GLASS_BLUE: 22, GLASS_DARK: 23, SIDEWALK: 24, RAIL: 25, YELLOW: 26, GREEN: 27, STONE: 28, IRON_ORE: 29, COAL_ORE: 30, DIAMOND_ORE: 31, SNOW: 32, SAND: 33
    };
    // Biome system: determines ground type based on world position
    function getBiome(wx, wz) {
      // Snow: northeast corner (positive x, negative z)
      if (wx > 500 && wz < -500) return 'SNOW';
      if (wx > 400 && wz < -400) { let blend = Math.min((wx-400)/100, (-wz-400)/100); if (blend > 0.5) return 'SNOW'; }
      // Desert: southeast corner (positive x, positive z)
      if (wx > 500 && wz > 500) return 'DESERT';
      if (wx > 400 && wz > 400) { let blend = Math.min((wx-400)/100, (wz-400)/100); if (blend > 0.5) return 'DESERT'; }
      // Mountain: southwest area
      let mtDist = Math.sqrt((wx + 600) * (wx + 600) + (wz + 200) * (wz + 200));
      if (mtDist < 120) return 'MOUNTAIN';
      return 'NORMAL';
    }
    const MATERIALS = {};
    const MAX_PARTICLES = 300;
    
    let scene, camera, renderer, minimapCtx, skybox, dirLight, composer;
    let isPlaying = false, isPaused = false;
    let score = 0, chaos = 0, wantedLevel = 0, copsKilled = 0, wantedTimer = 30, copSpawnTimer = 0;
    let copNearbyWhenChaos = false, blocksDestroyedRecently = 0, blockDestroyTimer = 0;
    let evadingMessage = false;
    let playerHealth = 2000, maxHealth = 2000, armorHP = 0, grenadeCount = 0;
    let player = null, currentVehicle = null;
    let vehicles = [], peds = [], projectiles = [], particlePool = [], skidMarks = [];
    let keys = { forward: false, backward: false, left: false, right: false, space: false };
    let touchMove = new THREE.Vector2(0, 0);
    const isMobileDevice = ('ontouchstart' in window) || window.matchMedia('(pointer: coarse)').matches;
    // Simple SFX using oscillator
    let sfxCtx = null;
    function playSFX(type) {
      try {
        if (!sfxCtx) sfxCtx = new (window.AudioContext || window.webkitAudioContext)();
        let osc = sfxCtx.createOscillator();
        let gain = sfxCtx.createGain();
        osc.connect(gain); gain.connect(sfxCtx.destination);
        gain.gain.value = 0.08;
        if (type === 'place') {
          osc.frequency.value = 800; gain.gain.value = 0.06;
          osc.type = 'square';
          gain.gain.exponentialRampToValueAtTime(0.001, sfxCtx.currentTime + 0.1);
          osc.start(); osc.stop(sfxCtx.currentTime + 0.1);
        } else if (type === 'mine') {
          osc.frequency.value = 200 + Math.random() * 100;
          osc.type = 'sawtooth'; gain.gain.value = 0.04;
          gain.gain.exponentialRampToValueAtTime(0.001, sfxCtx.currentTime + 0.08);
          osc.start(); osc.stop(sfxCtx.currentTime + 0.08);
        } else if (type === 'pickup') {
          osc.frequency.value = 600; osc.type = 'sine'; gain.gain.value = 0.05;
          osc.frequency.exponentialRampToValueAtTime(1200, sfxCtx.currentTime + 0.15);
          gain.gain.exponentialRampToValueAtTime(0.001, sfxCtx.currentTime + 0.15);
          osc.start(); osc.stop(sfxCtx.currentTime + 0.15);
        }
      } catch(e) {}
    }
    let tankAimYaw = 0, tankAimPitch = 0, lastTankShot = 0;
    let activeChunks = new Map();
    let isMouseDown = false;
    let buildMode = false;
    let blockInventory = {}; // { blockType: count }
    let selectedBlockType = TYPES.BRICK;
    let totalBlocks = 0;
    const BLOCK_NAMES = { [TYPES.GRASS]: 'Grass', [TYPES.BRICK]: 'Brick', [TYPES.GLASS]: 'Glass', [TYPES.CONCRETE]: 'Concrete', [TYPES.GOLD]: 'Gold', [TYPES.WOOD]: 'Wood', [TYPES.DIRT]: 'Dirt', [TYPES.STEEL]: 'Steel', [TYPES.LEAVES]: 'Leaves', [TYPES.RED]: 'Red', [TYPES.BLUE]: 'Blue', [TYPES.WHITE]: 'White', [TYPES.YELLOW]: 'Yellow', [TYPES.GREEN]: 'Green', [TYPES.STONE]: 'Stone', [TYPES.IRON_ORE]: 'Iron Ore', [TYPES.COAL_ORE]: 'Coal Ore', [TYPES.DIAMOND_ORE]: 'Diamond Ore' };
    const BLOCK_COLORS = { [TYPES.GRASS]: '#4caf50', [TYPES.BRICK]: '#8b4513', [TYPES.GLASS]: '#87ceeb', [TYPES.CONCRETE]: '#999', [TYPES.GOLD]: '#ffd700', [TYPES.WOOD]: '#8b6914', [TYPES.DIRT]: '#6b4226', [TYPES.STEEL]: '#bbb', [TYPES.LEAVES]: '#2d6b30', [TYPES.RED]: '#e53935', [TYPES.BLUE]: '#1e88e5', [TYPES.WHITE]: '#eee', [TYPES.YELLOW]: '#fdd835', [TYPES.GREEN]: '#43a047', [TYPES.STONE]: '#808080', [TYPES.IRON_ORE]: '#c8a882', [TYPES.COAL_ORE]: '#333', [TYPES.DIAMOND_ORE]: '#4de8e0', [TYPES.SNOW]: '#f0f0ff', [TYPES.SAND]: '#e8d68a' };
    const BLOCK_ICONS = {};
    let blockPickups = []; // Mini rotating block pickups in world
    let ghostBlock = null; // Preview mesh for block placement
    let miningTarget = null; // { x, y, z, progress, type }
    let miningOverlay = null; // Crack overlay mesh
    const MINE_TIME = 0.6; // Seconds to mine a block
    let hotbarSlots = [TYPES.BRICK, TYPES.GLASS, TYPES.CONCRETE, TYPES.WOOD, TYPES.STEEL, TYPES.DIRT, TYPES.GOLD, TYPES.RED, TYPES.BLUE];
    let hotbarIndex = 0;
    let blocksPlacedForMission = 0; // Track blocks placed for building mission
    const BARRICADE_POS = new THREE.Vector3(-144, 1, 6); // Road crossing point for barricade mission
    let bankMarkerGroup, storeMarkerGroup, carparkMarkerGroup, alleyMarkerGroup, airportMarkerGroup, islandMarkerGroup, barricadeMarkerGroup, waypointArrow3D, bankGlow, storeGlow;
    let currentPhoneMessage = "";
    let bankCashWad = null, bankTellerNPC = null;
    let pickups = [];
    const MAX_PICKUPS = 50;

    // --- Store / Inventory ---
    const STORE_ITEMS = [
      { id: 'health_pack', name: 'Health Pack', price: 200000, icon: 'üíä', type: 'consumable', desc: 'Restore full health' },
      { id: 'armor', name: 'Body Armor', price: 60000, icon: 'üõ°Ô∏è', type: 'equipment', desc: 'Absorbs 500 damage' },
      { id: 'rocket', name: 'Rocket Launcher', price: 8000, icon: 'üöÄ', type: 'weapon', desc: '5-block blast radius!' },
      { id: 'grenade', name: 'Grenades (x5)', price: 20000, icon: 'üí£', type: 'weapon', desc: 'Hold shoot to throw' },
      { id: 'suit', name: 'Business Suit', price: 6000, icon: 'ü§µ', type: 'outfit', desc: 'Navy suit look' },
      { id: 'balaclava', name: 'Balaclava', price: 2000, icon: 'üé≠', type: 'outfit', desc: 'Hide your face' },
      { id: 'minecraft_skin', name: 'Classic Steve', price: 8000, icon: '‚õèÔ∏è', type: 'outfit', desc: 'Minecraft classic look' },
      { id: 'gta_outfit', name: 'Street OG', price: 12000, icon: 'üî´', type: 'outfit', desc: 'Classic gangster look' },
      { id: 'tattoo', name: 'Sleeve Tattoos', price: 12000, icon: 'üí™', type: 'cosmetic', desc: 'Ink up your arms' },
      { id: 'spray', name: 'Spray Can', price: 200000, icon: 'üé®', type: 'tool', desc: 'Tag the city' },
      { id: 'buy_car', name: 'Sports Car', price: 400000, icon: 'üèéÔ∏è', type: 'vehicle', desc: 'Fast red convertible!' },
      { id: 'buy_tank', name: 'Tank', price: 1200000, icon: 'ü™ñ', type: 'vehicle', desc: 'Armored & deadly' },
      { id: 'buy_plane', name: 'Plane', price: 3200000, icon: '‚úàÔ∏è', type: 'vehicle', desc: 'Take to the skies!' },
      { id: 'buy_flycar', name: 'Flying Car', price: 3600000, icon: 'üõ∏', type: 'vehicle', desc: 'Car that flies!' }
    ];
    let playerInventory = new Set();
    let currentWeapon = 'pistol';
    let storeOpen = false;
    let storePurchases = []; // Track purchases in current store session
    // Weapon cycling system: Shift toggles between weapons and block mode
    let playerWeapons = [
      { id: 'pistol', name: 'Pistol', projSpeed: 200, projSize: 0.35, projColor: 0xffff00, fireRate: 200, auto: false }
    ];
    let weaponIndex = 0; // Index into playerWeapons, -1 = block mode
    let lastFireTime = 0;
    const WEAPON_DEFS = {
      pistol:  { id: 'pistol', name: 'Pistol', projSpeed: 200, projSize: 0.35, projColor: 0xffff00, fireRate: 200, auto: false },
      cop_pistol: { id: 'cop_pistol', name: 'Cop Pistol', projSpeed: 220, projSize: 0.3, projColor: 0x00aaff, fireRate: 180, auto: false },
      army_rifle: { id: 'army_rifle', name: 'Army Rifle', projSpeed: 300, projSize: 0.4, projColor: 0xff3300, fireRate: 80, auto: true },
      rocket:  { id: 'rocket', name: 'Rocket Launcher', projSpeed: 120, projSize: 0.6, projColor: 0xff4400, fireRate: 500, auto: false, isRocket: true }
    };

    // --- Multi-Mission System ---
    const STORE_POS = new THREE.Vector3(-73, 1, 21);
    const ALLEY_POS = new THREE.Vector3(-504, 1, 24);
    const CARPARK_POS = new THREE.Vector3(216, 1, -24);
    const MISSIONS = [
      { id: 0, name: 'ROB THE BANK', objective: 'MISSION 1: ROB THE BANK',
        target: [72, 1, 72], reward: 10000,
        phoneStart: "Boss: Alright kid, your first job is to hit the National Bank. Follow the glowing pillar. Go inside, walk up to the teller desk. Be ready for the cops.",
        rewards: [
          { icon: 'üí∞', text: '+$10,000 Cash Stolen', action: 'cash10k' },
          { icon: '‚ù§Ô∏è', text: '+5 Health!', action: 'health_boost' },
          { icon: 'ü§µ', text: 'Suit Unlocked!', action: 'suit_unlock' }
        ]},
      { id: 1, name: 'GETAWAY', objective: 'MISSION 2: FIND A CAR & LOSE THE COPS',
        target: [-504, 1, 24], reward: 5000,
        phoneStart: "Boss: The alarm's tripped and cops are everywhere! Jack a car and get to the safe house out west. Lose those cops!",
        rewards: [
          { icon: 'üí∞', text: '+$5,000 Getaway Pay', action: 'cash5k' },
          { icon: 'üèéÔ∏è', text: 'Driving Skills Improved!', action: 'drive_skill' }
        ]},
      { id: 2, name: 'GEAR UP', objective: 'MISSION 3: VISIT THE WEAPON SHOP',
        target: [-73, 1, 21], reward: 0,
        phoneStart: "Boss: Time to gear up. Head to the weapon shop and buy yourself a rocket launcher. You're gonna need it.",
        rewards: [
          { icon: 'üöÄ', text: 'Rocket Launcher Equipped!', action: 'rocket_equip' },
          { icon: 'üè™', text: 'Store Always Open!', action: 'store_open' }
        ]},
      { id: 3, name: 'RAMPAGE', objective: 'MISSION 4: DESTROY 5 CARS',
        target: [0, 1, 0], reward: 10000,
        phoneStart: "Boss: Time to cause some chaos! Use that rocket launcher and blow up 5 cars around the city. Any car counts - make it rain fire!",
        rewards: [
          { icon: 'üí∞', text: '+$10,000 Destruction Pay', action: 'cash10k' },
          { icon: 'üí•', text: 'Car Crusher!', action: 'car_crusher' }
        ]},
      { id: 4, name: 'DEMOLITION', objective: 'MISSION 5: DESTROY THE CAR PARK',
        target: [216, 1, -24], reward: 15000,
        phoneStart: "Boss: See that multi-story car park downtown? Head over there and blast a hole in it! Destroy 50 blocks to bring it down. Use your rocket launcher!",
        rewards: [
          { icon: 'üí∞', text: '+$15,000 Destruction Pay', action: 'cash15k' },
          { icon: 'üí•', text: 'Demolition Expert!', action: 'explosion_expert' }
        ]},
      { id: 5, name: 'FINAL HEIST', objective: 'MISSION 6: STEAL A PLANE',
        target: [AIRPORT_X, 1, AIRPORT_Z + 9], reward: 25000,
        phoneStart: "Boss: Final job. Get to the airport and steal one of the jumbo jets. Fly it to my private island ‚Äî that's your new hideout. Follow the marker!",
        rewards: [
          { icon: 'üí∞', text: '+$25,000 Final Payout!', action: 'cash25k' },
          { icon: '‚úàÔ∏è', text: 'Master Criminal!', action: 'master' },
          { icon: 'üèùÔ∏è', text: 'Island Hideout Unlocked!', action: 'island' }
        ]},
      { id: 6, name: 'TANK HEIST', objective: 'MISSION 7: STEAL A TANK',
        target: [0, 1, 0], reward: 50000,
        phoneStart: "Boss: One last thing, kid. Go downtown and cause enough chaos to bring in the military. Steal one of their tanks and drive it to the island. That's your empire now.",
        rewards: [
          { icon: 'üí∞', text: '+$50,000 Tank Heist Pay!', action: 'cash50k' },
          { icon: 'üî•', text: 'Tank Commander!', action: 'tank_commander' },
          { icon: 'üèùÔ∏è', text: 'Island Fortress Established!', action: 'fortress' }
        ]},
      { id: 7, name: 'MASTER BUILDER', objective: 'MISSION 8: BUILD A BARRICADE',
        target: [-144, 1, 6], reward: 30000,
        phoneStart: "Boss: The cops keep coming down that main road. I need you to build a barricade! Go to the yellow marker, collect blocks by destroying buildings, then place 20 blocks to block the road.",
        rewards: [
          { icon: 'üí∞', text: '+$30,000 Builder Pay!', action: 'cash30k' },
          { icon: 'üöó', text: 'Indestructible Flying Car!', action: 'flycar_reward' },
          { icon: 'üèóÔ∏è', text: '+50 Free Blocks!', action: 'free_blocks' }
        ]},
      { id: 8, name: 'BUILD YOUR HOME', objective: 'FINAL MISSION: BUILD YOUR MANSION',
        target: [ISLAND_X, 1, ISLAND_Z], reward: 100000,
        phoneStart: "Boss: You've earned it, kid. That island is yours now. Time to build yourself a mansion fit for a gangster! Get to the island and place 40 blocks. I've left you 5 tanks and 5 planes as a gift!",
        rewards: [
          { icon: 'üí∞', text: '+$100,000 Retirement Fund!', action: 'cash100k' },
          { icon: 'üè†', text: 'Gangster Mansion Built!', action: 'mansion' },
          { icon: 'üõ©Ô∏è', text: '5 Planes + 5 Tanks on Island!', action: 'island_vehicles' },
          { icon: 'üëë', text: 'CRIME LORD STATUS!', action: 'crime_lord' }
        ]}
    ];
    let missionIndex = 0;
    let mission = { active: false, state: 'INTRO', target: new THREE.Vector3(72, 1, 72) };
    let carsDestroyedCount = 0;
    const CARS_NEEDED = 5;
    let carparkBlocksDestroyed = 0;
    let carparkTotalBlocks = 0;

    // --- Soundtrack System ---
    const SOUNDTRACK = [
      'Songs/BREAD CLUB-CRIMINAL MIND (Music Video).mp3',
      'Songs/Come My Way.mp3',
      'Songs/Force of Nature.mp3',
      'Songs/Bread Club - Predictable.mp3',
      'Songs/Tokyo.mp3',
      'Songs/Forever - Bread Club & Phil Fresh.mp3',
      'Songs/hOT mESS - Bread Club (Official Music Video).mp3',
      'Songs/Lonely Without You.mp3',
      'Songs/Rest Of My Life (Official Music Video).mp3',
      'Songs/2099.mp3',
      'Songs/Pushing Away [qdHJ5hk81lA].mp3',
      'Songs/Technical Difficulties [c3KCdQq5ooE].mp3'
    ];
    const RADIO_TUNING = 'Songs/Radio tuning.mp3';
    let radioAudio = null;
    let radioTrackIndex = 0;
    let radioStarted = false;
    let radioTuningTimer = null;

    function startRadio() {
      if (radioStarted) return;
      radioStarted = true;
      radioAudio = new Audio();
      radioAudio.volume = 0.3;
      playSong(0); // Start directly with first song, no static
    }

    function playRadioTuning() {
      if (!radioAudio) return;
      if (radioTuningTimer) { clearTimeout(radioTuningTimer); radioTuningTimer = null; }
      radioAudio.onended = null;
      radioAudio.src = RADIO_TUNING;
      let onMeta = () => {
        radioAudio.removeEventListener('loadedmetadata', onMeta);
        let maxOffset = Math.max(0, radioAudio.duration - 6);
        radioAudio.currentTime = Math.random() * maxOffset;
        radioAudio.play().catch(() => {});
        radioTuningTimer = setTimeout(() => {
          radioTuningTimer = null;
          radioAudio.pause();
          playSong(radioTrackIndex);
        }, 5000);
      };
      radioAudio.addEventListener('loadedmetadata', onMeta);
      radioAudio.load();
    }

    function playSong(index) {
      if (!radioAudio) return;
      if (radioTuningTimer) { clearTimeout(radioTuningTimer); radioTuningTimer = null; }
      radioTrackIndex = index % SOUNDTRACK.length;
      radioAudio.src = SOUNDTRACK[radioTrackIndex];
      radioAudio.onended = () => {
        radioTrackIndex = (radioTrackIndex + 1) % SOUNDTRACK.length;
        playRadioTuning();
      };
      radioAudio.play().catch(() => {});
    }

    let _phoneTimeout = null;
    function showPhoneMessage(text, duration = 20000) {
      if (!text || mission.state === 'SUCCESS') return;
      currentPhoneMessage = text;
      let phone = document.getElementById('phone-ui');
      document.getElementById('phone-text').innerText = text;
      // Set dismiss text based on platform
      let dismissEl = document.getElementById('phone-dismiss');
      if (dismissEl) dismissEl.innerText = isMobileDevice ? 'tap to dismiss' : '[K] to dismiss';
      let pauseMissionEl = document.getElementById('pause-mission-text');
      if (pauseMissionEl) pauseMissionEl.innerText = text;
      phone.style.display = 'flex';
      // Clear any inline position overrides from triggerMissionSuccess
      phone.style.top = ''; phone.style.bottom = '';
      phone.classList.remove('active');
      void phone.offsetWidth;
      phone.classList.add('active');
      // Desktop gets 1.5x longer display time
      let actualDuration = isMobileDevice ? duration : Math.round(duration * 1.5);
      if (phone._hideTimer) clearTimeout(phone._hideTimer);
      phone._hideTimer = setTimeout(() => {
        phone.classList.remove('active');
        setTimeout(() => { phone.style.display = 'none'; }, 700); // hide after slide-out animation
      }, actualDuration);
    }

    function dismissPhone() {
      let phone = document.getElementById('phone-ui');
      if (phone._hideTimer) clearTimeout(phone._hideTimer);
      phone.classList.remove('active');
      setTimeout(() => { phone.style.display = 'none'; }, 700);
    }

    window.debugTeleport = function(x, y, z) { player.pos.set(x, y, z); };
    window.debugMission = function(idx) { missionIndex = idx; startMission(idx); };
    window.debugMoney = function(n) { score += (n || 100000); updateHUD(); };
    window.debugBlocks = function(n) { n=n||20; blockInventory[TYPES.BRICK]=n; blockInventory[TYPES.GLASS]=n; blockInventory[TYPES.CONCRETE]=n; totalBlocks=n*3; updateBlockCounter(); updateHotbar(); };
    window.debugFly = function() { interactVehicle(); };
    window.debugVehicles = function() { return vehicles.filter(v => v.type === 'PLANE').map(v => ({x:Math.round(v.pos.x), y:Math.round(v.pos.y), z:Math.round(v.pos.z), dead:v.isDead})); };
    window.debugSuccess = function() { triggerMissionSuccess(); };
    window.debugState = function() { return { missionIndex, state: mission.state, active: mission.active, isPaused, isPlaying, storeOpen, carparkTotalBlocks, carparkBlocksDestroyed }; };
    window.debugGetBlock = function(x, y, z) { return getBlock(x, y, z); };
    window.togglePause = function() {
      if (!isPlaying || mission.state === 'SUCCESS') return;
      if (storeOpen) { closeStore(); return; }
      isPaused = !isPaused;
      if (isPaused) {
        try { document.exitPointerLock(); } catch(e) {}
        document.getElementById('pause-screen').style.display = 'flex';
        if (isMobileDevice) document.getElementById('mobile-controls').style.display = 'none';
        if (radioAudio) radioAudio.pause();
      } else {
        document.getElementById('pause-screen').style.display = 'none';
        if (isMobileDevice) {
          document.getElementById('mobile-controls').style.display = 'block';
        } else {
          renderer.domElement.requestPointerLock();
        }
        if (radioAudio && radioStarted) radioAudio.play().catch(() => {});
      }
    };

    window.continueGame = function() {
      let justCompletedMission = missionIndex;
      document.getElementById('mission-success').style.display = 'none';
      missionIndex++;
      if (missionIndex < MISSIONS.length) {
        startMission(missionIndex);
      } else {
        document.getElementById('objective-text').innerText = "ALL MISSIONS COMPLETE! FREE ROAM";
        mission.active = false; mission.state = 'DONE';
      }
      isPaused = false;
      isPlaying = true;
      if (!isMobileDevice) renderer.domElement.requestPointerLock();
      if (isMobileDevice) document.getElementById('mobile-controls').style.display = 'block';
      // Barricade mission reward: spawn indestructible flying car
      if (justCompletedMission === 7 && playerInventory.has('flycar_reward')) {
        let spawnX = player.pos.x + 5, spawnZ = player.pos.z;
        let v = new Vehicle('CIVILIAN', spawnX, spawnZ, 0x9900ff);
        v.health = 99999; v.maxHealth = 99999; // Indestructible
        v.parked = true; v.vel.set(0, 0, 0);
        v.isFlyingCar = true;
        v.isIndestructible = true;
        vehicles.push(v);
        // Show "hold space to fly" modal
        setTimeout(() => {
          showPhoneMessage("Your new flying car is here! Hold SPACE while driving to fly!", 12000);
        }, 2000);
      }
    };

    function startMission(index) {
      let m = MISSIONS[index];
      missionIndex = index;
      mission.active = true;
      mission.state = m.id === 0 ? 'GO_TO_BANK' : m.id === 1 ? 'STEAL_CAR' : m.id === 2 ? 'GO_TO_STORE' : m.id === 3 ? 'DESTROY_CARS' : m.id === 4 ? 'GO_TO_CARPARK' : m.id === 5 ? 'GO_TO_AIRPORT' : m.id === 7 ? 'GO_TO_BARRICADE' : m.id === 8 ? 'GO_TO_ISLAND_BUILD' : 'CAUSE_CHAOS';
      mission.target = new THREE.Vector3(m.target[0], m.target[1], m.target[2]);
      document.getElementById('objective-text').innerText = m.objective;
      // Show/hide markers
      if (bankMarkerGroup) bankMarkerGroup.visible = (index === 0);
      if (bankGlow) bankGlow.visible = (index === 0);
      if (storeMarkerGroup) storeMarkerGroup.visible = (index === 2 || playerInventory.has('store_unlocked'));
      if (storeGlow) storeGlow.visible = (index === 2 || playerInventory.has('store_unlocked'));
      if (carparkMarkerGroup) carparkMarkerGroup.visible = (index === 4);
      if (alleyMarkerGroup) alleyMarkerGroup.visible = (index === 1);
      if (airportMarkerGroup) airportMarkerGroup.visible = (index === 5);
      if (islandMarkerGroup) islandMarkerGroup.visible = (index >= 5); // Show island marker from plane mission onwards
      if (barricadeMarkerGroup) barricadeMarkerGroup.visible = (index === 7);
      if (bankCashWad) { bankCashWad.visible = (index === 0); bankCashWad.userData.animating = false; bankCashWad.scale.setScalar(1); }
      // Show phone message for missions after the first (first is handled via pendingPhoneMessage)
      if (index > 0) setTimeout(() => showPhoneMessage(m.phoneStart, 20000), 500);
      // Mission 2: set wanted level - cops are chasing from the bank robbery
      if (index === 1) { setWantedLevel(3); }
      // Reset car destroy counter for mission 4
      if (index === 3) { carsDestroyedCount = 0; updateCarCounter(); }
      // Reset carpark block counter for mission 5
      if (index === 4) { carparkBlocksDestroyed = 0; carparkCarsSpawned = false; }
      // Reset block placement counter for mission 8
      if (index === 7 || index === 8) { blocksPlacedForMission = 0; }
      // Hide demolition progress UI when starting any mission
      document.getElementById('demolition-progress').style.display = 'none';
      return m;
    }

    function applyRewardAction(actionId) {
      switch(actionId) {
        case 'cash10k': score += 10000; break;
        case 'cash5k': score += 5000; break;
        case 'cash15k': score += 15000; break;
        case 'cash25k': score += 25000; break;
        case 'health_boost': maxHealth += 500; playerHealth = Math.min(playerHealth + 500, maxHealth); break;
        case 'suit_unlock':
          player.body.material.color.setHex(0x1a1a2e); player.armL.material.color.setHex(0x1a1a2e);
          player.armR.material.color.setHex(0x1a1a2e); player.legL.material.color.setHex(0x1a1a2e);
          player.legR.material.color.setHex(0x1a1a2e);
          playerInventory.add('suit'); break;
        case 'drive_skill': break;
        case 'rocket_equip': currentWeapon = 'rocket'; playerInventory.add('rocket'); applyWeaponVisual('rocket'); break;
        case 'store_open': playerInventory.add('store_unlocked'); if (storeMarkerGroup) storeMarkerGroup.visible = true; break;
        case 'car_crusher': break;
        case 'explosion_expert': break;
        case 'master': break;
        case 'island': break;
        case 'cash50k': score += 50000; break;
        case 'tank_commander': break;
        case 'fortress': break;
        case 'cash30k': score += 30000; break;
        case 'master_builder': playerInventory.add('master_builder'); break;
        case 'free_blocks':
          // Give 50 blocks of assorted types
          let freeTypes = [TYPES.BRICK, TYPES.CONCRETE, TYPES.STEEL, TYPES.WOOD, TYPES.GLASS];
          for (let ft of freeTypes) { blockInventory[ft] = (blockInventory[ft] || 0) + 10; totalBlocks += 10; }
          updateBlockCounter();
          break;
        case 'flycar_reward':
          // Spawn indestructible flying car after modal closes
          playerInventory.add('flycar_reward');
          break;
        case 'island_vehicles':
          spawnIslandVehicles();
          break;
        case 'cash100k': score += 100000; break;
        case 'mansion': break;
        case 'crime_lord': break;
      }
      updateHUD();
    }

    function updateCarCounter() {
      let el = document.getElementById('car-counter');
      if (!el) return;
      if (missionIndex === 3 && mission.state === 'DESTROY_CARS') {
        el.style.display = 'flex';
        el.innerHTML = '';
        for (let i = 0; i < CARS_NEEDED; i++) {
          let icon = document.createElement('span');
          icon.innerText = 'üöó';
          icon.style.fontSize = '24px';
          icon.style.filter = i < carsDestroyedCount ? 'none' : 'grayscale(1) opacity(0.3)';
          icon.style.transition = 'filter 0.3s, transform 0.3s';
          if (i < carsDestroyedCount) icon.style.transform = 'scale(1.2)';
          el.appendChild(icon);
        }
        document.getElementById('objective-text').innerText = 'DESTROY CARS: ' + carsDestroyedCount + '/' + CARS_NEEDED;
      } else {
        el.style.display = 'none';
      }
    }

    function takeDamage(amount) {
      if (armorHP > 0) {
        let absorbed = Math.min(armorHP, amount);
        armorHP -= absorbed; amount -= absorbed;
        if (armorHP <= 0 && player.armorMesh) player.armorMesh.visible = false;
      }
      playerHealth -= amount;
      updateHUD();
      // Red flash on damage
      if (amount > 5) {
        let flash = document.getElementById('damage-flash');
        if (flash) {
          let intensity = Math.min(amount / 100, 1);
          flash.style.opacity = 0.3 + intensity * 0.5;
          setTimeout(() => { flash.style.opacity = '0'; }, 150);
        }
      }
    }

    function applyWeaponVisual(weaponId) {
      addWeapon(weaponId);
      currentWeapon = weaponId;
      weaponIndex = playerWeapons.findIndex(w => w.id === weaponId);
      if (weaponIndex >= 0) {
        let w = playerWeapons[weaponIndex];
        player.projSpeed = w.projSpeed; player.projSize = w.projSize; player.projColor = w.projColor;
      }
      applyWeaponVisualForType(weaponId);
    }

    function triggerMissionSuccess() {
      if (mission.state === 'SUCCESS') return; // Guard against double-calls
      let m = MISSIONS[missionIndex];
      mission.state = 'SUCCESS'; mission.active = false;
      isPaused = true; // Pause game during success screen
      playerHealth = maxHealth; // Heal player so they can't die during success cinematic
      try { document.exitPointerLock(); } catch(e) {}
      if (waypointArrow3D) waypointArrow3D.visible = false;
      // Hide death screen if it was showing
      document.getElementById('start-screen').style.display = 'none';
      // Hide mobile controls so they don't block the success screen
      let mAct = document.getElementById('btn-interact');
      if (mAct) mAct.style.display = 'none';
      document.getElementById('action-msg').style.display = 'none';
      if (isMobileDevice) document.getElementById('mobile-controls').style.display = 'none';
      // Hide phone notification and cancel any pending phone timeouts
      if (_phoneTimeout) { clearTimeout(_phoneTimeout); _phoneTimeout = null; }
      let phoneUI = document.getElementById('phone-ui');
      if (phoneUI) {
        if (phoneUI._hideTimer) clearTimeout(phoneUI._hideTimer);
        phoneUI.classList.remove('active');
        phoneUI.style.display = 'none';
        phoneUI.style.top = '-350px';
        phoneUI.style.bottom = '-350px';
      }
      let carCounter = document.getElementById('car-counter');
      if (carCounter) carCounter.style.display = 'none';
      document.getElementById('demolition-progress').style.display = 'none';

      let container = document.getElementById('mission-success');
      container.innerHTML = '';
      container.style.display = 'flex'; container.style.flexDirection = 'column';
      container.style.alignItems = 'center'; container.style.justifyContent = 'center';

      let title = document.createElement('div');
      title.className = 'ms-title'; title.id = 'ms-title';
      title.innerText = m.name + ' COMPLETE!';
      title.style.transform = 'scale(0)';
      container.appendChild(title);
      setTimeout(() => title.style.transform = 'scale(1)', 100);

      m.rewards.forEach((r, i) => {
        let item = document.createElement('div');
        item.className = 'ms-item';
        item.innerHTML = '<span class="ms-icon">' + r.icon + '</span> <span>' + r.text + '</span>';
        container.appendChild(item);
        setTimeout(() => {
          item.style.opacity = '1'; item.style.transform = 'translateY(0)';
          applyRewardAction(r.action);
        }, 1000 + i * 1000);
      });

      let btn = document.createElement('button');
      btn.className = 'ms-btn'; btn.id = 'ms-btn';
      btn.innerText = missionIndex < MISSIONS.length - 1 ? 'NEXT MISSION' : 'FREE ROAM';
      let btnHandler = () => continueGame();
      btn.onclick = btnHandler;
      btn.addEventListener('touchstart', (e) => { e.preventDefault(); btnHandler(); });
      btn.style.pointerEvents = 'auto';
      container.appendChild(btn);
      setTimeout(() => btn.style.opacity = '1', 1000 + m.rewards.length * 1000 + 500);
    }

    let gameWon = false;
    function showVictoryScreen() {
      if (gameWon) return;
      gameWon = true;
      isPaused = true;
      document.exitPointerLock();
      if (waypointArrow3D) waypointArrow3D.visible = false;
      let container = document.getElementById('mission-success');
      container.innerHTML = '';
      container.style.display = 'flex'; container.style.flexDirection = 'column';
      container.style.alignItems = 'center'; container.style.justifyContent = 'center';
      // Title
      let title = document.createElement('div');
      title.className = 'ms-title';
      title.innerText = 'YOU WIN!';
      title.style.transform = 'scale(0)'; title.style.fontSize = '80px';
      container.appendChild(title);
      setTimeout(() => title.style.transform = 'scale(1)', 100);
      // Subtitle
      let sub = document.createElement('div');
      sub.style.cssText = 'font-size:24px; color:#aaa; margin-bottom:30px; opacity:0; transition:opacity 0.5s;';
      sub.innerText = 'You made it to the private island!';
      container.appendChild(sub);
      setTimeout(() => sub.style.opacity = '1', 600);
      // Stats
      let stats = [
        { label: 'Cash Earned', value: '$' + score },
        { label: 'Missions Completed', value: missionIndex + '/' + MISSIONS.length },
        { label: 'Wanted Level Reached', value: '‚òÖ'.repeat(Math.max(wantedLevel, 1)) },
        { label: 'Weapons Collected', value: playerWeapons.length + '' },
        { label: 'Blocks Collected', value: totalBlocks + '' }
      ];
      stats.forEach((s, i) => {
        let item = document.createElement('div');
        item.className = 'ms-item';
        item.innerHTML = '<span style="color:#ffcc00; min-width:220px;">' + s.label + '</span><span>' + s.value + '</span>';
        container.appendChild(item);
        setTimeout(() => { item.style.opacity = '1'; item.style.transform = 'translateY(0)'; }, 1000 + i * 400);
      });
      // Unfinished missions
      let unfinished = MISSIONS.filter((m, i) => i >= missionIndex);
      if (unfinished.length > 0) {
        let ufDiv = document.createElement('div');
        ufDiv.style.cssText = 'margin-top:20px; opacity:0; transition:opacity 0.5s; text-align:center;';
        ufDiv.innerHTML = '<div style="color:#ff8800; font-size:18px; margin-bottom:8px;">Missions Remaining:</div>' +
          unfinished.map(m => '<div style="color:#888; font-size:16px;">' + m.objective + '</div>').join('');
        container.appendChild(ufDiv);
        setTimeout(() => ufDiv.style.opacity = '1', 1000 + stats.length * 400 + 200);
      }
      // Unpurchased store items
      let unbought = STORE_ITEMS.filter(it => !playerInventory.has(it.id) && it.type !== 'consumable' && it.id !== 'grenade');
      if (unbought.length > 0) {
        let ubDiv = document.createElement('div');
        ubDiv.style.cssText = 'margin-top:15px; opacity:0; transition:opacity 0.5s; text-align:center;';
        ubDiv.innerHTML = '<div style="color:#ff8800; font-size:18px; margin-bottom:8px;">Items Not Purchased:</div>' +
          unbought.map(it => '<div style="color:#888; font-size:14px;">' + it.icon + ' ' + it.name + ' ‚Äî $' + it.price + '</div>').join('');
        container.appendChild(ubDiv);
        setTimeout(() => ubDiv.style.opacity = '1', 1000 + stats.length * 400 + 600);
      }
      // Boss message about gifts
      let bossMsg = document.createElement('div');
      bossMsg.style.cssText = 'margin-top:20px; padding:15px 25px; background:rgba(255,200,0,0.15); border:2px solid #ffd700; border-radius:12px; opacity:0; transition:opacity 0.5s; text-align:center; max-width:85vw;';
      bossMsg.innerHTML = '<div style="color:#ffd700; font-size:20px; font-weight:bold; margin-bottom:5px;">üì± Boss:</div><div style="color:#fff; font-size:18px;">"I\'ve gifted you 5 planes and 5 tanks to play with. Enjoy your island, kid."</div>';
      container.appendChild(bossMsg);
      setTimeout(() => bossMsg.style.opacity = '1', 1000 + stats.length * 400 + 800);

      // Continue playing button - large, green, always visible
      let btn = document.createElement('button');
      btn.className = 'ms-btn';
      btn.innerText = 'KEEP PLAYING';
      btn.style.pointerEvents = 'auto';
      btn.style.marginBottom = '30px';
      btn.style.minHeight = '60px';
      let victoryHandler = () => {
        container.style.display = 'none';
        isPaused = false;
        if (!isMobileDevice) renderer.domElement.requestPointerLock();
        if (isMobileDevice) document.getElementById('mobile-controls').style.display = 'block';
        // Spawn 5 planes and 5 tanks on island
        spawnIslandVehicles();
        showPhoneMessage("Boss: Check out your new toys on the island! 5 tanks and 5 planes, all yours.", 12000);
      };
      btn.onclick = victoryHandler;
      btn.addEventListener('touchstart', (e) => { e.preventDefault(); victoryHandler(); });
      container.appendChild(btn);
      setTimeout(() => btn.style.opacity = '1', 1000 + stats.length * 400 + 1000);
    }

    function spawnIslandVehicles() {
      // Spawn 5 tanks and 5 planes on the island
      let tankColors = [0x3b4d2e, 0x556b2f, 0x4a5a3a, 0x2d3b1f, 0x5a6b4a];
      let planeColors = [0xffffff, 0xcc0000, 0x0044cc, 0xffcc00, 0x00cc44];
      for (let i = 0; i < 5; i++) {
        // Tanks in a row near mansion
        let tx = ISLAND_X - 30 + i * 8;
        let tz = ISLAND_Z - 20;
        let tank = new Vehicle('TANK', tx, tz, tankColors[i]);
        tank.parked = true; tank.vel.set(0, 0, 0);
        vehicles.push(tank);
        // Planes along the runway
        let px = ISLAND_X - 40 + i * 18;
        let pz = ISLAND_Z + 8;
        let plane = new Vehicle('PLANE', px, pz, planeColors[i]);
        plane.parked = true; plane.vel.set(0, 0, 0);
        vehicles.push(plane);
      }
    }

    // --- Store System ---
    window.openStore = function() {
      storeOpen = true; isPaused = true;
      storePurchases = []; // Reset purchases for this session
      try { document.exitPointerLock(); } catch(e) {}
      // Hide phone so it doesn't overlap shop
      let phoneUI = document.getElementById('phone-ui');
      if (phoneUI) { if (phoneUI._hideTimer) clearTimeout(phoneUI._hideTimer); phoneUI.classList.remove('active'); phoneUI.style.display = 'none'; }
      document.getElementById('store-balance').innerText = '$' + score;
      let grid = document.getElementById('store-grid');
      grid.innerHTML = '';
      STORE_ITEMS.forEach(item => {
        let owned = playerInventory.has(item.id) && item.type !== 'consumable' && item.type !== 'vehicle';
        let canAfford = score >= item.price;
        let card = document.createElement('div');
        card.className = 'store-item' + (owned ? ' owned' : (!canAfford ? ' cant-afford' : ''));
        card.innerHTML = '<div class="store-item-icon">' + item.icon + '</div>' +
          '<div class="store-item-name">' + item.name + '</div>' +
          '<div class="store-item-price">' + (owned ? 'OWNED' : '$' + item.price) + '</div>';
        if (!owned && canAfford) {
          let buyHandler = () => buyItem(item.id);
          card.onclick = buyHandler;
          card.addEventListener('touchstart', (e) => { e.preventDefault(); buyHandler(); });
        }
        grid.appendChild(card);
      });
      document.getElementById('store-ui').style.display = 'flex';
      document.getElementById('store-scroll').scrollTop = 0;
      if (isMobileDevice) document.getElementById('mobile-controls').style.display = 'none';
    };

    window.closeStore = function() {
      storeOpen = false;
      document.getElementById('store-ui').style.display = 'none';
      // Check if mission requires buying rocket BEFORE resuming game
      if (missionIndex === 2 && mission.state === 'BUY_WEAPON' && playerInventory.has('rocket')) {
        triggerMissionSuccess(); // Sets isPaused = true, shows success screen
        return; // Don't resume game - success screen handles transition
      }
      // Show purchase summary if items were bought
      if (storePurchases.length > 0) {
        let totalSpent = storePurchases.reduce((s, p) => s + p.price, 0);
        let overlay = document.createElement('div');
        overlay.style.cssText = 'position:fixed; top:50%; left:50%; transform:translate(-50%,-50%); z-index:500; background:rgba(0,0,0,0.9); border:2px solid #4CAF50; border-radius:12px; padding:20px 30px; color:white; font-family:sans-serif; text-align:center; pointer-events:none; min-width:250px;';
        let itemsHtml = storePurchases.map(p => '<div style="display:flex; align-items:center; justify-content:space-between; padding:4px 0; border-bottom:1px solid #333;"><span>' + p.icon + ' ' + p.name + '</span><span style="color:#4CAF50;">-$' + p.price.toLocaleString() + '</span></div>').join('');
        overlay.innerHTML = '<h3 style="color:#4CAF50; margin:0 0 10px 0; font-size:18px;">üõí PURCHASED</h3>' + itemsHtml + '<div style="margin-top:10px; padding-top:8px; border-top:2px solid #4CAF50; font-size:16px; font-weight:bold;">Total: <span style="color:#ff6600;">-$' + totalSpent.toLocaleString() + '</span></div>';
        document.body.appendChild(overlay);
        setTimeout(() => { overlay.style.transition = 'opacity 0.5s'; overlay.style.opacity = '0'; setTimeout(() => overlay.remove(), 500); }, 2500);
      }
      // Resume game normally
      isPaused = false;
      if (isMobileDevice) {
        document.getElementById('mobile-controls').style.display = 'block';
      } else {
        renderer.domElement.requestPointerLock();
      }
      // Auto-equip rocket launcher for carpark mission even if not purchased
      if (missionIndex >= 3 && !playerInventory.has('rocket')) {
        playerInventory.add('rocket');
        applyWeaponVisual('rocket');
        showFloatingText('+Rocket Launcher (Free)', player.pos);
      }
      // Always ensure rocket is properly in weapon list and equipped after store
      if (playerInventory.has('rocket')) {
        addWeapon('rocket');
        // If not in build mode, equip rocket
        if (!buildMode) {
          currentWeapon = 'rocket';
          weaponIndex = playerWeapons.findIndex(w => w.id === 'rocket');
          if (weaponIndex >= 0) {
            let w = playerWeapons[weaponIndex];
            player.projSpeed = w.projSpeed; player.projSize = w.projSize; player.projColor = w.projColor;
          }
          applyWeaponVisualForType('rocket');
        }
      }
    };

    function buyItem(itemId) {
      let item = STORE_ITEMS.find(i => i.id === itemId);
      if (!item || score < item.price) return;
      if (playerInventory.has(itemId) && item.type !== 'consumable' && item.type !== 'equipment' && item.type !== 'vehicle' && itemId !== 'grenade') return;
      score -= item.price;
      storePurchases.push({ name: item.name, icon: item.icon, price: item.price });
      if (item.type !== 'consumable' && item.type !== 'equipment' && itemId !== 'grenade') playerInventory.add(itemId);
      if (itemId === 'health_pack') { playerHealth = maxHealth; }
      else if (itemId === 'armor') {
        armorHP = 500;
        // Visual: add white chest plate to player body
        if (!player.armorMesh) {
          let am = new THREE.Mesh(new THREE.BoxGeometry(0.85, 0.55, 0.55), new THREE.MeshStandardMaterial({ color: 0xcccccc, roughness: 0.3, metalness: 0.6 }));
          am.position.set(0, 0.1, 0);
          player.body.add(am);
          player.armorMesh = am;
        }
        player.armorMesh.visible = true;
      }
      else if (itemId === 'rocket') { currentWeapon = 'rocket'; applyWeaponVisual('rocket'); }
      else if (itemId === 'grenade') { grenadeCount += 5; let gh = document.getElementById('grenade-hint'); if (gh) gh.style.display = ''; }
      else if (itemId === 'suit') {
        player.body.material.color.setHex(0x1a1a2e); player.armL.material.color.setHex(0x1a1a2e);
        player.armR.material.color.setHex(0x1a1a2e); player.legL.material.color.setHex(0x1a1a2e); player.legR.material.color.setHex(0x1a1a2e);
      }
      else if (itemId === 'balaclava') { player.head.material.color.setHex(0x111111); }
      else if (itemId === 'minecraft_skin') {
        // Classic Steve: cyan shirt, blue pants, brown hair head
        player.body.material.color.setHex(0x00aaaa); player.armL.material.color.setHex(0x00aaaa);
        player.armR.material.color.setHex(0x00aaaa); player.legL.material.color.setHex(0x1a1a8e);
        player.legR.material.color.setHex(0x1a1a8e); player.head.material.color.setHex(0x8b6947);
      }
      else if (itemId === 'gta_outfit') {
        // Street OG: white tank top, baggy green pants
        player.body.material.color.setHex(0xeeeeee); player.armL.material.color.setHex(0xd4a574);
        player.armR.material.color.setHex(0xd4a574); player.legL.material.color.setHex(0x3d5c3a);
        player.legR.material.color.setHex(0x3d5c3a);
      }
      else if (itemId === 'tattoo') { player.armL.material.color.setHex(0x2d3a31); player.armR.material.color.setHex(0x2d3a31); }
      else if (itemId === 'spray') { playerInventory.add('spray'); }
      else if (itemId === 'buy_car') {
        let spawnX = player.pos.x + 5, spawnZ = player.pos.z;
        let v = new Vehicle('CIVILIAN', spawnX, spawnZ, 0xff2222);
        v.health = 1000; v.maxHealth = 1000; // 10x normal health
        v.parked = true; v.vel.set(0, 0, 0);
        v.isSportsCar = true;
        vehicles.push(v);
        closeStore();
      }
      else if (itemId === 'buy_tank') {
        let spawnX = player.pos.x + 8, spawnZ = player.pos.z;
        let v = new Vehicle('TANK', spawnX, spawnZ, 0x556b2f);
        v.parked = true; v.vel.set(0, 0, 0);
        vehicles.push(v);
        closeStore();
      }
      else if (itemId === 'buy_plane') {
        let spawnX = player.pos.x + 10, spawnZ = player.pos.z;
        let v = new Vehicle('PLANE', spawnX, spawnZ, 0xffffff);
        v.parked = true; v.vel.set(0, 0, 0);
        vehicles.push(v);
        closeStore();
      }
      else if (itemId === 'buy_flycar') {
        let spawnX = player.pos.x + 5, spawnZ = player.pos.z;
        let v = new Vehicle('CIVILIAN', spawnX, spawnZ, 0x9900ff);
        v.health = 500; v.maxHealth = 500;
        v.parked = true; v.vel.set(0, 0, 0);
        v.isFlyingCar = true;
        vehicles.push(v);
        closeStore();
      }
      updateHUD();
      showFloatingText('PURCHASED: ' + item.name, player.pos);
      if (item.type !== 'vehicle') openStore(); // refresh UI (vehicles close store)
    }

    // --- Cash Pickup System ---
    function spawnCashPickup(x, y, z, amount) {
      let p = pickups.find(p => !p.active);
      if (!p) return;
      p.active = true; p.amount = amount; p.life = 30;
      p.mesh.position.set(x, y + 1, z);
      p.mesh.visible = true; p.mesh.scale.setScalar(1);
    }

    function showFloatingText(text, worldPos) {
      let v = worldPos.clone().project(camera);
      let x = (v.x * 0.5 + 0.5) * window.innerWidth;
      let y = (-v.y * 0.5 + 0.5) * window.innerHeight;
      let el = document.createElement('div');
      el.className = 'float-text';
      el.style.left = x + 'px'; el.style.top = y + 'px';
      el.innerText = text;
      document.body.appendChild(el);
      requestAnimationFrame(() => { el.style.transform = 'translateY(-80px)'; el.style.opacity = '0'; });
      setTimeout(() => el.remove(), 1200);
    }

    function showPlaneControls() {
      let overlay = document.createElement('div');
      overlay.id = 'plane-controls-overlay';
      overlay.style.cssText = 'position:fixed; top:50%; left:50%; transform:translate(-50%,-50%); z-index:500; background:rgba(0,0,0,0.85); border:2px solid #ffcc00; border-radius:12px; padding:20px 30px; color:white; font-size:18px; text-align:center; pointer-events:none; -webkit-transform:translate(-50%,-50%) translateZ(0);';
      overlay.innerHTML = '<div style="color:#ffcc00; font-size:24px; font-weight:bold; margin-bottom:12px;">FLIGHT CONTROLS</div>' +
        '<div style="line-height:2.2; text-align:left; display:inline-block;">' +
        '<span style="color:#ffcc00; font-weight:bold;">W</span> ‚Äî Accelerate forward<br>' +
        '<span style="color:#ffcc00; font-weight:bold;">S</span> ‚Äî Slow down + descend<br>' +
        '<span style="color:#ffcc00; font-weight:bold;">A / D</span> ‚Äî Steer left / right<br>' +
        '<span style="color:#ffcc00; font-weight:bold;">SPACE</span> ‚Äî Fly up<br>' +
        '<span style="color:#aaa;">Release Space to glide down</span><br>' +
        '<span style="color:#ffcc00; font-weight:bold;">Enter</span> ‚Äî Exit plane' +
        '</div>' +
        '<div style="margin-top:12px; color:#888; font-size:14px;">[K] to dismiss</div>';
      document.body.appendChild(overlay);
      setTimeout(() => { if (overlay.parentElement) { overlay.style.transition = 'opacity 1s'; overlay.style.opacity = '0'; setTimeout(() => overlay.remove(), 1000); } }, 20000);
    }

    // --- Block Building System ---
    function addBlockToInventory(blockType) {
      if (!blockType || blockType === TYPES.EMPTY || blockType === TYPES.WATER) return;
      if (!blockInventory[blockType]) blockInventory[blockType] = 0;
      blockInventory[blockType]++;
      totalBlocks++;
      // Add to hotbar if not already there
      if (!hotbarSlots.includes(blockType)) {
        let emptySlot = hotbarSlots.findIndex(s => !(blockInventory[s] > 0));
        if (emptySlot >= 0) hotbarSlots[emptySlot] = blockType;
      }
      showFloatingText('+1 ' + (BLOCK_NAMES[blockType] || 'Block'), player.pos);
      playSFX('pickup');
      updateBlockCounter();
    }

    function updateBlockCounter() {
      let el = document.getElementById('block-counter');
      if (totalBlocks > 0) {
        el.style.display = 'block';
        let selName = BLOCK_NAMES[selectedBlockType] || 'Block';
        let selCount = blockInventory[selectedBlockType] || 0;
        el.innerHTML = 'üß± ' + totalBlocks + ' | ' + selName + ': ' + selCount + (buildMode ? ' <span style="color:#ffcc00">[BUILD]</span>' : (isMobileDevice ? '' : ' <span style="color:#888">[SHIFT]</span>'));
        el.style.borderColor = buildMode ? '#ffcc00' : '#888';
      } else {
        el.style.display = 'none';
        buildMode = false;
      }
      updateHotbar();
    }

    function cycleWeapon() {
      if (currentVehicle) return; // No weapon/build cycling in vehicles
      // Cycle: weapon0 ‚Üí weapon1 ‚Üí ... ‚Üí blocks ‚Üí weapon0
      let totalModes = playerWeapons.length + (totalBlocks > 0 ? 1 : 0);
      if (totalModes <= 1 && totalBlocks <= 0) return; // Only 1 weapon, no blocks
      if (weaponIndex === -1) {
        // Currently in block mode, go to first weapon
        weaponIndex = 0; buildMode = false;
      } else {
        weaponIndex++;
        if (weaponIndex >= playerWeapons.length) {
          if (totalBlocks > 0) {
            weaponIndex = -1; buildMode = true;
            // Auto-select first block type the player has and sync hotbarIndex
            if (!blockInventory[selectedBlockType] || blockInventory[selectedBlockType] <= 0) {
              for (let i = 0; i < hotbarSlots.length; i++) {
                if (blockInventory[hotbarSlots[i]] > 0) {
                  hotbarIndex = i; selectedBlockType = hotbarSlots[i]; break;
                }
              }
            } else {
              // Sync hotbarIndex to match selectedBlockType
              let idx = hotbarSlots.indexOf(selectedBlockType);
              if (idx >= 0) hotbarIndex = idx;
            }
          } else {
            weaponIndex = 0;
          }
        } else {
          buildMode = false;
        }
      }
      if (weaponIndex >= 0) {
        let w = playerWeapons[weaponIndex];
        currentWeapon = w.id;
        player.projSpeed = w.projSpeed;
        player.projSize = w.projSize;
        player.projColor = w.projColor;
        applyWeaponVisualForType(w.id);
        showFloatingText(w.name, player.pos);
      } else {
        showFloatingText('BUILD MODE', player.pos);
      }
      updateBlockCounter(); updateHotbar(); updateHUD();
    }

    window.toggleBuildMode = function() {
      if (currentVehicle) return; // No build mode in vehicles
      if (totalBlocks <= 0) return;
      if (buildMode) {
        buildMode = false;
        if (playerWeapons.length > 0) {
          weaponIndex = 0;
          let w = playerWeapons[0];
          currentWeapon = w.id; player.projSpeed = w.projSpeed; player.projSize = w.projSize; player.projColor = w.projColor;
          applyWeaponVisualForType(w.id);
        }
        showFloatingText('BUILD MODE OFF', player.pos);
      } else {
        weaponIndex = -1; buildMode = true;
        if (!blockInventory[selectedBlockType] || blockInventory[selectedBlockType] <= 0) {
          for (let i = 0; i < hotbarSlots.length; i++) {
            if (blockInventory[hotbarSlots[i]] > 0) { hotbarIndex = i; selectedBlockType = hotbarSlots[i]; break; }
          }
        } else {
          let idx = hotbarSlots.indexOf(selectedBlockType);
          if (idx >= 0) hotbarIndex = idx;
        }
        showFloatingText('BUILD MODE', player.pos);
      }
      updateBlockCounter(); updateHotbar(); updateHUD();
    };

    function addWeapon(weaponId) {
      if (playerWeapons.find(w => w.id === weaponId)) return; // Already have it
      let def = WEAPON_DEFS[weaponId];
      if (!def) return;
      playerWeapons.push({...def});
      showFloatingText('+' + def.name + '!', player.pos);
    }

    function applyWeaponVisualForType(weaponId) {
      if (!player || !player.gun) return;
      let barrel = player.gun.children[0];
      let tip = player.gun.children[1];
      if (weaponId === 'pistol') {
        barrel.geometry.dispose(); barrel.geometry = new THREE.BoxGeometry(0.15, 0.2, 0.9);
        barrel.material.color.setHex(0x444444);
        tip.material.color.setHex(0xffff00);
        player.gun.position.set(0.55, 1.15, -0.5);
        player.gun.scale.setScalar(1);
      } else if (weaponId === 'cop_pistol') {
        barrel.geometry.dispose(); barrel.geometry = new THREE.BoxGeometry(0.18, 0.22, 1.1);
        barrel.material.color.setHex(0x222233);
        tip.material.color.setHex(0x00aaff);
        player.gun.position.set(0.55, 1.15, -0.5);
        player.gun.scale.setScalar(1.1);
      } else if (weaponId === 'army_rifle') {
        barrel.geometry.dispose(); barrel.geometry = new THREE.BoxGeometry(0.2, 0.25, 1.8);
        barrel.material.color.setHex(0x2a2a1a);
        tip.material.color.setHex(0xff3300);
        player.gun.position.set(0.55, 1.2, -0.6);
        player.gun.scale.setScalar(1.3);
      } else if (weaponId === 'rocket') {
        barrel.geometry.dispose(); barrel.geometry = new THREE.BoxGeometry(0.35, 0.5, 2.0);
        barrel.material.color.setHex(0x222222);
        tip.material.color.setHex(0xff4400);
        player.gun.position.set(0.6, 1.3, -0.8);
        player.gun.scale.setScalar(1);
      }
    }

    let weaponPickups = [];
    function spawnWeaponPickup(x, y, z, weaponId) {
      if (weaponPickups.length > 30) return;
      let def = WEAPON_DEFS[weaponId];
      if (!def) return;
      let size = weaponId === 'army_rifle' ? 0.6 : 0.4;
      let color = def.projColor;
      let mesh = new THREE.Mesh(
        new THREE.BoxGeometry(size * 0.4, size * 0.3, size * 1.5),
        new THREE.MeshStandardMaterial({ color: color, emissive: color, emissiveIntensity: 0.6 })
      );
      mesh.position.set(x, y + 1, z);
      scene.add(mesh);
      weaponPickups.push({ mesh, weaponId, life: 45, pos: new THREE.Vector3(x, y + 1, z), vel: new THREE.Vector3((Math.random()-0.5)*2, 4, (Math.random()-0.5)*2) });
    }

    function updateWeaponPickups(dt) {
      let collectPos = currentVehicle ? currentVehicle.pos : player.pos;
      for (let i = weaponPickups.length - 1; i >= 0; i--) {
        let wp = weaponPickups[i];
        wp.life -= dt;
        wp.mesh.rotation.y += dt * 2;
        if (wp.vel) {
          wp.vel.y -= 15 * dt;
          wp.pos.add(wp.vel.clone().multiplyScalar(dt));
          if (wp.pos.y < 1.5) { wp.pos.y = 1.5; wp.vel.y = Math.abs(wp.vel.y) * 0.2; wp.vel.x *= 0.4; wp.vel.z *= 0.4; }
          if (Math.abs(wp.vel.y) < 0.1 && wp.pos.y <= 1.6) wp.vel = null;
        }
        if (!wp.vel) wp.mesh.position.y = wp.pos.y + Math.sin(wp.life * 2) * 0.2;
        else wp.mesh.position.copy(wp.pos);
        // Magnetic pull
        let distSq = wp.pos.distanceToSquared(collectPos);
        if (distSq < 25 && distSq > 4) {
          let pull = collectPos.clone().sub(wp.pos).normalize().multiplyScalar(dt * 6);
          wp.pos.add(pull); wp.mesh.position.copy(wp.pos);
        }
        if (distSq < 4) {
          addWeapon(wp.weaponId);
          scene.remove(wp.mesh);
          weaponPickups.splice(i, 1);
          continue;
        }
        wp.mesh.material.emissiveIntensity = 0.3 + Math.sin(wp.life * 4) * 0.4;
        if (wp.life <= 0) { scene.remove(wp.mesh); weaponPickups.splice(i, 1); }
      }
    }

    function spawnBlockPickup(x, y, z, blockType) {
      if (!blockType || blockType === TYPES.EMPTY || blockType === TYPES.WATER) return;
      if (blockPickups.length > 200) return;
      let colorHex = BLOCK_COLORS[blockType];
      let color = colorHex ? parseInt(colorHex.replace('#', ''), 16) : 0x888888;
      // Try to get color from material if available
      if (!colorHex && MATERIALS[blockType]) {
        let mat = MATERIALS[blockType];
        if (mat.color) color = mat.color.getHex();
      }
      let mesh = new THREE.Mesh(new THREE.BoxGeometry(0.35, 0.35, 0.35), new THREE.MeshStandardMaterial({ color: color, emissive: color, emissiveIntensity: 0.5 }));
      mesh.position.set(x, y + 0.5, z);
      scene.add(mesh);
      // Add velocity for a slight toss effect
      let vx = (Math.random() - 0.5) * 3, vy = 3 + Math.random() * 2, vz = (Math.random() - 0.5) * 3;
      blockPickups.push({ mesh, blockType, life: 30, pos: new THREE.Vector3(x, y + 0.5, z), vel: new THREE.Vector3(vx, vy, vz) });
    }

    function updateBlockPickups(dt) {
      let collectPos = currentVehicle ? currentVehicle.pos : player.pos;
      for (let i = blockPickups.length - 1; i >= 0; i--) {
        let bp = blockPickups[i];
        bp.life -= dt;
        bp.mesh.rotation.y += dt * 3;
        bp.mesh.rotation.x += dt * 1.5;
        // Physics: gravity + bounce
        if (bp.vel) {
          bp.vel.y -= 15 * dt;
          bp.pos.add(bp.vel.clone().multiplyScalar(dt));
          // Ground bounce
          let groundY = 1;
          if (bp.pos.y < groundY) { bp.pos.y = groundY; bp.vel.y = Math.abs(bp.vel.y) * 0.3; bp.vel.x *= 0.5; bp.vel.z *= 0.5; }
          if (Math.abs(bp.vel.y) < 0.1 && bp.pos.y <= groundY + 0.1) bp.vel = null; // Stop bouncing
        }
        // Gentle bob when stationary
        if (!bp.vel) bp.mesh.position.y = bp.pos.y + Math.sin(bp.life * 3) * 0.15;
        else bp.mesh.position.copy(bp.pos);
        // Magnetic attraction when within 6 blocks
        let distSq = bp.pos.distanceToSquared(collectPos);
        if (distSq < 36 && distSq > 4) {
          let pull = collectPos.clone().sub(bp.pos).normalize().multiplyScalar(dt * 8);
          bp.pos.add(pull);
          bp.mesh.position.copy(bp.pos);
        }
        // Collect when near player
        if (distSq < 4) {
          addBlockToInventory(bp.blockType);
          scene.remove(bp.mesh);
          blockPickups.splice(i, 1);
          continue;
        }
        // Pulse glow effect
        bp.mesh.material.emissiveIntensity = 0.3 + Math.sin(bp.life * 5) * 0.3;
        if (bp.life <= 0) {
          scene.remove(bp.mesh);
          blockPickups.splice(i, 1);
        }
      }
    }

    function placeBlock() {
      if (!buildMode || !selectedBlockType || !(blockInventory[selectedBlockType] > 0)) return;
      let placed = false;
      let ray = blockRaycast(7);
      if (ray && ray.place && getBlock(ray.place.x, ray.place.y, ray.place.z) === TYPES.EMPTY) {
        setBlockGlobal(ray.place.x, ray.place.y, ray.place.z, selectedBlockType);
        placed = true;
      } else {
        // If no block hit, place on ground 5 blocks ahead
        let camDir = new THREE.Vector3(); camera.getWorldDirection(camDir);
        let pos = player.pos.clone().add(new THREE.Vector3(0, 1.5, 0));
        let target = pos.clone().add(camDir.clone().multiplyScalar(5));
        let tx = Math.round(target.x), tz = Math.round(target.z);
        for (let ty = Math.round(target.y) + 5; ty >= -3; ty--) {
          if (getBlock(tx, ty, tz) !== TYPES.EMPTY) {
            if (getBlock(tx, ty + 1, tz) === TYPES.EMPTY) {
              setBlockGlobal(tx, ty + 1, tz, selectedBlockType);
              placed = true;
            }
            break;
          }
        }
      }
      if (placed) {
        blockInventory[selectedBlockType]--;
        totalBlocks--;
        blocksPlacedForMission++;
        playSFX('place');
        updateBlockCounter();
        if (mission.active && mission.state === 'BUILD_BARRICADE') {
          document.getElementById('objective-text').innerText = 'BUILD BARRICADE: ' + blocksPlacedForMission + '/20 blocks';
          if (blocksPlacedForMission >= 20) triggerMissionSuccess();
        }
        if (mission.active && mission.state === 'BUILD_MANSION') {
          document.getElementById('objective-text').innerText = 'BUILD YOUR MANSION: ' + blocksPlacedForMission + '/40 blocks';
          if (blocksPlacedForMission >= 40) triggerMissionSuccess();
        }
      }
    }

    function setBlockGlobal(wx, wy, wz, type) {
      let cx = Math.floor(wx / CHUNK_SIZE), cz = Math.floor(wz / CHUNK_SIZE);
      let key = cx + ',' + cz;
      let chunk = activeChunks.get(key);
      if (!chunk) return;
      let lx = wx - cx * CHUNK_SIZE, lz = wz - cz * CHUNK_SIZE;
      if (lx < 0) { lx += CHUNK_SIZE; }
      if (lz < 0) { lz += CHUNK_SIZE; }
      let mapKey = lx + ',' + wy + ',' + lz;
      chunk.blocks.set(mapKey, type);
      // Ensure mesh exists for this block type
      if (!chunk.meshesByType[type]) {
        let geo = new THREE.BoxGeometry(1, 1, 1);
        let mesh = new THREE.InstancedMesh(geo, MATERIALS[type], 200);
        mesh.castShadow = true; mesh.receiveShadow = true;
        chunk.group.add(mesh);
        chunk.meshesByType[type] = mesh;
      }
      chunk.rebuildAll();
    }

    // Raycast from camera to find block position (returns {hit, place, hitType} or null)
    function blockRaycast(maxDist = 7) {
      let camDir = new THREE.Vector3(); camera.getWorldDirection(camDir);
      // In build mode, raycast from camera position for accurate first-person aiming
      let pos = buildMode ? camera.position.clone() : player.pos.clone().add(new THREE.Vector3(0, 1.5, 0));
      let prevX, prevY, prevZ;
      // Use fine steps (0.1) for accurate face detection and grid-snapped placement
      let steps = maxDist * 10;
      for (let d = 1; d <= steps; d++) {
        let check = pos.clone().add(camDir.clone().multiplyScalar(d * 0.1));
        let bx = Math.round(check.x), by = Math.round(check.y), bz = Math.round(check.z);
        let bt = getBlock(bx, by, bz);
        if (bt !== TYPES.EMPTY) {
          // Only return place if it's different from hit (proper adjacent cell)
          let place = null;
          if (prevX !== undefined && (prevX !== bx || prevY !== by || prevZ !== bz)) {
            place = { x: prevX, y: prevY, z: prevZ };
          }
          return { hit: { x: bx, y: by, z: bz }, place: place, hitType: bt };
        }
        prevX = bx; prevY = by; prevZ = bz;
      }
      return null;
    }

    function updateGhostBlock() {
      if (!ghostBlock) return;
      if (!buildMode || currentVehicle || isPaused || !isPlaying || totalBlocks <= 0) {
        ghostBlock.visible = false; return;
      }
      let ray = blockRaycast(7);
      if (ray && ray.place && getBlock(ray.place.x, ray.place.y, ray.place.z) === TYPES.EMPTY) {
        ghostBlock.visible = true;
        ghostBlock.position.set(ray.place.x, ray.place.y, ray.place.z);
        // Tint ghost to match selected block color
        let color = parseInt((BLOCK_COLORS[selectedBlockType] || '#fff').replace('#', ''), 16);
        ghostBlock.children[0].material.color.setHex(color); // wireframe
        ghostBlock.children[1].material.color.setHex(color); // fill
      } else {
        ghostBlock.visible = false;
      }
    }

    function startMining(bx, by, bz, blockType) {
      miningTarget = { x: bx, y: by, z: bz, progress: 0, type: blockType };
      if (miningOverlay) {
        miningOverlay.visible = true;
        miningOverlay.position.set(bx + 0.5, by + 0.5, bz + 0.5);
      }
    }

    function updateMining(dt) {
      if (!miningTarget || !isMouseDown || currentVehicle || isPaused) {
        cancelMining(); return;
      }
      // Check we're still looking at the same block
      let ray = blockRaycast(5);
      if (!ray || ray.hit.x !== miningTarget.x || ray.hit.y !== miningTarget.y || ray.hit.z !== miningTarget.z) {
        cancelMining(); return;
      }
      miningTarget.progress += dt;
      // Update crack overlay opacity
      if (miningOverlay) {
        let pct = Math.min(miningTarget.progress / MINE_TIME, 1);
        miningOverlay.material.opacity = pct * 0.6;
        miningOverlay.material.color.setHex(pct > 0.7 ? 0xff3300 : 0x000000);
      }
      // Block mined!
      if (miningTarget.progress >= MINE_TIME) {
        let wx = miningTarget.x, wy = miningTarget.y, wz = miningTarget.z;
        let bt = miningTarget.type;
        // Destroy the block and give it to player
        triggerDestroy(wx, wy, wz, new THREE.Vector3(0, 1, 0), true);
        // Always give the block (not just 30% drop)
        addBlockToInventory(bt);
        playSFX('mine');
        showFloatingText('Mined ' + (BLOCK_NAMES[bt] || 'Block'), player.pos);
        cancelMining();
      }
    }

    function cancelMining() {
      miningTarget = null;
      if (miningOverlay) { miningOverlay.visible = false; miningOverlay.material.opacity = 0; }
    }

    // Hotbar management
    function updateHotbar() {
      let bar = document.getElementById('hotbar');
      // Show/hide desktop build button
      let dbBtn = document.getElementById('desktop-build-btn');
      if (dbBtn && !isMobileDevice) {
        dbBtn.style.display = totalBlocks > 0 ? 'inline-block' : 'none';
        dbBtn.innerText = buildMode ? 'Build ON [Shift]' : 'Build [Shift]';
        dbBtn.style.background = buildMode ? 'rgba(255,204,0,0.6)' : 'rgba(255,204,0,0.3)';
      }
      if (!bar || totalBlocks <= 0) {
        if (bar) bar.style.display = 'none';
        return;
      }
      // Only show hotbar when in build mode
      if (!buildMode) {
        bar.style.display = 'none';
        let nl = document.getElementById('hotbar-nav-labels');
        if (nl) nl.style.display = 'none';
        return;
      }
      bar.style.display = 'flex';
      // Show navigation labels on desktop
      let navLabels = document.getElementById('hotbar-nav-labels');
      if (!navLabels && !isMobileDevice) {
        navLabels = document.createElement('div');
        navLabels.id = 'hotbar-nav-labels';
        navLabels.style.cssText = 'position:fixed; bottom:62px; left:50%; transform:translateX(-50%); z-index:50; display:flex; gap:8px; pointer-events:none;';
        navLabels.innerHTML = '<span style="background:rgba(255,255,255,0.15); border:1px solid #fff; color:#ffcc00; padding:3px 8px; border-radius:4px; font-size:12px; font-weight:bold; font-family:sans-serif;">‚óÄ Left [E]</span>' +
          '<span style="background:rgba(255,255,255,0.15); border:1px solid #fff; color:#ffcc00; padding:3px 8px; border-radius:4px; font-size:12px; font-weight:bold; font-family:sans-serif;">Right [F] ‚ñ∂</span>';
        document.body.appendChild(navLabels);
      }
      if (navLabels) navLabels.style.display = (buildMode && !currentVehicle) ? 'flex' : 'none';
      let slots = bar.children;
      for (let i = 0; i < 9; i++) {
        let slot = slots[i];
        let bType = hotbarSlots[i];
        let count = blockInventory[bType] || 0;
        let name = BLOCK_NAMES[bType] || '';
        let color = BLOCK_COLORS[bType] || '#333';
        let isSelected = (i === hotbarIndex) && buildMode;
        let iconUrl = BLOCK_ICONS[bType];
        if (count > 0 && iconUrl) {
          slot.style.background = 'url(' + iconUrl + ') center/cover';
        } else if (count > 0) {
          slot.style.background = color;
        } else {
          slot.style.background = 'rgba(30,30,30,0.7)';
        }
        slot.style.borderColor = isSelected ? '#ffcc00' : (i === hotbarIndex ? '#aaa' : '#555');
        slot.style.borderWidth = isSelected ? '3px' : '2px';
        slot.style.imageRendering = 'pixelated';
        if (count > 0) {
          slot.innerHTML = '<span style="position:absolute; top:-2px; right:-2px; background:rgba(0,0,0,0.75); color:#fff; font-size:9px; font-weight:bold; min-width:14px; height:14px; line-height:14px; text-align:center; border-radius:7px; padding:0 3px; text-shadow:1px 1px #000; pointer-events:none;">' + count + '</span>';
          slot.style.position = 'relative';
        } else {
          slot.innerHTML = '<div style="font-size:9px; color:#666;">' + (i + 1) + '</div>';
        }
        slot.style.opacity = count > 0 ? '1' : '0.4';
      }
    }

    function selectHotbarSlot(idx) {
      if (idx < 0 || idx > 8) return;
      hotbarIndex = idx;
      selectedBlockType = hotbarSlots[idx];
      if (blockInventory[selectedBlockType] > 0 && !buildMode) {
        buildMode = true;
        showFloatingText('BUILD MODE ON', player.pos);
      }
      updateBlockCounter();
      updateHotbar();
    }

    window.toggleBlockSelector = function() {
      let sel = document.getElementById('block-selector');
      if (sel.style.display === 'none') {
        sel.style.display = 'block';
        isPaused = true;
        document.exitPointerLock();
        let grid = document.getElementById('block-grid');
        grid.innerHTML = '';
        for (let bt in blockInventory) {
          if (blockInventory[bt] <= 0) continue;
          let bType = parseInt(bt);
          let name = BLOCK_NAMES[bType] || 'Block';
          let color = BLOCK_COLORS[bType] || '#888';
          let card = document.createElement('div');
          card.style.cssText = 'background:' + color + '; width:50px; height:50px; border-radius:6px; display:flex; flex-direction:column; align-items:center; justify-content:center; cursor:pointer; border:2px solid ' + (bType == selectedBlockType ? '#ffcc00' : '#555') + '; pointer-events:auto;';
          card.innerHTML = '<div style="font-size:10px; color:white; text-shadow:1px 1px #000; font-weight:bold;">' + name + '</div><div style="font-size:12px; color:white;">' + blockInventory[bt] + '</div>';
          card.onclick = () => { selectedBlockType = bType; closeBlockSelector(); };
          grid.appendChild(card);
        }
      } else {
        closeBlockSelector();
      }
    };

    window.closeBlockSelector = function() {
      document.getElementById('block-selector').style.display = 'none';
      isPaused = false;
      updateBlockCounter();
      renderer.domElement.requestPointerLock();
    };

    function updatePickups(dt) {
      let collectPos = currentVehicle ? currentVehicle.pos : player.pos;
      for (let p of pickups) {
        if (!p.active) continue;
        p.mesh.rotation.y += 3 * dt;
        p.mesh.position.y += Math.sin(Date.now() * 0.004 + p.mesh.position.x) * 0.01;
        p.life -= dt;
        if (p.mesh.position.distanceToSquared(collectPos) < 12) {
          score += p.amount; updateHUD();
          showFloatingText('+$' + p.amount, p.mesh.position.clone());
          p.active = false; p.mesh.visible = false;
        }
        if (p.life <= 0) { p.active = false; p.mesh.visible = false; }
      }
    }

    function spawnPhysicsParticle(x, y, z, color, baseVel, isSmoke = false) {
      let p = particlePool.find(p => !p.active);
      if (!p) return;
      p.active = true; p.isSmoke = isSmoke; p.mesh.position.set(x, y, z); p.mesh.visible = true;
      let hexColor = 0xffaa00;
      if (color === 'FIRE') hexColor = 0xff4400;
      else if (color === 'SMOKE') hexColor = 0x555555;
      else if (typeof color === 'number' && color > 30) hexColor = color;
      else {
        const typeColors = {
          [TYPES.BRICK]: 0x777777, [TYPES.GLASS]: 0x80bfff, [TYPES.CONCRETE]: 0x999999, [TYPES.GOLD]: 0xffaa00,
          [TYPES.STEEL]: 0x555555, [TYPES.WOOD]: 0x6b5136, [TYPES.BRICK_RED]: 0xb3473e, [TYPES.BRICK_BROWN]: 0x6b4c3a,
          [TYPES.PLASTER_LIGHT]: 0xe6e1d8, [TYPES.PLASTER_WARM]: 0xe6b981, [TYPES.CONCRETE_DARK]: 0x555555,
          [TYPES.GLASS_BLUE]: 0x5c9bd6, [TYPES.GLASS_DARK]: 0x111111
        };
        hexColor = typeColors[color] || 0x888888;
      }
      p.mesh.material.color.setHex(hexColor);
      if (isSmoke) {
        p.life = 1.0 + Math.random();
        p.vel.set((Math.random() - 0.5) * 2, 2 + Math.random() * 2, (Math.random() - 0.5) * 2);
      } else {
        p.life = 0.5 + Math.random() * 0.5;
        let spread = 15;
        p.vel.set((Math.random() - 0.5) * spread, Math.random() * spread, (Math.random() - 0.5) * spread);
        if (baseVel) p.vel.add(baseVel.clone().multiplyScalar(0.5));
      }
    }

    function spawnSkidMark(x, z, yaw, opacity = 0.6) {
      let s = skidMarks.find(m => !m.visible);
      if (!s) { s = skidMarks[0]; skidMarks.push(skidMarks.shift()); }
      s.position.set(x, 0.05, z);
      s.rotation.set(-Math.PI / 2, 0, yaw);
      s.material.opacity = opacity;
      s.visible = true;
    }

    function startGame() {
      document.getElementById('start-screen').style.display = 'none';
      isPlaying = true;
      startMission(0);
      updateHUD();
      // Phone message appears after 6 seconds
      let phoneMsg = MISSIONS[0].phoneStart;
      _phoneTimeout = setTimeout(() => showPhoneMessage(phoneMsg, 20000), 6000);
      startRadio();
      let isMobile = ('ontouchstart' in window) || window.matchMedia('(pointer: coarse)').matches;
      if (!isMobile) renderer.domElement.requestPointerLock();
    }
    let pendingPhoneMessage = null;

    function robBank() {
      if (mission.state !== 'GO_TO_BANK') return;
      bankMarkerGroup.visible = false;
      if (bankGlow) bankGlow.visible = false;
      // Animate cash wad to player
      if (bankCashWad) {
        bankCashWad.userData.animating = true;
        bankCashWad.userData.startPos = bankCashWad.position.clone();
        bankCashWad.userData.animTime = 0;
      }
      // Show success immediately after robbery
      triggerMissionSuccess();
    }

    function hideTutorial() {
      let tut = document.getElementById('tutorial-overlay');
      if (tut.style.display !== 'none') {
        tut.style.display = 'none';
      }
    }

    // --- Models ---
    class RiggedCharacter {
      constructor(type, color) {
        this.group = new THREE.Group(); this.type = type;
        let matSkin = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.8 });
        let matShirt = new THREE.MeshStandardMaterial({ color: color, roughness: 0.9 });
        let matPants = new THREE.MeshStandardMaterial({ color: type === 'COP' || type === 'ARMY' ? 0x111111 : 0x224488, roughness: 0.9 });
        if (type === 'COP') matShirt = new THREE.MeshStandardMaterial({ color: 0x113388 });
        if (type === 'ARMY') { matShirt = new THREE.MeshStandardMaterial({ color: 0x3b4d2e }); matPants = new THREE.MeshStandardMaterial({ color: 0x2b3d1e }); }
        if (type === 'ROBBER') { matShirt = new THREE.MeshStandardMaterial({ color: 0x222222 }); matSkin = new THREE.MeshStandardMaterial({ color: 0x111111 }); }
        
        this.body = new THREE.Mesh(new THREE.BoxGeometry(0.7, 1.0, 0.4), matShirt);
        this.body.position.y = 1.0; this.body.castShadow = true;
        this.head = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.5, 0.5), matSkin);
        this.head.position.y = 1.75; this.head.castShadow = true;
        let eyeGeo = new THREE.BoxGeometry(0.1, 0.1, 0.1); let eyeMat = new THREE.MeshBasicMaterial({ color: 0x000000 });
        let eyeL = new THREE.Mesh(eyeGeo, eyeMat); eyeL.position.set(-0.15, 0.05, -0.26);
        let eyeR = new THREE.Mesh(eyeGeo, eyeMat); eyeR.position.set(0.15, 0.05, -0.26);
        this.head.add(eyeL, eyeR);
        this.armL = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.9, 0.3), matShirt); this.armL.position.set(-0.55, 1.0, 0); this.armL.castShadow = true;
        this.armR = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.9, 0.3), matShirt); this.armR.position.set(0.55, 1.0, 0); this.armR.castShadow = true;
        this.legL = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.6, 0.3), matPants); this.legL.position.set(-0.2, 0.3, 0); this.legL.castShadow = true;
        this.legR = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.6, 0.3), matPants); this.legR.position.set(0.2, 0.3, 0); this.legR.castShadow = true;
        this.group.add(this.body, this.head, this.armL, this.armR, this.legL, this.legR);

        // Cop: blue hat + pistol
        if (type === 'COP') {
          let hatMat = new THREE.MeshStandardMaterial({ color: 0x113388, roughness: 0.8 });
          let hat = new THREE.Mesh(new THREE.BoxGeometry(0.52, 0.2, 0.52), hatMat);
          hat.position.y = 0.35;
          let brim = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.06, 0.65), hatMat);
          brim.position.set(0, 0.25, -0.05);
          this.head.add(hat, brim);
          this.gunGroup = new THREE.Group();
          let pistolBarrel = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.08, 0.4), new THREE.MeshStandardMaterial({ color: 0x333333, metalness: 0.5 }));
          let pistolHandle = new THREE.Mesh(new THREE.BoxGeometry(0.06, 0.15, 0.08), new THREE.MeshStandardMaterial({ color: 0x222222 }));
          pistolHandle.position.set(0, 0.1, 0.12);
          this.gunGroup.add(pistolBarrel, pistolHandle);
          this.gunGroup.position.set(0, -0.4, -0.15);
          this.armR.add(this.gunGroup);
        }
        // Army: green helmet + rifle
        if (type === 'ARMY') {
          let helmMat = new THREE.MeshStandardMaterial({ color: 0x3b4d2e, roughness: 0.9 });
          let helm = new THREE.Mesh(new THREE.BoxGeometry(0.56, 0.3, 0.56), helmMat);
          helm.position.y = 0.35;
          let rim = new THREE.Mesh(new THREE.BoxGeometry(0.62, 0.08, 0.62), helmMat);
          rim.position.y = 0.2;
          this.head.add(helm, rim);
          this.gunGroup = new THREE.Group();
          let rifleBarrel = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.1, 0.8), new THREE.MeshStandardMaterial({ color: 0x333333, metalness: 0.6 }));
          let rifleStock = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.12, 0.25), new THREE.MeshStandardMaterial({ color: 0x553311 }));
          rifleStock.position.z = 0.3;
          let rifleMag = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.2, 0.12), new THREE.MeshStandardMaterial({ color: 0x222222 }));
          rifleMag.position.set(0, -0.15, 0.1);
          this.gunGroup.add(rifleBarrel, rifleStock, rifleMag);
          this.gunGroup.position.set(0, -0.4, -0.25);
          this.armR.add(this.gunGroup);
        }

        this.walkCycle = 0;
      }
      animate(dt, speed) {
        if (speed > 0.1) {
          this.walkCycle += dt * speed * 2;
          this.legL.rotation.x = Math.sin(this.walkCycle) * 0.5; this.legR.rotation.x = Math.sin(this.walkCycle + Math.PI) * 0.5;
          this.armL.rotation.x = Math.sin(this.walkCycle + Math.PI) * 0.4; this.armR.rotation.x = Math.sin(this.walkCycle) * 0.4;
        } else {
          this.legL.rotation.x = 0; this.legR.rotation.x = 0; this.armL.rotation.x = 0; this.armR.rotation.x = 0;
        }
      }
      spawnDeathParticles(worldPos, baseVel) {
        for (let i = 0; i < 15; i++) spawnPhysicsParticle(worldPos.x, worldPos.y + 1, worldPos.z, this.body.material.color.getHex(), baseVel);
        for (let i = 0; i < 5; i++) spawnPhysicsParticle(worldPos.x, worldPos.y + 1.5, worldPos.z, 0xff0000, baseVel);
        this.group.visible = false;
      }
    }

    class PlayerModel extends RiggedCharacter {
      constructor() {
        super('PLAYER', 0xffffff); // White shirt
        this.pos = new THREE.Vector3(0, 15, 0);
        this.vel = new THREE.Vector3();
        this.yaw = 0; this.pitch = 0;

        // Yellow head
        this.head.material = new THREE.MeshStandardMaterial({ color: 0xffdd00, roughness: 0.7 });
        // Blue pants
        let matBlue = new THREE.MeshStandardMaterial({ color: 0x2255bb, roughness: 0.9 });
        this.legL.material = matBlue; this.legR.material = matBlue;

        // Hair on top of head
        let hair = new THREE.Mesh(new THREE.BoxGeometry(0.52, 0.12, 0.52), new THREE.MeshStandardMaterial({ color: 0xcc8800, roughness: 0.8 }));
        hair.position.y = 0.31;
        this.head.add(hair);
        // Mouth
        let mouth = new THREE.Mesh(new THREE.BoxGeometry(0.18, 0.06, 0.1), new THREE.MeshBasicMaterial({ color: 0x222222 }));
        mouth.position.set(0, -0.12, -0.26);
        this.head.add(mouth);

        // Yellow hands at end of arms
        let handMat = new THREE.MeshStandardMaterial({ color: 0xffdd00, roughness: 0.7 });
        let handL = new THREE.Mesh(new THREE.BoxGeometry(0.22, 0.22, 0.22), handMat);
        handL.position.y = -0.5; this.armL.add(handL);
        let handR = new THREE.Mesh(new THREE.BoxGeometry(0.22, 0.22, 0.22), handMat);
        handR.position.y = -0.5; this.armR.add(handR);

        // Gun in right hand
        this.gun = new THREE.Group();
        let gunBarrel = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.2, 0.9), new THREE.MeshStandardMaterial({ color: 0x444444, roughness: 0.4, metalness: 0.6 }));
        let gunTip = new THREE.Mesh(new THREE.BoxGeometry(0.18, 0.24, 0.15), new THREE.MeshBasicMaterial({ color: 0xffaa00 }));
        gunTip.position.set(0, 0, -0.5);
        let gunHandle = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.25, 0.15), new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.6 }));
        gunHandle.position.set(0, 0.18, 0.15);
        this.gun.add(gunBarrel, gunTip, gunHandle);
        this.gun.position.set(0.55, 1.15, -0.5);
        this.group.add(this.gun);

        scene.add(this.group);
        this.projSpeed = 200; this.projSize = 0.35; this.projColor = 0xffff00;
      }
      updatePlayerAnim(dt, isMoving) {
        this.animate(dt, isMoving ? 10 : 0);
        this.group.position.copy(this.pos);
        this.group.rotation.y = this.yaw;
        if (buildMode) {
          // Build mode: hide gun, normal arm position
          this.gun.visible = false;
          // Let walk cycle handle arm swing naturally (from animate())
          this.armR.rotation.z = 0;
        } else {
          // Combat mode: show gun, aim arm
          this.gun.visible = true;
          this.gun.rotation.x = this.pitch;
          this.armR.rotation.x = Math.PI / 2 + this.pitch;
          this.armR.rotation.z = 0.15;
        }
        // Left arm swings naturally from walk cycle
        this.armL.rotation.z = 0;
      }
      upgrade(step) {
        if (step === 1) { // Cash
          // Just sound/score logic, visually handled by UI
        }
        else if (step === 2) { // Health boost
          maxHealth += 500; playerHealth = Math.min(playerHealth + 500, maxHealth);
        }
        else if (step === 3) { // Gun
          this.gun.children[0].geometry = new THREE.BoxGeometry(0.35, 0.5, 2.0);
          this.gun.children[0].material.color.setHex(0x111111);
          this.gun.children[1].geometry = new THREE.BoxGeometry(0.4, 0.6, 0.3);
          this.gun.children[1].position.set(0, 0, -1.0);
          this.gun.position.set(0.6, 1.3, -0.8);
          let laser = new THREE.Mesh(new THREE.CylinderGeometry(0.02, 0.02, 20), new THREE.MeshBasicMaterial({ color: 0xff0000, transparent: true, opacity: 0.5 }));
          laser.rotation.x = Math.PI / 2; laser.position.set(0, 0.3, -10);
          this.gun.add(laser);
          this.projSpeed = 350; this.projSize = 0.5; this.projColor = 0xffaa00;
        }
        else if (step === 4) { // Tattoos / Style
          this.body.material.color.setHex(0x111111);
          this.head.position.y = 1.85;
          this.armL.material.color.setHex(0x2d3a31); // Inked up look
          this.armR.material.color.setHex(0x2d3a31);
        }
      }
    }

    class VoxelCar {
      constructor(type, color) {
        this.group = new THREE.Group(); this.blocks = [];
        let w = 9, h = 7, d = 20, blockSize = 0.22;
        let carMat = new THREE.MeshStandardMaterial({
          roughness: 0.2,
          metalness: 0.8
        });
        this.mesh = new THREE.InstancedMesh(new THREE.BoxGeometry(blockSize, blockSize, blockSize),
          carMat, w * h * d);
        this.mesh.castShadow = true;
        this.mesh.frustumCulled = false;
        let i = 0, m = new THREE.Matrix4(), c = new THREE.Color();
        for (let x = 0; x < w; x++) {
          for (let y = 0; y < h; y++) {
            for (let z = 0; z < d; z++) {
              let isValid = false, bColor = color;
              let isWheel = (y < 2) && (x < 1 || x > w - 2) && ((z > 2 && z < 6) || (z > d - 7 && z < d - 3));
              let isUnderbody = (y === 0) && (x >= 1 && x <= w - 2) && (z >= 1 && z < d - 1);
              let isChassis = (y >= 1 && y < 3) && (x >= 0 && x < w) && (z >= 0 && z < d);
              let isCabin = (y >= 3 && y < 5) && (x > 0 && x < w - 1) && (z > 4 && z < d - 3);
              let isRoof = (y === 5) && (x > 1 && x < w - 2) && (z > 5 && z < d - 4);
              if (isWheel) { isValid = true; bColor = 0x111111; }
              else if (isUnderbody) { isValid = true; bColor = 0x222222; }
              else if (isChassis) {
                isValid = true;
                if ((x === 0 || x === w - 1) && ((z > 1 && z < 7) || (z > d - 8 && z < d - 2))) isValid = false;
                if (y === 2 && z === 0 && (x === 1 || x === w - 2)) bColor = 0xffffaa;
                if (y === 2 && z === d - 1 && (x === 1 || x === w - 2)) bColor = 0xff0000;
              } else if (isCabin) {
                isValid = true;
                if (x === 1 || x === w - 2 || z === 5 || z === d - 4) bColor = 0x556688;
              } else if (isRoof) { isValid = true; }

              if ((type === 'COP_CAR' || type === 'ARMY_CAR') && isValid) {
                if (isChassis || isRoof || isCabin || isUnderbody) {
                  if (type === 'ARMY_CAR') {
                    if (bColor !== 0x556688 && bColor !== 0xffffaa && bColor !== 0xff0000 && bColor !== 0x111111) bColor = 0x3b4d2e;
                  } else {
                    // Classic black & white cop car
                    let isWhiteDoor = (z > 4 && z < d - 4);
                    if (bColor === 0x556688) {} // Keep window tint
                    else if (bColor === 0xffffaa || bColor === 0xff0000) {} // Keep lights
                    else if (bColor === 0x111111 || bColor === 0x222222) {} // Keep wheel/underbody
                    else if (isWhiteDoor) bColor = 0xffffff;
                    else bColor = 0x1a1a3e; // Dark navy for hood/trunk
                    // Gold badge stripe
                    if ((z === 4 || z === d - 4) && y >= 1 && y <= 3) bColor = 0xccaa00;
                  }
                }
                // Roof light bar: red/blue on y=5 AND y=6
                if ((y === 5 || y === 6) && z >= 7 && z <= 10 && x > 1 && x < w - 2) {
                  isValid = true; bColor = (x < w / 2) ? 0xff0000 : 0x0000ff;
                }
              }
              if (!isValid) continue;
              let lx = (x - w / 2 + 0.5) * blockSize, ly = y * blockSize, lz = (z - d / 2 + 0.5) * blockSize;
              m.setPosition(lx, ly, lz);
              this.mesh.setMatrixAt(i, m);
              c.setHex(bColor); this.mesh.setColorAt(i, c);
              this.blocks.push({ id: i, pos: new THREE.Vector3(lx, ly, lz), active: true, color: bColor });
              i++;
            }
          }
        }
        this.mesh.count = i; this.group.add(this.mesh);
      }
      damageAtLocal(localPos, radius, worldMatrix, baseVel) {
        let hits = 0, m = new THREE.Matrix4(), p = new THREE.Vector3();
        // Cap block removal at 50% of total blocks
        let totalActive = this.blocks.filter(b => b.active).length;
        let minBlocks = Math.ceil(this.blocks.length * 0.5);
        for (let b of this.blocks) {
          if (totalActive <= minBlocks) break; // Don't remove more than 50%
          if (b.active && b.pos.distanceTo(localPos) < radius) {
            b.active = false; m.makeScale(0, 0, 0); this.mesh.setMatrixAt(b.id, m); hits++;
            totalActive--;
            if (worldMatrix) { p.copy(b.pos).applyMatrix4(worldMatrix); spawnPhysicsParticle(p.x, p.y, p.z, b.color, baseVel); }
          }
        }
        if (hits > 0) this.mesh.instanceMatrix.needsUpdate = true;
        return hits;
      }
      darkenByDamage(healthRatio) {
        // Progressively darken car as it takes damage: 1.0 = full health, 0 = dead
        let darkFactor = Math.max(0.15, healthRatio);
        let c = new THREE.Color();
        for (let b of this.blocks) {
          if (!b.active) continue;
          c.setHex(b.color);
          c.multiplyScalar(darkFactor);
          // Add soot/burn tint at low health
          if (healthRatio < 0.4) {
            c.r = Math.min(c.r + 0.05, 0.3);
          }
          this.mesh.setColorAt(b.id, c);
        }
        this.mesh.instanceColor.needsUpdate = true;
      }
      destroyCompletely() {
        let c = new THREE.Color(0x111111);
        for (let i = 0; i < this.mesh.count; i++) this.mesh.setColorAt(i, c);
        this.mesh.instanceColor.needsUpdate = true;
      }
    }

    class VoxelPlane {
      constructor(color) {
        this.group = new THREE.Group(); this.blocks = [];
        color = 0xf0f0f0; // Always white planes
        let blockSize = 0.5;
        // Jumbo jet: Fuselage 8w x 8h x 40d, Wings 36w x 2h x 12d, Tail, Engines
        let fw = 8, fh = 8, fd = 40;
        let maxBlocks = fw*fh*fd + 36*2*12 + 4*8*6 + 16*4*6 + 100;
        this.mesh = new THREE.InstancedMesh(new THREE.BoxGeometry(blockSize, blockSize, blockSize),
          new THREE.MeshStandardMaterial({ roughness: 0.2, metalness: 0.7 }), maxBlocks);
        this.mesh.castShadow = true;
        this.mesh.frustumCulled = false;
        let i = 0, m = new THREE.Matrix4(), c = new THREE.Color();
        let halfW = fw / 2, halfD = fd / 2;
        // Fuselage (hollow tube)
        for (let x = 0; x < fw; x++) for (let y = 0; y < fh; y++) for (let z = 0; z < fd; z++) {
          let isSkin = x === 0 || x === fw-1 || y === 0 || y === fh-1 || z === 0 || z === fd-1;
          // Rounded nose taper
          let isNose = z < 4 && (x < 1 || x > fw-2 || y < 1 || y > fh-2);
          let isNoseTip = z < 2 && (x < 2 || x > fw-3 || y < 2 || y > fh-3);
          // Cockpit windows
          let isCockpit = z < 8 && z > 2 && y === fh-1 && x > 1 && x < fw-2;
          // Passenger windows - rows of small windows along sides
          let isWindow = (x === 0 || x === fw-1) && y === fh-2 && z > 6 && z < fd-6 && z % 2 === 0;
          if (isNoseTip) continue;
          if (isNose) continue;
          if (!isSkin && !isCockpit) continue;
          let bColor = color;
          if (isCockpit) bColor = 0x88ccff;
          else if (isWindow) bColor = 0x556688;
          else if (z === 0 || z === 1) bColor = 0x444444;
          else if (y === 0) bColor = 0xcccccc; // Belly lighter
          // Stripe along fuselage
          if ((x === 0 || x === fw-1) && (y === 3 || y === 4)) bColor = 0x2255aa;
          let lx = (x - halfW + 0.5) * blockSize, ly = y * blockSize, lz = (z - halfD + 0.5) * blockSize;
          m.setPosition(lx, ly, lz); this.mesh.setMatrixAt(i, m);
          c.setHex(bColor); this.mesh.setColorAt(i, c);
          this.blocks.push({ id: i, pos: new THREE.Vector3(lx, ly, lz), active: true, color: bColor }); i++;
        }
        // Wings (swept back, at mid-fuselage, y=2)
        let wingZ0 = 14, wingZLen = 12;
        for (let x = -18; x <= fw + 17; x++) for (let wy = 0; wy < 2; wy++) for (let z = wingZ0; z < wingZ0 + wingZLen; z++) {
          if (x >= 0 && x < fw) continue; // skip fuselage
          // Swept wing shape ‚Äî taper toward tips
          let dist = x < 0 ? -x : x - fw + 1;
          let tipTaper = Math.max(0, wingZLen - Math.floor(dist * 0.4));
          if (z - wingZ0 >= tipTaper) continue;
          let lx = (x - halfW + 0.5) * blockSize, ly = (2 + wy) * blockSize, lz = (z - halfD + 0.5) * blockSize;
          m.setPosition(lx, ly, lz); this.mesh.setMatrixAt(i, m);
          c.setHex(color); this.mesh.setColorAt(i, c);
          this.blocks.push({ id: i, pos: new THREE.Vector3(lx, ly, lz), active: true, color: color }); i++;
        }
        // Engines (2 under each wing)
        let enginePositions = [-10, -5, fw + 4, fw + 9];
        for (let ep of enginePositions) {
          for (let ex = 0; ex < 3; ex++) for (let ey = 0; ey < 3; ey++) for (let ez = wingZ0; ez < wingZ0 + 6; ez++) {
            let isSkin = ex === 0 || ex === 2 || ey === 0 || ey === 2 || ez === wingZ0 || ez === wingZ0 + 5;
            if (!isSkin) continue;
            let lx = (ep + ex - halfW + 0.5) * blockSize, ly = ey * blockSize, lz = (ez - halfD + 0.5) * blockSize;
            m.setPosition(lx, ly, lz); this.mesh.setMatrixAt(i, m);
            c.setHex(0x555555); this.mesh.setColorAt(i, c);
            this.blocks.push({ id: i, pos: new THREE.Vector3(lx, ly, lz), active: true, color: 0x555555 }); i++;
          }
        }
        // Tail fin (vertical)
        for (let x = 3; x < 5; x++) for (let y = fh; y < fh + 8; y++) for (let z = fd - 6; z < fd; z++) {
          let lx = (x - halfW + 0.5) * blockSize, ly = y * blockSize, lz = (z - halfD + 0.5) * blockSize;
          m.setPosition(lx, ly, lz); this.mesh.setMatrixAt(i, m);
          let tailColor = (y > fh + 4) ? 0xcc0000 : color;
          c.setHex(tailColor); this.mesh.setColorAt(i, c);
          this.blocks.push({ id: i, pos: new THREE.Vector3(lx, ly, lz), active: true, color: tailColor }); i++;
        }
        // Horizontal stabilizers
        for (let x = -6; x <= fw + 5; x++) for (let z = fd - 5; z < fd; z++) {
          if (x >= 1 && x < fw - 1) continue;
          let lx = (x - halfW + 0.5) * blockSize, ly = (fh - 1) * blockSize, lz = (z - halfD + 0.5) * blockSize;
          m.setPosition(lx, ly, lz); this.mesh.setMatrixAt(i, m);
          c.setHex(color); this.mesh.setColorAt(i, c);
          this.blocks.push({ id: i, pos: new THREE.Vector3(lx, ly, lz), active: true, color: color }); i++;
        }
        this.mesh.count = i; this.group.add(this.mesh);
      }
      damageAtLocal(localPos, radius, worldMatrix, baseVel) {
        let hits = 0, m = new THREE.Matrix4(), p = new THREE.Vector3();
        for (let b of this.blocks) {
          if (b.active && b.pos.distanceTo(localPos) < radius) {
            b.active = false; m.makeScale(0, 0, 0); this.mesh.setMatrixAt(b.id, m); hits++;
            if (worldMatrix) { p.copy(b.pos).applyMatrix4(worldMatrix); spawnPhysicsParticle(p.x, p.y, p.z, b.color, baseVel); }
          }
        }
        if (hits > 0) this.mesh.instanceMatrix.needsUpdate = true;
        return hits;
      }
      destroyCompletely() {
        let c = new THREE.Color(0x111111);
        for (let i = 0; i < this.mesh.count; i++) this.mesh.setColorAt(i, c);
        this.mesh.instanceColor.needsUpdate = true;
      }
    }

    class VoxelTank {
      constructor() {
        this.group = new THREE.Group(); this.blocks = [];
        let bs = 0.28; // Bigger blocks than car
        let w = 12, h = 4, d = 18;
        let maxBlocks = w * h * d + 200;
        let tankMat = new THREE.MeshStandardMaterial({ roughness: 0.9, metalness: 0.1 });
        this.mesh = new THREE.InstancedMesh(new THREE.BoxGeometry(bs, bs, bs), tankMat, maxBlocks);
        this.mesh.castShadow = true;
        this.mesh.frustumCulled = false;
        let i = 0, m = new THREE.Matrix4(), c = new THREE.Color();
        let tankGreen = 0x3b4d2e, darkGreen = 0x2b3d1e, trackColor = 0x222222;
        // Hull
        for (let x = 0; x < w; x++) for (let y = 0; y < h; y++) for (let z = 0; z < d; z++) {
          let isTrack = (x < 2 || x >= w - 2) && y < 2;
          let isSlopedFront = y >= 3 && z < 2 && (x < 2 || x >= w - 2);
          if (isSlopedFront) continue;
          let bColor = isTrack ? trackColor : (y === h - 1 ? darkGreen : tankGreen);
          let lx = (x - w / 2 + 0.5) * bs, ly = y * bs, lz = (z - d / 2 + 0.5) * bs;
          m.setPosition(lx, ly, lz); this.mesh.setMatrixAt(i, m);
          c.setHex(bColor); this.mesh.setColorAt(i, c);
          this.blocks.push({ id: i, pos: new THREE.Vector3(lx, ly, lz), active: true, color: bColor }); i++;
        }
        this.mesh.count = i; this.group.add(this.mesh);
        // Turret (separate group for independent rotation)
        this.turret = new THREE.Group();
        let tw = 6, th = 3, td = 6, bw = 2, bh = 2, bd = 10;
        let turretMax = tw * th * td + bw * bh * bd + 20;
        this.turretMesh = new THREE.InstancedMesh(new THREE.BoxGeometry(bs, bs, bs), tankMat, turretMax);
        this.turretMesh.castShadow = true;
        this.turretMesh.frustumCulled = false;
        let ti = 0;
        for (let x = 0; x < tw; x++) for (let y = 0; y < th; y++) for (let z = 0; z < td; z++) {
          let bColor = y === th - 1 ? darkGreen : tankGreen;
          let lx = (x - tw / 2 + 0.5) * bs, ly = y * bs, lz = (z - td / 2 + 0.5) * bs;
          m.setPosition(lx, ly, lz); this.turretMesh.setMatrixAt(ti, m);
          c.setHex(bColor); this.turretMesh.setColorAt(ti, c);
          this.blocks.push({ id: ti, pos: new THREE.Vector3(lx, ly, lz), active: true, color: bColor, isTurret: true }); ti++;
        }
        // Barrel extending forward
        for (let x = 0; x < bw; x++) for (let y = 0; y < bh; y++) for (let z = 0; z < bd; z++) {
          let lx = (x - bw / 2 + 0.5) * bs, ly = (y + 0.5) * bs, lz = -(z + td / 2) * bs;
          m.setPosition(lx, ly, lz); this.turretMesh.setMatrixAt(ti, m);
          c.setHex(0x444444); this.turretMesh.setColorAt(ti, c);
          this.blocks.push({ id: ti, pos: new THREE.Vector3(lx, ly, lz), active: true, color: 0x444444, isTurret: true }); ti++;
        }
        this.turretMesh.count = ti; this.turret.add(this.turretMesh);
        this.turret.position.y = h * bs;
        this.group.add(this.turret);
        this.barrelTipLocal = new THREE.Vector3(0, 0.5 * bs, -(td / 2 + bd) * bs);
      }
      getBarrelTipWorld() {
        let tip = new THREE.Vector3();
        this.turret.localToWorld(tip.copy(this.barrelTipLocal));
        return tip;
      }
      damageAtLocal(localPos, radius, worldMatrix, baseVel) {
        let hits = 0, m = new THREE.Matrix4(), p = new THREE.Vector3();
        for (let b of this.blocks) {
          if (b.active && b.pos.distanceTo(localPos) < radius) {
            b.active = false; m.makeScale(0, 0, 0);
            if (b.isTurret) this.turretMesh.setMatrixAt(b.id, m);
            else this.mesh.setMatrixAt(b.id, m);
            hits++;
            if (worldMatrix) { p.copy(b.pos).applyMatrix4(worldMatrix); spawnPhysicsParticle(p.x, p.y, p.z, b.color, baseVel); }
          }
        }
        if (hits > 0) { this.mesh.instanceMatrix.needsUpdate = true; this.turretMesh.instanceMatrix.needsUpdate = true; }
        return hits;
      }
      destroyCompletely() {
        let cl = new THREE.Color(0x111111);
        for (let j = 0; j < this.mesh.count; j++) this.mesh.setColorAt(j, cl);
        for (let j = 0; j < this.turretMesh.count; j++) this.turretMesh.setColorAt(j, cl);
        this.mesh.instanceColor.needsUpdate = true; this.turretMesh.instanceColor.needsUpdate = true;
      }
    }

    // --- Initialization ---
    function init() {
      scene = new THREE.Scene();
      scene.fog = new THREE.FogExp2(0x88b8d8, 0.0010);
      camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 2500);
      renderer = new THREE.WebGLRenderer({
        canvas: document.getElementById('game-canvas'), antialias: false, powerPreference: "high-performance"
      });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      renderer.toneMapping = THREE.ACESFilmicToneMapping;
      renderer.toneMappingExposure = 0.72;
      renderer.outputEncoding = THREE.sRGBEncoding;

      const pmremGenerator = new THREE.PMREMGenerator(renderer);
      pmremGenerator.compileEquirectangularShader();
      const skyTex = createSkyTexture();
      const envMap = pmremGenerator.fromEquirectangular(skyTex).texture;
      scene.environment = envMap;
      minimapCtx = document.getElementById('minimap').getContext('2d');
      
      const hemiLight = new THREE.HemisphereLight(0x6699bb, 0x334422, 0.4);
      scene.add(hemiLight);
      
      dirLight = new THREE.DirectionalLight(0xffe8cc, 1.1);
      dirLight.position.set(200, 300, 150);
      dirLight.castShadow = true;
      dirLight.shadow.camera.left = -100; dirLight.shadow.camera.right = 100;
      dirLight.shadow.camera.top = 100; dirLight.shadow.camera.bottom = -100;
      dirLight.shadow.mapSize.width = 2048; dirLight.shadow.mapSize.height = 2048;
      dirLight.shadow.bias = -0.001;
      scene.add(dirLight); scene.add(dirLight.target);
      
      const skyGeo = new THREE.SphereGeometry(1200, 32, 32);
      const skyMat = new THREE.MeshBasicMaterial({ map: skyTex, side: THREE.BackSide, fog: false });
      skybox = new THREE.Mesh(skyGeo, skyMat);
      scene.add(skybox);

      MATERIALS[TYPES.GRASS] = buildPBRMaterial(createTex('GRASS'));
      MATERIALS[TYPES.ROAD] = buildPBRMaterial(createTex('ROAD'), { roughness: 0.9, metalness: 0.1 });
      MATERIALS[TYPES.HIGHWAY] = buildPBRMaterial(createTex('HIGHWAY'), { roughness: 0.9, metalness: 0.1 });
      
      const waterTexObj = createTex('WATER');
      MATERIALS[TYPES.WATER] = new THREE.MeshPhysicalMaterial({
        map: waterTexObj.map, bumpMap: waterTexObj.bumpMap, bumpScale: 0.1, roughnessMap: waterTexObj.roughnessMap,
        color: 0x3388cc, metalness: 0.95, roughness: 0.05, transparent: true, opacity: 0.85, envMap: envMap, envMapIntensity: 1.0
      });
      MATERIALS[TYPES.WATER].onBeforeCompile = (shader) => {
        shader.uniforms.time = customUniforms.time;
        shader.vertexShader = `uniform float time;\n${shader.vertexShader}`.replace(
          `#include <project_vertex>`,
          `vec4 worldPositionWave = instanceMatrix * vec4( transformed, 1.0 );
           float wave = sin(worldPositionWave.x * 0.5 + time * 1.5) * cos(worldPositionWave.z * 0.5 + time * 1.5) * 0.25;
           transformed.y += wave;
           #include <project_vertex>`
        );
      };
      
      MATERIALS[TYPES.WOOD] = buildPBRMaterial(createTex('WOOD'));
      MATERIALS[TYPES.LEAVES] = buildPBRMaterial(createTex('LEAVES'), { transparent: true, opacity: 0.9, side: THREE.DoubleSide });
      MATERIALS[TYPES.BRICK] = buildPBRMaterial(createTex('BRICK'));
      MATERIALS[TYPES.BRICK_RED] = buildPBRMaterial(createTex('BRICK_RED'));
      MATERIALS[TYPES.BRICK_BROWN] = buildPBRMaterial(createTex('BRICK_BROWN'));
      MATERIALS[TYPES.PLASTER_LIGHT] = buildPBRMaterial(createTex('PLASTER_LIGHT'));
      MATERIALS[TYPES.PLASTER_WARM] = buildPBRMaterial(createTex('PLASTER_WARM'));
      MATERIALS[TYPES.CONCRETE] = buildPBRMaterial(createTex('CONCRETE'));
      MATERIALS[TYPES.CONCRETE_DARK] = buildPBRMaterial(createTex('CONCRETE_DARK'));
      MATERIALS[TYPES.GLASS] = buildPBRMaterial(createTex('GLASS'), { transparent: true, opacity: 0.6, metalness: 1.0, roughness: 0.0, envMapIntensity: 1.0 });
      MATERIALS[TYPES.GLASS_BLUE] = buildPBRMaterial(createTex('GLASS_BLUE'), { transparent: true, opacity: 0.7, metalness: 1.0, roughness: 0.0, envMapIntensity: 1.0 });
      MATERIALS[TYPES.GLASS_DARK] = buildPBRMaterial(createTex('GLASS_DARK'), { transparent: true, opacity: 0.85, metalness: 1.0, roughness: 0.0, envMapIntensity: 1.0 });
      MATERIALS[TYPES.GOLD] = buildPBRMaterial(createTex('GOLD'), { metalness: 1.0, roughness: 0.2 });
      MATERIALS[TYPES.LIGHT] = buildPBRMaterial(createTex('LIGHT'), { emissive: 0xffffaa, emissiveIntensity: 2.0 });
      MATERIALS[TYPES.DIRT] = buildPBRMaterial(createTex('DIRT'));
      MATERIALS[TYPES.STEEL] = buildPBRMaterial(createTex('STEEL'), { metalness: 0.8, roughness: 0.4 });
      MATERIALS[TYPES.BLUE] = new THREE.MeshStandardMaterial({ color: 0x113388, roughness: 0.8 });
      MATERIALS[TYPES.WHITE] = new THREE.MeshStandardMaterial({ color: 0xeeeeee, roughness: 0.8 });
      MATERIALS[TYPES.RED] = new THREE.MeshStandardMaterial({ color: 0xaa1111, roughness: 0.8 });
      MATERIALS[TYPES.SIDEWALK] = buildPBRMaterial(createTex('SIDEWALK'), { roughness: 0.85, metalness: 0.05 });
      MATERIALS[TYPES.RAIL] = buildPBRMaterial(createTex('RAIL'), { roughness: 0.3, metalness: 0.9 });
      MATERIALS[TYPES.YELLOW] = new THREE.MeshStandardMaterial({ color: 0xddaa00, roughness: 0.8, emissive: 0xddaa00, emissiveIntensity: 0.3 });
      MATERIALS[TYPES.GREEN] = new THREE.MeshStandardMaterial({ color: 0x22aa22, roughness: 0.8, emissive: 0x22aa22, emissiveIntensity: 0.3 });
      MATERIALS[TYPES.STONE] = buildPBRMaterial(createTex('STONE'));
      MATERIALS[TYPES.IRON_ORE] = buildPBRMaterial(createTex('IRON_ORE'));
      MATERIALS[TYPES.COAL_ORE] = buildPBRMaterial(createTex('COAL_ORE'));
      MATERIALS[TYPES.DIAMOND_ORE] = buildPBRMaterial(createTex('DIAMOND_ORE'), { emissive: 0x2299aa, emissiveIntensity: 0.2 });
      MATERIALS[TYPES.SNOW] = new THREE.MeshStandardMaterial({ color: 0xf0f0ff, roughness: 0.9, metalness: 0.0 });
      MATERIALS[TYPES.SAND] = new THREE.MeshStandardMaterial({ color: 0xe8d68a, roughness: 0.95, metalness: 0.0 });

      // Build block icon data URLs for 2D hotbar display
      for (let typeKey in TYPES) {
        let typeVal = TYPES[typeKey];
        let mat = MATERIALS[typeVal];
        if (!mat) continue;
        if (mat.map && mat.map.image && mat.map.image.toDataURL) {
          BLOCK_ICONS[typeVal] = mat.map.image.toDataURL();
        } else if (mat.color) {
          let ic = document.createElement('canvas'); ic.width = 32; ic.height = 32;
          let ictx = ic.getContext('2d');
          ictx.fillStyle = '#' + mat.color.getHexString();
          ictx.fillRect(0, 0, 32, 32);
          // Add subtle noise for visual interest
          for (let x = 0; x < 32; x += 4) {
            for (let y = 0; y < 32; y += 4) {
              if (Math.random() > 0.6) {
                ictx.fillStyle = 'rgba(255,255,255,0.15)';
                ictx.fillRect(x, y, 4, 4);
              }
            }
          }
          BLOCK_ICONS[typeVal] = ic.toDataURL();
        }
      }

      let partGeo = new THREE.BoxGeometry(0.3, 0.3, 0.3);
      for (let i = 0; i < MAX_PARTICLES; i++) {
        let m = new THREE.Mesh(partGeo, new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.8 }));
        m.visible = false; scene.add(m);
        particlePool.push({ mesh: m, life: 0, vel: new THREE.Vector3(), active: false, isSmoke: false });
      }
      
      const skidGeo = new THREE.PlaneGeometry(0.4, 1.8); // Narrow & elongated tyre streaks
      const skidMat = new THREE.MeshBasicMaterial({ color: 0x111111, transparent: true, opacity: 0.6, depthWrite: false });
      for (let i = 0; i < 500; i++) {
        let m = new THREE.Mesh(skidGeo, skidMat.clone());
        m.rotation.x = -Math.PI / 2; m.visible = false; scene.add(m);
        skidMarks.push(m);
      }
      
      // Floating GTA-style Bank Marker
      bankMarkerGroup = new THREE.Group();
      bankMarkerGroup.position.set(72, 0, 72);
      
      const markerGeo = new THREE.OctahedronGeometry(3, 0);
      const markerMat = new THREE.MeshStandardMaterial({ color: 0xffcc00, emissive: 0xffaa00, emissiveIntensity: 0.8 });
      let floatingCrystal = new THREE.Mesh(markerGeo, markerMat);
      floatingCrystal.position.set(0, 25, 0);
      bankMarkerGroup.add(floatingCrystal);

      const pillarGeo = new THREE.CylinderGeometry(4, 4, 150, 16);
      const pillarMat = new THREE.MeshBasicMaterial({ color: 0xffcc00, transparent: true, opacity: 0.2, blending: THREE.AdditiveBlending, depthWrite: false });
      let pillarMesh = new THREE.Mesh(pillarGeo, pillarMat);
      pillarMesh.position.set(0, 75, 0);
      bankMarkerGroup.add(pillarMesh);

      const bankSignCanvas = document.createElement('canvas');
      bankSignCanvas.width = 512; bankSignCanvas.height = 128;
      const bctx = bankSignCanvas.getContext('2d');
      bctx.fillStyle = 'rgba(0, 0, 0, 0.5)'; bctx.fillRect(0,0,512,128);
      bctx.fillStyle = '#ffcc00'; bctx.font = 'bold 90px sans-serif'; bctx.textAlign = 'center'; bctx.textBaseline = 'middle';
      bctx.fillText('BANK', 256, 64);
      const bankSignTex = new THREE.CanvasTexture(bankSignCanvas);
      const bankSignMat = new THREE.MeshBasicMaterial({ map: bankSignTex, transparent: true });
      let bankSignMesh = new THREE.Mesh(new THREE.PlaneGeometry(16, 4), bankSignMat);
      bankSignMesh.position.set(0, 12, -13); // Above door (south face, viewer from -Z)
      bankSignMesh.rotation.y = Math.PI;
      bankMarkerGroup.add(bankSignMesh);

      scene.add(bankMarkerGroup);

      // Bank signs on all 4 sides (lower, at height 8)
      let bsm = bankSignMat.clone(); bsm.side = THREE.DoubleSide;
      let bankSignS = new THREE.Mesh(new THREE.PlaneGeometry(16, 4), bsm);
      bankSignS.position.set(72, 8, 60.5); bankSignS.rotation.y = Math.PI; scene.add(bankSignS); // South (front)
      let bankSignN = new THREE.Mesh(new THREE.PlaneGeometry(16, 4), bsm.clone());
      bankSignN.position.set(72, 8, 83.5); scene.add(bankSignN); // North (back)
      let bankSignW = new THREE.Mesh(new THREE.PlaneGeometry(16, 4), bsm.clone());
      bankSignW.position.set(60.5, 8, 72); bankSignW.rotation.y = -Math.PI / 2; scene.add(bankSignW); // West
      let bankSignE = new THREE.Mesh(new THREE.PlaneGeometry(16, 4), bsm.clone());
      bankSignE.position.set(83.5, 8, 72); bankSignE.rotation.y = Math.PI / 2; scene.add(bankSignE); // East

      // Yellow glow ring around mission buildings
      let glowMat = new THREE.MeshBasicMaterial({ color: 0xffcc00, transparent: true, opacity: 0.25, blending: THREE.AdditiveBlending, depthWrite: false, side: THREE.DoubleSide });
      let bankGlow = new THREE.Mesh(new THREE.RingGeometry(12, 16, 32), glowMat);
      bankGlow.rotation.x = -Math.PI / 2; bankGlow.position.set(72, 0.2, 72);
      bankGlow.visible = false; scene.add(bankGlow);
      let storeGlow = new THREE.Mesh(new THREE.RingGeometry(8, 12, 32), glowMat.clone());
      storeGlow.rotation.x = -Math.PI / 2; storeGlow.position.set(STORE_POS.x, 0.2, STORE_POS.z);
      storeGlow.visible = false; scene.add(storeGlow);

      // Floating 3D Cash Wad above bank teller
      bankCashWad = new THREE.Group();
      let cashMat = new THREE.MeshStandardMaterial({ color: 0x22aa22, emissive: 0x115511, emissiveIntensity: 0.4 });
      for (let i = 0; i < 6; i++) {
        let bill = new THREE.Mesh(new THREE.BoxGeometry(1.8, 0.2, 2.8), cashMat);
        bill.position.y = i * 0.12; bill.rotation.y = i * 0.08;
        bankCashWad.add(bill);
      }
      let cashBand = new THREE.Mesh(new THREE.BoxGeometry(1.9, 0.9, 0.4), new THREE.MeshStandardMaterial({ color: 0xffffff }));
      cashBand.position.y = 0.3; bankCashWad.add(cashBand);
      // $ symbol on band
      let $canvas = document.createElement('canvas'); $canvas.width = 64; $canvas.height = 64;
      let $ctx = $canvas.getContext('2d'); $ctx.fillStyle = '#22aa22'; $ctx.font = 'bold 50px Arial';
      $ctx.textAlign = 'center'; $ctx.textBaseline = 'middle'; $ctx.fillText('$', 32, 32);
      let $tex = new THREE.CanvasTexture($canvas);
      let $sign = new THREE.Mesh(new THREE.PlaneGeometry(0.8, 0.8), new THREE.MeshBasicMaterial({ map: $tex, transparent: true, side: THREE.DoubleSide }));
      $sign.position.set(0, 0.3, 0.25); bankCashWad.add($sign);
      bankCashWad.position.set(72, 6, 66);
      scene.add(bankCashWad);

      // Store building sign
      let storeSignCanvas = document.createElement('canvas');
      storeSignCanvas.width = 512; storeSignCanvas.height = 128;
      let sctx = storeSignCanvas.getContext('2d');
      sctx.fillStyle = '#1b5e20'; sctx.fillRect(0, 0, 512, 128);
      sctx.fillStyle = '#ffffff'; sctx.font = 'bold 80px sans-serif'; sctx.textAlign = 'center'; sctx.textBaseline = 'middle';
      sctx.fillText('STORE', 256, 64);
      let storeSignTex = new THREE.CanvasTexture(storeSignCanvas);
      let ssm = new THREE.MeshBasicMaterial({ map: storeSignTex, side: THREE.DoubleSide });
      let storeSS = new THREE.Mesh(new THREE.PlaneGeometry(12, 3), ssm);
      storeSS.position.set(-73, 8, 12.5); storeSS.rotation.y = Math.PI; scene.add(storeSS); // South (front)
      let storeSN = new THREE.Mesh(new THREE.PlaneGeometry(12, 3), ssm.clone());
      storeSN.position.set(-73, 8, 29.5); scene.add(storeSN); // North (back)
      let storeSW = new THREE.Mesh(new THREE.PlaneGeometry(12, 3), ssm.clone());
      storeSW.position.set(-83.5, 8, 21); storeSW.rotation.y = -Math.PI / 2; scene.add(storeSW); // West
      let storeSE = new THREE.Mesh(new THREE.PlaneGeometry(12, 3), ssm.clone());
      storeSE.position.set(-63.5, 8, 21); storeSE.rotation.y = Math.PI / 2; scene.add(storeSE); // East

      // Carpark building signs ‚Äî all 4 sides
      let carparkSignCanvas = document.createElement('canvas');
      carparkSignCanvas.width = 512; carparkSignCanvas.height = 128;
      let cpctx = carparkSignCanvas.getContext('2d');
      cpctx.fillStyle = '#4a2800'; cpctx.fillRect(0, 0, 512, 128);
      cpctx.strokeStyle = '#ff6600'; cpctx.lineWidth = 6; cpctx.strokeRect(8, 8, 496, 112);
      cpctx.fillStyle = '#ff8800'; cpctx.font = 'bold 72px sans-serif'; cpctx.textAlign = 'center'; cpctx.textBaseline = 'middle';
      cpctx.fillText('CARPARK', 256, 64);
      let carparkSignTex = new THREE.CanvasTexture(carparkSignCanvas);
      let cpSignMat = new THREE.MeshBasicMaterial({ map: carparkSignTex, side: THREE.DoubleSide });
      // South face
      let cpSignS = new THREE.Mesh(new THREE.PlaneGeometry(16, 4), cpSignMat.clone());
      cpSignS.position.set(CARPARK_POS.x, 22, CARPARK_POS.z - 13); scene.add(cpSignS);
      // North face
      let cpSignN = new THREE.Mesh(new THREE.PlaneGeometry(16, 4), cpSignMat.clone());
      cpSignN.position.set(CARPARK_POS.x, 22, CARPARK_POS.z + 13); cpSignN.rotation.y = Math.PI; scene.add(cpSignN);
      // West face
      let cpSignW = new THREE.Mesh(new THREE.PlaneGeometry(16, 4), cpSignMat.clone());
      cpSignW.position.set(CARPARK_POS.x - 13, 22, CARPARK_POS.z); cpSignW.rotation.y = Math.PI / 2; scene.add(cpSignW);
      // East face
      let cpSignE = new THREE.Mesh(new THREE.PlaneGeometry(16, 4), cpSignMat.clone());
      cpSignE.position.set(CARPARK_POS.x + 13, 22, CARPARK_POS.z); cpSignE.rotation.y = -Math.PI / 2; scene.add(cpSignE);

      // Airport signs on all 4 sides of terminal
      let apSignCanvas = document.createElement('canvas');
      apSignCanvas.width = 512; apSignCanvas.height = 128;
      let apctx = apSignCanvas.getContext('2d');
      apctx.fillStyle = '#003366'; apctx.fillRect(0, 0, 512, 128);
      apctx.fillStyle = '#ffffff'; apctx.font = 'bold 72px sans-serif'; apctx.textAlign = 'center'; apctx.textBaseline = 'middle';
      apctx.fillText('AIRPORT', 256, 64);
      let apSignTex = new THREE.CanvasTexture(apSignCanvas);
      let apm = new THREE.MeshBasicMaterial({ map: apSignTex, side: THREE.DoubleSide });
      let apSignS = new THREE.Mesh(new THREE.PlaneGeometry(20, 5), apm);
      apSignS.position.set(AIRPORT_X, 8, AIRPORT_Z + 14.5); apSignS.rotation.y = Math.PI; scene.add(apSignS);
      let apSignN = new THREE.Mesh(new THREE.PlaneGeometry(20, 5), apm.clone());
      apSignN.position.set(AIRPORT_X, 8, AIRPORT_Z + 38.5); scene.add(apSignN);
      let apSignW = new THREE.Mesh(new THREE.PlaneGeometry(20, 5), apm.clone());
      apSignW.position.set(AIRPORT_X - 120, 8, AIRPORT_Z); apSignW.rotation.y = -Math.PI / 2; scene.add(apSignW);
      let apSignE = new THREE.Mesh(new THREE.PlaneGeometry(20, 5), apm.clone());
      apSignE.position.set(AIRPORT_X + 120, 8, AIRPORT_Z); apSignE.rotation.y = Math.PI / 2; scene.add(apSignE);

      // Airport marker (visible during mission 6)
      airportMarkerGroup = new THREE.Group();
      airportMarkerGroup.position.set(AIRPORT_X, 0, AIRPORT_Z + 9);
      let apCrystal = new THREE.Mesh(markerGeo.clone(), new THREE.MeshStandardMaterial({ color: 0x4488ff, emissive: 0x2244aa, emissiveIntensity: 0.8 }));
      apCrystal.position.set(0, 15, 0); airportMarkerGroup.add(apCrystal);
      let apPillar = new THREE.Mesh(pillarGeo.clone(), new THREE.MeshBasicMaterial({ color: 0x4488ff, transparent: true, opacity: 0.15, blending: THREE.AdditiveBlending, depthWrite: false }));
      apPillar.position.set(0, 75, 0); airportMarkerGroup.add(apPillar);
      airportMarkerGroup.visible = false;
      scene.add(airportMarkerGroup);

      // Store Marker (green)
      storeMarkerGroup = new THREE.Group();
      storeMarkerGroup.position.copy(STORE_POS).setY(0);
      let storeCrystal = new THREE.Mesh(markerGeo.clone(), new THREE.MeshStandardMaterial({ color: 0x00ff00, emissive: 0x00aa00, emissiveIntensity: 0.8 }));
      storeCrystal.position.set(0, 15, 0); storeMarkerGroup.add(storeCrystal);
      let storePillar = new THREE.Mesh(pillarGeo.clone(), new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0.15, blending: THREE.AdditiveBlending, depthWrite: false }));
      storePillar.position.set(0, 75, 0); storeMarkerGroup.add(storePillar);
      storeMarkerGroup.visible = false;
      scene.add(storeMarkerGroup);

      // Alley Safe Zone Marker (blue)
      alleyMarkerGroup = new THREE.Group();
      alleyMarkerGroup.position.copy(ALLEY_POS).setY(0);
      let alleyCrystal = new THREE.Mesh(markerGeo.clone(), new THREE.MeshStandardMaterial({ color: 0x4488ff, emissive: 0x2244aa, emissiveIntensity: 0.8 }));
      alleyCrystal.position.set(0, 15, 0); alleyMarkerGroup.add(alleyCrystal);
      let alleyPillar = new THREE.Mesh(pillarGeo.clone(), new THREE.MeshBasicMaterial({ color: 0x4488ff, transparent: true, opacity: 0.15, blending: THREE.AdditiveBlending, depthWrite: false }));
      alleyPillar.position.set(0, 75, 0); alleyMarkerGroup.add(alleyPillar);
      alleyMarkerGroup.visible = false;
      scene.add(alleyMarkerGroup);

      // Carpark Marker (red/orange)
      carparkMarkerGroup = new THREE.Group();
      carparkMarkerGroup.position.copy(CARPARK_POS).setY(0);
      let carparkCrystal = new THREE.Mesh(markerGeo.clone(), new THREE.MeshStandardMaterial({ color: 0xff6600, emissive: 0xaa4400, emissiveIntensity: 0.8 }));
      carparkCrystal.position.set(0, 15, 0); carparkMarkerGroup.add(carparkCrystal);
      let carparkPillar = new THREE.Mesh(pillarGeo.clone(), new THREE.MeshBasicMaterial({ color: 0xff6600, transparent: true, opacity: 0.15, blending: THREE.AdditiveBlending, depthWrite: false }));
      carparkPillar.position.set(0, 75, 0); carparkMarkerGroup.add(carparkPillar);
      carparkMarkerGroup.visible = false;
      scene.add(carparkMarkerGroup);

      // Barricade Marker (yellow)
      barricadeMarkerGroup = new THREE.Group();
      barricadeMarkerGroup.position.copy(BARRICADE_POS).setY(0);
      let barricadeCrystal = new THREE.Mesh(markerGeo.clone(), new THREE.MeshStandardMaterial({ color: 0xffcc00, emissive: 0xaa8800, emissiveIntensity: 0.8 }));
      barricadeCrystal.position.set(0, 15, 0); barricadeMarkerGroup.add(barricadeCrystal);
      let barricadePillar = new THREE.Mesh(pillarGeo.clone(), new THREE.MeshBasicMaterial({ color: 0xffcc00, transparent: true, opacity: 0.15, blending: THREE.AdditiveBlending, depthWrite: false }));
      barricadePillar.position.set(0, 75, 0); barricadeMarkerGroup.add(barricadePillar);
      barricadeMarkerGroup.visible = false;
      scene.add(barricadeMarkerGroup);

      // Island Castle Marker (gold/purple) - visible after plane mission
      islandMarkerGroup = new THREE.Group();
      islandMarkerGroup.position.set(ISLAND_X, 0, ISLAND_Z + 18);
      let islandCrystal = new THREE.Mesh(markerGeo.clone(), new THREE.MeshStandardMaterial({ color: 0xffd700, emissive: 0xcc8800, emissiveIntensity: 1.0 }));
      islandCrystal.position.set(0, 20, 0); islandMarkerGroup.add(islandCrystal);
      let islandPillar = new THREE.Mesh(pillarGeo.clone(), new THREE.MeshBasicMaterial({ color: 0xffd700, transparent: true, opacity: 0.2, blending: THREE.AdditiveBlending, depthWrite: false }));
      islandPillar.position.set(0, 75, 0); islandMarkerGroup.add(islandPillar);
      islandMarkerGroup.visible = false;
      scene.add(islandMarkerGroup);

      // Pickup pool (cash drops)
      let pickupGeo = new THREE.BoxGeometry(0.7, 0.15, 1.0);
      let pickupMat = new THREE.MeshStandardMaterial({ color: 0x22aa22, emissive: 0x115511, emissiveIntensity: 0.5 });
      for (let i = 0; i < MAX_PICKUPS; i++) {
        let pg = new THREE.Group();
        let bill = new THREE.Mesh(pickupGeo, pickupMat);
        pg.add(bill);
        let band = new THREE.Mesh(new THREE.BoxGeometry(0.75, 0.3, 0.15), new THREE.MeshStandardMaterial({ color: 0xffffff }));
        band.position.y = 0.08; pg.add(band);
        pg.visible = false; scene.add(pg);
        pickups.push({ mesh: pg, active: false, amount: 0, life: 0 });
      }

      // 3D Waypoint Arrow (follows camera, points toward mission target in 3D)
      waypointArrow3D = new THREE.Group();
      const arrowMat = new THREE.MeshBasicMaterial({ color: 0xffcc00, depthTest: false, transparent: true, opacity: 0.92 });
      // Simple rounded triangle pointing +Y (like a navigation arrow)
      let triShape = new THREE.Shape();
      triShape.moveTo(0, 0.35);    // tip
      triShape.lineTo(-0.15, -0.15);
      triShape.quadraticCurveTo(-0.12, -0.08, 0, -0.05); // rounded base left
      triShape.quadraticCurveTo(0.12, -0.08, 0.15, -0.15); // rounded base right
      triShape.lineTo(0, 0.35);    // back to tip
      let triGeo = new THREE.ExtrudeGeometry(triShape, { depth: 0.06, bevelEnabled: true, bevelThickness: 0.02, bevelSize: 0.02, bevelSegments: 3 });
      triGeo.center();
      let arrowTri = new THREE.Mesh(triGeo, arrowMat);
      waypointArrow3D.add(arrowTri);
      // Distance label sprite
      let distCanvas = document.createElement('canvas');
      distCanvas.width = 128; distCanvas.height = 64;
      let distTex = new THREE.CanvasTexture(distCanvas);
      let distSprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: distTex, depthTest: false, transparent: true }));
      distSprite.scale.set(0.5, 0.25, 1);
      distSprite.position.set(0, -0.3, 0);
      waypointArrow3D.add(distSprite);
      waypointArrow3D.userData.distCanvas = distCanvas;
      waypointArrow3D.userData.distTex = distTex;
      waypointArrow3D.userData.distSprite = distSprite;
      waypointArrow3D.traverse(c => { if (c.isMesh || c.isSprite) c.renderOrder = 999; });
      waypointArrow3D.renderOrder = 999;
      waypointArrow3D.visible = false;
      scene.add(waypointArrow3D);

      player = new PlayerModel();

      // Setup Post-Processing Composer
      composer = new EffectComposer(renderer);
      const renderPass = new RenderPass(scene, camera);
      composer.addPass(renderPass);
      const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 0.2, 0.4, 0.95);
      composer.addPass(bloomPass);

      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        composer.setSize(window.innerWidth, window.innerHeight);
      });

      // Ghost block preview (wireframe + translucent)
      let ghostGeo = new THREE.BoxGeometry(1.02, 1.02, 1.02);
      let ghostEdges = new THREE.EdgesGeometry(ghostGeo);
      ghostBlock = new THREE.Group();
      let ghostWire = new THREE.LineSegments(ghostEdges, new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.8 }));
      let ghostFill = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 1), new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.15, depthWrite: false }));
      ghostBlock.add(ghostWire); ghostBlock.add(ghostFill);
      ghostBlock.visible = false;
      scene.add(ghostBlock);
      // Mining crack overlay
      miningOverlay = new THREE.Mesh(new THREE.BoxGeometry(1.01, 1.01, 1.01), new THREE.MeshBasicMaterial({ color: 0x000000, transparent: true, opacity: 0, depthWrite: false, wireframe: true }));
      miningOverlay.visible = false;
      scene.add(miningOverlay);

      // Atmospheric dust particles
      let dustCount = 200;
      let dustGeo = new THREE.BufferGeometry();
      let dustPositions = new Float32Array(dustCount * 3);
      for (let i = 0; i < dustCount; i++) {
        dustPositions[i * 3] = (Math.random() - 0.5) * 80;
        dustPositions[i * 3 + 1] = Math.random() * 30 + 2;
        dustPositions[i * 3 + 2] = (Math.random() - 0.5) * 80;
      }
      dustGeo.setAttribute('position', new THREE.BufferAttribute(dustPositions, 3));
      let dustMat = new THREE.PointsMaterial({ color: 0xffffff, size: 0.15, transparent: true, opacity: 0.3, depthWrite: false });
      let dustParticles = new THREE.Points(dustGeo, dustMat);
      scene.add(dustParticles);
      // Store for update
      window._dustParticles = dustParticles;
      window._dustPositions = dustPositions;

      setupInput();
      // Show correct controls on start screen
      if ('ontouchstart' in window || window.matchMedia('(pointer: coarse)').matches) {
        document.getElementById('start-controls-desktop').style.display = 'none';
        document.getElementById('start-controls-mobile').style.display = 'block';
      }
      document.getElementById('start-btn').addEventListener('click', startGame);
      document.getElementById('phone-dismiss').addEventListener('click', dismissPhone);
      document.getElementById('phone-ui').addEventListener('click', dismissPhone);
      document.getElementById('mobile-help-modal').addEventListener('click', () => {
        document.getElementById('mobile-help-modal').style.display = 'none';
      });
      // Hotbar slot click handlers
      let hotbarSlotEls = document.querySelectorAll('#hotbar .hotbar-slot');
      hotbarSlotEls.forEach((slot, i) => {
        slot.addEventListener('click', () => selectHotbarSlot(i));
      });
      if ('ontouchstart' in window) {
        document.getElementById('mobile-controls').style.display = 'block';
        document.getElementById('pause-btn').innerText = 'Pause';
        setupTouch();
      }

      camera.position.set(0, 50, 50); camera.lookAt(0, 0, 0);
      updateChunks();
      spawnTraffic();

      // Bank Teller NPC - stands behind counter in the bank
      bankTellerNPC = new Pedestrian('CIVILIAN', 72, 70);
      bankTellerNPC.pos.y = 2;
      bankTellerNPC.yaw = Math.PI; // Face toward entrance
      bankTellerNPC.stationary = true;
      peds.push(bankTellerNPC);

      // Store Shopkeeper NPC - stands behind counter in the store
      let shopkeeperNPC = new Pedestrian('CIVILIAN', -73, 26);
      shopkeeperNPC.pos.y = 2;
      shopkeeperNPC.yaw = 0; // Face toward entrance
      shopkeeperNPC.stationary = true;
      shopkeeperNPC.isShopkeeper = true;
      peds.push(shopkeeperNPC);

      requestAnimationFrame(animate);
    }

    function getCameraPos(targetPos, idealPos) {
      let dir = idealPos.clone().sub(targetPos);
      let dist = dir.length(); dir.normalize();
      for (let d = 0.5; d <= dist; d += 0.5) {
        let checkP = targetPos.clone().add(dir.clone().multiplyScalar(d));
        let b = getBlock(checkP.x, checkP.y, checkP.z);
        if (b !== TYPES.EMPTY && b !== TYPES.WATER && b !== TYPES.GLASS && b !== TYPES.GLASS_BLUE && b !== TYPES.GLASS_DARK) {
          return targetPos.clone().add(dir.clone().multiplyScalar(Math.max(0.5, d - 0.8)));
        }
      }
      return idealPos;
    }

    class Projectile {
      constructor(pos, dir, isPlayer, damage = 0) {
        this.pos = pos.clone(); this.isPlayer = isPlayer;
        this.damage = damage || (isPlayer ? 0 : 25); // Default cop damage
        let pSpeed = isPlayer ? player.projSpeed : 100;
        let pSize = isPlayer ? player.projSize : 0.2;
        let pColor = isPlayer ? player.projColor : 0xff4400;
        this.vel = dir.clone().multiplyScalar(pSpeed);
        this.mesh = new THREE.Mesh(new THREE.BoxGeometry(pSize, pSize, 2.5), new THREE.MeshBasicMaterial({ color: pColor }));
        this.mesh.position.copy(this.pos);
        this.mesh.lookAt(this.pos.clone().add(dir));
        scene.add(this.mesh);
        this.life = 1.5;
      }
      update(dt) {
        this.life -= dt;
        // Grenade timer countdown
        if (this.grenadeTimer !== undefined) {
          this.grenadeTimer -= dt;
          // Gravity for grenades
          this.vel.y -= 20 * dt;
          if (this.grenadeTimer <= 0) {
            // Explode with 10-block radius
            let r = 10;
            for (let dx = -r; dx <= r; dx++) for (let dy = -r; dy <= r; dy++) for (let dz = -r; dz <= r; dz++)
              if (dx*dx+dy*dy+dz*dz <= r*r) triggerDestroy(this.pos.x+dx, this.pos.y+dy, this.pos.z+dz, this.vel, true);
            for (let fi = 0; fi < 25; fi++) spawnPhysicsParticle(this.pos.x, this.pos.y, this.pos.z, 'FIRE', this.vel);
            for (let si = 0; si < 12; si++) spawnPhysicsParticle(this.pos.x, this.pos.y+1, this.pos.z, 'SMOKE', null, true);
            for (let v of vehicles) if (v.pos.distanceToSquared(this.pos) < 200 && !(v.type === 'PLANE' && v.parked && v !== currentVehicle)) v.takeDamage(500, true);
            for (let p of peds) if (!p.isDead && p.pos.distanceToSquared(this.pos) < 100) p.takeDamage(200, this.pos, this.vel, true);
            return true; // Remove projectile
          }
        }
        let step = this.vel.clone().multiplyScalar(dt);
        let subSteps = 3, subStep = step.clone().divideScalar(subSteps), hit = false;
        for (let i = 0; i < subSteps; i++) {
          this.pos.add(subStep);
          if (getBlock(this.pos.x, this.pos.y, this.pos.z) !== TYPES.EMPTY && this.pos.y > 0 && getBlock(this.pos.x, this.pos.y, this.pos.z) !== TYPES.WATER) {
            if (this.isPlayer && this.isGrenade) {
              // Grenade hit surface: stop and wait for timer
              this.vel.set(0, 0, 0);
              hit = false; break; // Don't destroy yet, let timer handle it
            } else if (this.isPlayer && this.isRocket) {
              // Rocket: 5-block radius explosion
              for (let dx = -5; dx <= 5; dx++) for (let dy = -5; dy <= 5; dy++) for (let dz = -5; dz <= 5; dz++)
                if (dx*dx+dy*dy+dz*dz <= 25) triggerDestroy(this.pos.x+dx, this.pos.y+dy, this.pos.z+dz, this.vel, true);
              for (let fi = 0; fi < 15; fi++) spawnPhysicsParticle(this.pos.x, this.pos.y, this.pos.z, 'FIRE', this.vel);
              for (let si = 0; si < 8; si++) spawnPhysicsParticle(this.pos.x, this.pos.y+1, this.pos.z, 'SMOKE', null, true);
              // Damage nearby vehicles
              for (let v of vehicles) if (v.pos.distanceToSquared(this.pos) < 100 && !(v.type === 'PLANE' && v.parked && v !== currentVehicle)) v.takeDamage(300, true);
            } else if (this.isPlayer) {
              triggerDestroy(this.pos.x, this.pos.y, this.pos.z, this.vel, true);
            }
            spawnPhysicsParticle(this.pos.x, this.pos.y, this.pos.z, 'CONCRETE', this.vel);
            hit = true; break;
          }
          for (let v of vehicles) {
            if (v !== currentVehicle && !v.isDead && this.pos.distanceToSquared(v.pos) < 12.25) {
              // Don't let stray bullets damage parked planes at the airport
              if (v.type === 'PLANE' && v.parked && v !== currentVehicle) continue;
              let localHit = this.pos.clone().sub(v.pos).applyAxisAngle(_upVec, -v.yaw);
              v.voxelGroup.damageAtLocal(localHit, 1.5, v.mesh.matrixWorld, this.vel);
              v.takeDamage(this.isPlayer ? 100 : 5, this.isPlayer); // Player shreds cops
              hit = true; break;
            }
          }
          if (hit) break;
          if (this.isPlayer) {
            for (let p of peds) {
              if (!p.isDead && this.pos.distanceToSquared(p.pos) < 2.25) {
                p.takeDamage(100, this.pos, this.vel, true); // Player one-shots 
                hit = true; break;
              }
            }
          } else {
            // Cop bullets damage player on foot or in vehicle
            let playerTarget = currentVehicle ? currentVehicle.pos : player.pos;
            let hitRadius = currentVehicle ? 6.25 : 1.44;
            if (this.pos.distanceToSquared(playerTarget) < hitRadius) {
              takeDamage(this.damage);
              if (currentVehicle) currentVehicle.takeDamage(10, false); // Also damage vehicle
              if (playerHealth <= 0) gameOver();
              hit = true; break;
            }
          }
          if (hit) break;
        }
        this.mesh.position.copy(this.pos);
        return hit || this.life <= 0;
      }
      dispose() { scene.remove(this.mesh); }
    }

    class Chunk {
      constructor(cx, cz) {
        this.cx = cx; this.cz = cz; this.key = cx + "," + cz;
        this.group = new THREE.Group(); this.blocks = new Map();
        this.meshesByType = {}; this.typeCounts = {};
        this.generateData(); this.buildMeshes();
        scene.add(this.group);
      }
      generateData() {
        const startX = this.cx * CHUNK_SIZE, startZ = this.cz * CHUNK_SIZE;
        const centerX = startX + CHUNK_SIZE / 2, centerZ = startZ + CHUNK_SIZE / 2;
        const zone = getZone(centerX, centerZ);
        const isBank = (this.cx === 1 && this.cz === 1);
        const isStore = (this.cx === -2 && this.cz === 0);
        const isCarpark = (this.cx === 4 && this.cz === -1);
        const isAlley = (this.cx === -11 && this.cz === 0);
        let h = hash2D(this.cx, this.cz);

        // Material palette per chunk
        let bTypesArr = [TYPES.BRICK, TYPES.BRICK_RED, TYPES.BRICK_BROWN, TYPES.PLASTER_LIGHT, TYPES.PLASTER_WARM, TYPES.CONCRETE, TYPES.CONCRETE_DARK];
        let gTypesArr = [TYPES.GLASS, TYPES.GLASS_BLUE, TYPES.GLASS_DARK];
        let bHash = hash2D(this.cx * 1.5, this.cz * 1.5);
        let wallType = bTypesArr[Math.floor(bHash * 100) % bTypesArr.length];
        let glassType = gTypesArr[Math.floor(bHash * 200) % gTypesArr.length];
        let trimType = bTypesArr[Math.floor(bHash * 300) % bTypesArr.length];

        // Perimeter barrier detection
        let distFromOrigin = Math.sqrt(centerX * centerX + centerZ * centerZ);
        let isPerimeter = (distFromOrigin > 850 && distFromOrigin < 1050 && zone !== 'AIRPORT' && zone !== 'ISLAND');

        // Zone-specific building height
        let buildingHeight = 0;
        if (isPerimeter) { buildingHeight = 40; wallType = TYPES.CONCRETE_DARK; glassType = TYPES.GLASS_DARK; }
        else if (isBank) { buildingHeight = 25; wallType = TYPES.CONCRETE_DARK; glassType = TYPES.GLASS_BLUE; }
        else if (isStore) { buildingHeight = 18; wallType = TYPES.BRICK_RED; glassType = TYPES.GLASS_BLUE; }
        else if (isCarpark) { buildingHeight = 30; wallType = TYPES.CONCRETE; }
        else if (isAlley) { buildingHeight = 0; } // Open alley/safe zone
        else if (zone === 'DOWNTOWN') {
          buildingHeight = 30 + Math.floor(h * 35);
          if (h > 0.7) { wallType = TYPES.GLASS_DARK; glassType = TYPES.GLASS_BLUE; }
          else if (h > 0.4) { wallType = TYPES.CONCRETE_DARK; }
        } else if (zone === 'URBAN') {
          buildingHeight = 12 + Math.floor(h * 20);
        } else if (zone === 'SUBURBAN') {
          let subType = hash2D(this.cx * 13, this.cz * 17);
          if (subType > 0.95) {
            // Mansion ‚Äî tall, large
            buildingHeight = 10 + Math.floor(h * 5);
            wallType = TYPES.PLASTER_LIGHT; glassType = TYPES.GLASS_BLUE;
          } else if (subType > 0.88) {
            // School/Hospital
            buildingHeight = 8 + Math.floor(h * 4);
            wallType = subType > 0.915 ? TYPES.BRICK_RED : TYPES.CONCRETE;
          } else if (subType > 0.78) {
            // Farm ‚Äî low barn
            buildingHeight = h > 0.2 ? 4 + Math.floor(h * 2) : 0;
            wallType = TYPES.WOOD; glassType = TYPES.GLASS;
          } else {
            buildingHeight = h > 0.3 ? 3 + Math.floor(h * 4) : 0;
          }
          let houseColors = [TYPES.PLASTER_LIGHT, TYPES.PLASTER_WARM, TYPES.BRICK_RED, TYPES.BRICK, TYPES.BRICK_BROWN, TYPES.CONCRETE];
          if (subType <= 0.78) wallType = houseColors[Math.floor(h * 100) % houseColors.length];
        } else if (zone === 'RURAL') {
          buildingHeight = h > 0.7 ? 4 + Math.floor(h * 3) : 0; // Sparse farmhouses/barns
          wallType = h > 0.85 ? TYPES.BRICK_RED : TYPES.WOOD;
          glassType = TYPES.GLASS;
        } else if (zone === 'ISLAND') {
          buildingHeight = 5 + Math.floor(h * 15);
        }

        for (let lx = 0; lx < CHUNK_SIZE; lx++) {
          for (let lz = 0; lz < CHUNK_SIZE; lz++) {
            let wx = startX + lx, wz = startZ + lz;
            let biome = getBiome(wx, wz);
            let groundType = biome === 'SNOW' ? TYPES.SNOW : (biome === 'DESERT' ? TYPES.SAND : TYPES.GRASS);
            let subSoilType = biome === 'SNOW' ? TYPES.SNOW : (biome === 'DESERT' ? TYPES.SAND : TYPES.DIRT);
            let noise = smoothNoise(wx * 0.02, wz * 0.02);
            let rxMod = Math.abs(wx) % CHUNK_SIZE, rzMod = Math.abs(wz) % CHUNK_SIZE;
            let isXRoad = rxMod < ROAD_WIDTH, isZRoad = rzMod < ROAD_WIDTH;
            let isRoad = isXRoad || isZRoad;
            let isSidewalk = !isRoad && ((rxMod >= ROAD_WIDTH && rxMod < ROAD_WIDTH + 2) || (rxMod > CHUNK_SIZE - 2) ||
                                          (rzMod >= ROAD_WIDTH && rzMod < ROAD_WIDTH + 2) || (rzMod > CHUNK_SIZE - 2));
            let isIntersection = isXRoad && isZRoad;

            // Water determination by zone
            let isWater = false;
            if (zone === 'OCEAN') {
              if (isPerimeter) {
                // Perimeter barrier: solid concrete wall instead of water
                this.setBlock(lx, 0, lz, TYPES.CONCRETE_DARK);
                for (let py = 1; py <= 40; py++) this.setBlock(lx, py, lz, TYPES.CONCRETE_DARK);
                continue; // Skip all other generation for this block
              }
              isWater = true;
            } else if (zone === 'ISLAND') {
              let idDist = Math.sqrt((wx - ISLAND_X) * (wx - ISLAND_X) + (wz - ISLAND_Z) * (wz - ISLAND_Z));
              // Bridge from island to mainland (goes east, z = ISLAND_Z, from x = ISLAND_X+60 to ISLAND_X+200)
              let onBridge = Math.abs(wz - ISLAND_Z) < 4 && wx > ISLAND_X + 50 && wx < ISLAND_X + 250;
              if (onBridge) {
                isWater = false;
              } else {
                // More water - smaller island land area
                isWater = idDist > 55 || (idDist > 45 && noise < 0.55);
              }
              // Island runway (along x-axis through south side)
              let islandRunway = Math.abs(wz - ISLAND_Z) < 4 && wx > ISLAND_X - 45 && wx < ISLAND_X + 45 && idDist < 50;
              // Castle/Mansion - much larger (30x24), positioned in center-north of island
              let castleX = ISLAND_X - 15, castleZ = ISLAND_Z + 12;
              let cxOff = wx - castleX, czOff = wz - castleZ;
              let isCastle = cxOff >= 0 && cxOff <= 30 && czOff >= 0 && czOff <= 24 && idDist < 50;
              let isCastleWall = isCastle && (cxOff === 0 || cxOff === 30 || czOff === 0 || czOff === 24);
              let isCastleDoor = isCastle && czOff === 0 && cxOff >= 13 && cxOff <= 17;
              // Corner towers
              let isCornerTower = isCastle && ((cxOff <= 3 || cxOff >= 27) && (czOff <= 3 || czOff >= 21));
              // Island mountain - northeast area of island
              let mtX = ISLAND_X + 25, mtZ = ISLAND_Z - 20;
              let mtIslandDist = Math.sqrt((wx - mtX) * (wx - mtX) + (wz - mtZ) * (wz - mtZ));
              let isIslandMt = mtIslandDist < 18 && idDist < 50;
              // Fountain/courtyard in front of castle
              let fxOff = wx - (ISLAND_X), fzOff = wz - (ISLAND_Z + 8);
              let fountainDist = Math.sqrt(fxOff * fxOff + fzOff * fzOff);

              if (!isWater && islandRunway) {
                this.setBlock(lx, 0, lz, TYPES.ROAD);
                if (Math.abs(wz - ISLAND_Z) < 1 && Math.abs(wx - ISLAND_X) % 10 < 5) this.setBlock(lx, 0, lz, TYPES.CONCRETE);
                continue;
              } else if (!isWater && isIslandMt) {
                // Island mountain
                let mtH = Math.floor((1 - mtIslandDist / 18) * 30);
                this.setBlock(lx, 0, lz, TYPES.GRASS);
                for (let my = 1; my <= mtH; my++) {
                  if (my === mtH && mtH > 20) this.setBlock(lx, my, lz, TYPES.SNOW);
                  else if (my === mtH) this.setBlock(lx, my, lz, TYPES.GRASS);
                  else if (my > mtH - 3) this.setBlock(lx, my, lz, TYPES.STONE);
                  else this.setBlock(lx, my, lz, TYPES.DIRT);
                }
                continue;
              } else if (!isWater && isCastle) {
                // Castle floor
                this.setBlock(lx, 0, lz, TYPES.GOLD);
                let wallH = isCornerTower ? 16 : 12;
                for (let my = 1; my <= wallH; my++) {
                  if (isCastleDoor && my <= 5) continue;
                  if (isCornerTower) {
                    this.setBlock(lx, my, lz, my > wallH - 2 ? TYPES.CONCRETE_DARK : TYPES.STONE);
                  } else if (isCastleWall) {
                    let isWin = my >= 4 && my <= 6 && ((cxOff % 4 === 0) || (czOff % 4 === 0));
                    this.setBlock(lx, my, lz, isWin ? TYPES.GLASS_BLUE : TYPES.STONE);
                  } else if (my === 1) {
                    this.setBlock(lx, my, lz, TYPES.GOLD); // gold floor
                  } else if (my === 6) {
                    this.setBlock(lx, my, lz, TYPES.WOOD); // second floor
                  }
                }
                // Crenellations (battlement pattern on top)
                if (isCastleWall && !isCornerTower) {
                  let crenelPos = (cxOff + czOff) % 3;
                  if (crenelPos === 0) this.setBlock(lx, wallH + 1, lz, TYPES.STONE);
                }
                // Tower peaked caps
                if (isCornerTower) {
                  this.setBlock(lx, wallH + 1, lz, TYPES.STONE);
                  let tCenterX = cxOff <= 3 ? 1.5 : 28.5;
                  let tCenterZ = czOff <= 3 ? 1.5 : 22.5;
                  let tDist = Math.abs(cxOff - tCenterX) + Math.abs(czOff - tCenterZ);
                  if (tDist <= 1) {
                    this.setBlock(lx, wallH + 2, lz, TYPES.BRICK_RED);
                    this.setBlock(lx, wallH + 3, lz, TYPES.BRICK_RED);
                  }
                }
                // Interior: throne room, furniture
                if (!isCastleWall && !isCornerTower) {
                  // Throne at back of castle
                  if (czOff >= 20 && czOff <= 22 && cxOff >= 14 && cxOff <= 16) {
                    this.setBlock(lx, 2, lz, TYPES.GOLD);
                    this.setBlock(lx, 3, lz, TYPES.GOLD);
                    if (cxOff === 15) this.setBlock(lx, 4, lz, TYPES.GOLD);
                  }
                  // Red carpet to throne
                  if (cxOff === 15 && czOff > 0 && czOff < 20) {
                    this.setBlock(lx, 1, lz, TYPES.RED);
                  }
                }
                this.setBlock(lx, wallH, lz, isCastleWall ? TYPES.STONE : TYPES.CONCRETE); // roof
                continue;
              } else if (!isWater && fountainDist < 5) {
                this.setBlock(lx, 0, lz, TYPES.GRASS);
                if (fountainDist > 3) this.setBlock(lx, 1, lz, TYPES.CONCRETE);
                else if (fountainDist > 1) this.setBlock(lx, 1, lz, TYPES.WATER);
                else { this.setBlock(lx, 1, lz, TYPES.CONCRETE); this.setBlock(lx, 2, lz, TYPES.CONCRETE); this.setBlock(lx, 3, lz, TYPES.WATER); }
                continue;
              } else if (onBridge) {
                this.setBlock(lx, 0, lz, TYPES.ROAD);
                if (Math.abs(wz - ISLAND_Z) >= 3) { this.setBlock(lx, 1, lz, TYPES.STEEL); this.setBlock(lx, 2, lz, TYPES.STEEL); }
                // Bridge supports
                if (wx % 20 === 0 && Math.abs(wz - ISLAND_Z) >= 3) {
                  for (let by = -2; by <= 0; by++) this.setBlock(lx, by, lz, TYPES.CONCRETE);
                }
                continue;
              }
            } else if (zone === 'AIRPORT' || isCarpark) {
              isWater = false;
            } else {
              // River through city (sinusoidal path, north-south)
              let riverCenter = Math.sin(wz * 0.006) * 90 + 120;
              let riverDist = Math.abs(wx - riverCenter);
              if (riverDist < 12) isWater = true;
              // Second river (east-west)
              let river2Center = Math.sin(wx * 0.005) * 80 - 100;
              let river2Dist = Math.abs(wz - river2Center);
              if (river2Dist < 10) isWater = true;
              // Zone-based water threshold
              let waterThreshold = zone === 'DOWNTOWN' ? 0.07 : (zone === 'URBAN' ? 0.14 : (zone === 'SUBURBAN' ? 0.20 : 0.30));
              if (noise < waterThreshold) isWater = true;
            }

            if (isWater) {
              for (let wy = -2; wy <= 0; wy++) this.setBlock(lx, wy, lz, TYPES.WATER);
              this.setBlock(lx, -3, lz, TYPES.DIRT);
              if (isRoad && zone !== 'OCEAN') {
                // Bridge deck
                this.setBlock(lx, 1, lz, TYPES.ROAD);
                // Bridge railings
                let rpx = Math.abs(wx) % CHUNK_SIZE, rpz = Math.abs(wz) % CHUNK_SIZE;
                let isEdge = rpx === 0 || rpx === ROAD_WIDTH - 1 || rpz === 0 || rpz === ROAD_WIDTH - 1;
                if (isEdge) {
                  this.setBlock(lx, 2, lz, TYPES.STEEL);
                  if (wx % 4 === 0 || wz % 4 === 0) this.setBlock(lx, 3, lz, TYPES.STEEL);
                }
                // Bridge support pillars
                if (wx % 12 === 0 && isEdge) {
                  for (let by = -2; by <= 1; by++) this.setBlock(lx, by, lz, TYPES.CONCRETE);
                }
              }
            } else if (zone === 'AIRPORT') {
              // Airport generation
              let apDist = Math.sqrt((wx - AIRPORT_X) * (wx - AIRPORT_X) + (wz - AIRPORT_Z) * (wz - AIRPORT_Z));
              let runwayDist = Math.abs(wz - AIRPORT_Z);
              let inRunwayLen = wx > AIRPORT_X - 90 && wx < AIRPORT_X + 90;
              // Perimeter fence/wall
              let isApFence = apDist > 118 && apDist < 122;
              let isApGate = Math.abs(wz - AIRPORT_Z) < 8 && wx < AIRPORT_X - 85;
              if (isApFence && !isApGate && !isRoad) {
                this.setBlock(lx, 0, lz, TYPES.CONCRETE);
                for (let fy = 1; fy <= 6; fy++) this.setBlock(lx, fy, lz, TYPES.STEEL);
                // Signs on walls facing each direction
                if (Math.abs(wx - AIRPORT_X) < 2 && wz < AIRPORT_Z) {
                  for (let sy = 7; sy <= 9; sy++) this.setBlock(lx, sy, lz, TYPES.WHITE);
                }
                if (Math.abs(wx - AIRPORT_X) < 2 && wz > AIRPORT_Z + 20) {
                  for (let sy = 7; sy <= 9; sy++) this.setBlock(lx, sy, lz, TYPES.WHITE);
                }
                if (Math.abs(wz - AIRPORT_Z) < 2 && wx < AIRPORT_X - 50) {
                  for (let sy = 7; sy <= 9; sy++) this.setBlock(lx, sy, lz, TYPES.WHITE);
                }
                if (Math.abs(wz - AIRPORT_Z) < 2 && wx > AIRPORT_X + 50) {
                  for (let sy = 7; sy <= 9; sy++) this.setBlock(lx, sy, lz, TYPES.WHITE);
                }
              } else if (runwayDist < 5 && inRunwayLen) {
                this.setBlock(lx, 0, lz, TYPES.ROAD);
                if (runwayDist < 1 && Math.abs(wx - AIRPORT_X) % 15 < 8) this.setBlock(lx, 0, lz, TYPES.CONCRETE);
              } else if (wx > AIRPORT_X - 20 && wx < AIRPORT_X + 20 && wz > AIRPORT_Z + 15 && wz < AIRPORT_Z + 38) {
                // Terminal building
                let tw = wx - (AIRPORT_X - 20), td = wz - (AIRPORT_Z + 15);
                let isTermWall = tw === 0 || tw === 39 || td === 0 || td === 22;
                let isTermDoor = td === 0 && tw > 16 && tw < 24;
                this.setBlock(lx, 0, lz, TYPES.CONCRETE);
                for (let y = 1; y <= 10; y++) {
                  if (isTermDoor && y <= 3) continue;
                  if (isTermWall) {
                    this.setBlock(lx, y, lz, y > 6 ? TYPES.GLASS_BLUE : TYPES.CONCRETE);
                  } else if (y === 1 || y === 6) {
                    this.setBlock(lx, y, lz, TYPES.CONCRETE);
                  }
                }
                this.setBlock(lx, 11, lz, TYPES.CONCRETE);
              } else if (Math.abs(wz - (AIRPORT_Z + 9)) < 3 && inRunwayLen) {
                this.setBlock(lx, 0, lz, TYPES.ROAD); // Taxiway
              } else if (isRoad) {
                this.setBlock(lx, 0, lz, TYPES.ROAD);
              } else {
                this.setBlock(lx, 0, lz, TYPES.CONCRETE);
                // Helipad near terminal
                let hpDist = Math.sqrt((wx - (AIRPORT_X + 40)) * (wx - (AIRPORT_X + 40)) + (wz - (AIRPORT_Z + 25)) * (wz - (AIRPORT_Z + 25)));
                if (hpDist < 8) {
                  this.setBlock(lx, 0, lz, TYPES.YELLOW);
                  if (hpDist > 5 && hpDist < 7) this.setBlock(lx, 0, lz, TYPES.WHITE);
                }
              }
            } else if (isRoad) {
              this.setBlock(lx, 0, lz, TYPES.ROAD);
              // Traffic lights - one per intersection (only one corner)
              if (isIntersection && zone !== 'RURAL' && zone !== 'OCEAN' && zone !== 'SUBURBAN') {
                if (rxMod === ROAD_WIDTH - 1 && rzMod === ROAD_WIDTH - 1) {
                  for (let ty = 1; ty <= 5; ty++) this.setBlock(lx, ty, lz, TYPES.STEEL);
                  this.setBlock(lx, 6, lz, TYPES.RED);
                  this.setBlock(lx, 7, lz, TYPES.YELLOW);
                  this.setBlock(lx, 8, lz, TYPES.GREEN);
                }
              }
              // Road ramps/jumps for fun driving (not on intersections, not near special buildings)
              if (!isIntersection && !isBank && !isStore && !isCarpark && !isAlley && zone !== 'OCEAN') {
                let rampHash = hash2D(Math.floor(wx / 48) * 100, Math.floor(wz / 48) * 100);
                // ~15% of road chunks get a ramp on one road
                if (rampHash > 0.85) {
                  let isXOnly = isXRoad && !isZRoad;
                  let isZOnly = isZRoad && !isXRoad;
                  // Ramp along X roads (player drives along Z), placed mid-chunk
                  if (isXOnly && rzMod >= 20 && rzMod <= 24) {
                    let rampLocal = rzMod - 20;
                    let rampY = rampLocal <= 2 ? rampLocal : (4 - rampLocal);
                    if (rampY > 0) this.setBlock(lx, rampY, lz, TYPES.CONCRETE);
                  }
                  // Ramp along Z roads (player drives along X), placed mid-chunk
                  if (isZOnly && rxMod >= 20 && rxMod <= 24) {
                    let rampLocal = rxMod - 20;
                    let rampY = rampLocal <= 2 ? rampLocal : (4 - rampLocal);
                    if (rampY > 0) this.setBlock(lx, rampY, lz, TYPES.CONCRETE);
                  }
                }
              }
            } else {
              // Standard terrain
              // More green spaces - lower thresholds mean more parks/gardens
              let isPark = !isCarpark && ((zone === 'RURAL' && noise > 0.25) || (zone === 'SUBURBAN' && noise > 0.45) || (zone === 'URBAN' && noise > 0.55) || (zone === 'DOWNTOWN' && noise > 0.68) || (zone === 'ISLAND' && noise > 0.45));
              // Mountain biome: always nature ground, no sidewalks/concrete
              if (biome === 'MOUNTAIN') isPark = true;
              if (isSidewalk && !isPark) {
                this.setBlock(lx, 0, lz, TYPES.SIDEWALK);
              } else {
                this.setBlock(lx, 0, lz, isPark ? groundType : TYPES.CONCRETE);
                // === CUL-DE-SAC SAFE HOUSE ===
                if (isAlley && !isRoad) {
                  let culCX = 24, culHW = 3, culSZ = ROAD_WIDTH, culEZ = 38;
                  let isCulRoad = (lx >= culCX - culHW && lx <= culCX + culHW && lz >= culSZ && lz <= culEZ);
                  let turnDist = Math.sqrt((lx - culCX) * (lx - culCX) + (lz - culEZ) * (lz - culEZ));
                  let isTurn = (turnDist <= 6 && lz >= culEZ - 2);
                  if (isCulRoad || isTurn) {
                    let isEdge = isCulRoad && (lx === culCX - culHW || lx === culCX + culHW);
                    let isTurnEdge = isTurn && turnDist >= 5;
                    this.setBlock(lx, 0, lz, (isEdge || isTurnEdge) ? TYPES.SIDEWALK : TYPES.ROAD);
                  } else {
                    this.setBlock(lx, 0, lz, TYPES.GRASS);
                    // Safe house at end of cul-de-sac
                    let isSH = (lx >= 19 && lx <= 29 && lz >= 40 && lz <= 46);
                    let isSHW = isSH && (lx === 19 || lx === 29 || lz === 40 || lz === 46);
                    let isSHD = (lz === 40 && lx >= 23 && lx <= 25);
                    if (isSH) {
                      this.setBlock(lx, 0, lz, TYPES.GREEN);
                      for (let sy = 1; sy <= 5; sy++) {
                        if (isSHD && sy <= 3) continue;
                        if (isSHW) this.setBlock(lx, sy, lz, TYPES.PLASTER_WARM);
                        else if (sy === 1) this.setBlock(lx, sy, lz, TYPES.WOOD);
                      }
                      let dfc = Math.abs(lx - 24), rH = 8 - dfc;
                      if (rH > 5) { for (let ry = 6; ry <= rH; ry++) this.setBlock(lx, ry, lz, TYPES.BRICK_BROWN); }
                    }
                    // Neighboring houses
                    let houses = [
                      [5, 14, culSZ + 2, culSZ + 10, culSZ + 2, TYPES.PLASTER_LIGHT, 5],
                      [5, 14, culSZ + 14, culSZ + 22, culSZ + 14, TYPES.BRICK_RED, 4],
                      [34, 43, culSZ + 2, culSZ + 10, culSZ + 2, TYPES.BRICK, 5],
                      [34, 43, culSZ + 14, culSZ + 22, culSZ + 14, TYPES.PLASTER_WARM, 4]
                    ];
                    for (let hd of houses) {
                      let [x1,x2,z1,z2,dz,wt,hh] = hd;
                      if (lx >= x1 && lx <= x2 && lz >= z1 && lz <= z2) {
                        let isW = (lx === x1 || lx === x2 || lz === z1 || lz === z2);
                        let mhx = Math.floor((x1 + x2) / 2);
                        let isDr = (lz === dz && lx >= mhx - 1 && lx <= mhx + 1);
                        for (let hy = 1; hy <= hh; hy++) {
                          if (isDr && hy <= 3) continue;
                          let isWin = (isW && hy === 2 && (lx % 3 === 0 || lz % 3 === 0) && !isDr);
                          if (isW) this.setBlock(lx, hy, lz, isWin ? TYPES.GLASS : wt);
                          else if (hy === 1) this.setBlock(lx, hy, lz, TYPES.WOOD);
                        }
                        let rC = Math.floor((x1 + x2) / 2), dfcH = Math.abs(lx - rC);
                        let rHH = hh + 3 - dfcH;
                        if (rHH > hh) { for (let ry = hh + 1; ry <= rHH; ry++) this.setBlock(lx, ry, lz, TYPES.BRICK_BROWN); }
                      }
                    }
                    // Fences along cul-de-sac road
                    let nearCul = (lx === culCX - culHW - 2 || lx === culCX + culHW + 2);
                    if (nearCul && lz >= culSZ && lz <= culEZ && lz % 2 === 0) this.setBlock(lx, 1, lz, TYPES.WOOD);
                  }
                }
              }

              let margin = ROAD_WIDTH + 1;
              let canBuild = (Math.abs(wx) % CHUNK_SIZE >= margin) && (Math.abs(wx) % CHUNK_SIZE <= CHUNK_SIZE - margin) &&
                             (Math.abs(wz) % CHUNK_SIZE >= margin) && (Math.abs(wz) % CHUNK_SIZE <= CHUNK_SIZE - margin);
              // Carpark uses expanded footprint ‚Äî override canBuild
              if (isCarpark) canBuild = !isRoad;

              if (canBuild && buildingHeight > 0 && !isPark && biome !== 'MOUNTAIN') {
                // Building footprint - smaller for suburban
                let xOffset = Math.floor((hash2D(this.cx, 1) % 1) * 3), zOffset = Math.floor((hash2D(1, this.cz) % 1) * 3);
                let wShrink = Math.floor((hash2D(this.cx, 2) % 1) * 4), dShrink = Math.floor((hash2D(2, this.cz) % 1) * 4);
                let maxFootprint = CHUNK_SIZE - margin * 2;
                if (zone === 'SUBURBAN') {
                  // Smaller houses with yards
                  wShrink += 8; dShrink += 8;
                }
                let bWidth = Math.max(8, maxFootprint - xOffset - wShrink);
                let bDepth = Math.max(8, maxFootprint - zOffset - dShrink);
                let bStartX = margin + xOffset, bStartZ = margin + zOffset;

                // Downtown setback height (narrower at top)
                let setbackH = (zone === 'DOWNTOWN' && buildingHeight > 40) ? Math.floor(buildingHeight * 0.55) : buildingHeight;

                // Special buildings: bank gets larger footprint
                if (isBank) { bWidth = maxFootprint; bDepth = maxFootprint; bStartX = margin; bStartZ = margin; }
                if (isStore) { bWidth = Math.min(20, maxFootprint); bDepth = Math.min(16, maxFootprint); }
                if (isCarpark) { bStartX = ROAD_WIDTH; bStartZ = ROAD_WIDTH; bWidth = CHUNK_SIZE - ROAD_WIDTH * 2; bDepth = CHUNK_SIZE - ROAD_WIDTH * 2; }

                if (lx >= bStartX && lx < bStartX + bWidth && lz >= bStartZ && lz < bStartZ + bDepth) {
                  let isWall = (lx === bStartX || lx === bStartX + bWidth - 1) || (lz === bStartZ || lz === bStartZ + bDepth - 1);
                  let midX = Math.floor(bStartX + bWidth / 2);
                  let midZ = Math.floor(bStartZ + bDepth / 2);

                  for (let y = 1; y <= buildingHeight; y++) {
                    // Setback logic for downtown towers
                    let effectiveWall = isWall;
                    if (y > setbackH && zone === 'DOWNTOWN' && !isBank && !isStore && !isCarpark) {
                      let shrink = Math.floor((y - setbackH) / 4) + 2;
                      if (lx < bStartX + shrink || lx >= bStartX + bWidth - shrink || lz < bStartZ + shrink || lz >= bStartZ + bDepth - shrink) continue;
                      effectiveWall = (lx === bStartX + shrink || lx === bStartX + bWidth - shrink - 1) || (lz === bStartZ + shrink || lz === bStartZ + bDepth - shrink - 1);
                    }

                    let isFloor = (y % 5 === 1);
                    let isFrontDoor = (y <= 5 && lz === bStartZ && lx >= midX - 2 && lx <= midX + 2);
                    let isBackDoor = (y <= 5 && lz === bStartZ + bDepth - 1 && lx >= midX - 2 && lx <= midX + 2);
                    let isDoor = isFrontDoor || isBackDoor;
                    // Door frame outline (gold for bank, green for store)
                    let isDoorFrame = false;
                    if (y <= 6 && (lz === bStartZ || lz === bStartZ + bDepth - 1)) {
                      let atEdge = (lx === midX - 3 || lx === midX + 3) && y <= 5;
                      let atTop = (y === 6) && lx >= midX - 2 && lx <= midX + 2;
                      if (atEdge || atTop) isDoorFrame = true;
                    }
                    if (isDoorFrame && (isBank || isStore)) {
                      this.setBlock(lx, y, lz, isBank ? TYPES.GOLD : TYPES.GREEN);
                      continue;
                    }
                    let isWindow = (effectiveWall && (y % 5 === 2 || y % 5 === 3) && ((lx % 4 === 0) || (lz % 4 === 0)) && !isDoor);
                    if (isDoor) continue;

                    let bType = wallType;

                    // === BANK INTERIOR ===
                    if (isBank) {
                      if (effectiveWall) {
                        if (y <= 3) this.setBlock(lx, y, lz, TYPES.CONCRETE_DARK); // Stone base
                        else if (isWindow) this.setBlock(lx, y, lz, TYPES.GLASS_BLUE);
                        else if (y === buildingHeight) this.setBlock(lx, y, lz, TYPES.CONCRETE_DARK);
                        else this.setBlock(lx, y, lz, TYPES.CONCRETE_DARK);
                      } else if (y === 1) {
                        this.setBlock(lx, y, lz, TYPES.WOOD); // Wood floor
                      } else if (y === 2) {
                        // L-shaped teller counter
                        let counterZ = bStartZ + 8;
                        let counterZside = bStartZ + 5;
                        if ((lz === counterZ && lx >= midX - 6 && lx <= midX + 6) ||
                            (lz >= counterZside && lz <= counterZ && (lx === midX - 6 || lx === midX + 6))) {
                          this.setBlock(lx, y, lz, TYPES.WOOD);
                        }
                        // Benches in waiting area
                        if (lz === bStartZ + 3 && (lx === midX - 3 || lx === midX + 3 || lx === midX)) {
                          this.setBlock(lx, y, lz, TYPES.WOOD);
                        }
                        // Velvet rope barriers (red blocks)
                        if (lz === bStartZ + 5 && lx >= midX - 4 && lx <= midX + 4 && lx !== midX) {
                          this.setBlock(lx, y, lz, TYPES.RED);
                        }
                      }
                      // Vault room at back
                      if (lx >= midX - 4 && lx <= midX + 4 && lz >= bStartZ + bDepth - 8 && lz <= bStartZ + bDepth - 2 && y <= 6) {
                        let isVW = (lx === midX - 4 || lx === midX + 4 || lz === bStartZ + bDepth - 8 || lz === bStartZ + bDepth - 2 || y === 6);
                        let isVD = (lz === bStartZ + bDepth - 8 && lx >= midX - 1 && lx <= midX + 1 && y <= 3);
                        if (isVW && !isVD) this.setBlock(lx, y, lz, TYPES.STEEL);
                        else if (!isVW && y === 2 && Math.random() > 0.5) this.setBlock(lx, y, lz, TYPES.GOLD);
                      }
                      continue;
                    }

                    // === STORE INTERIOR ===
                    if (isStore) {
                      if (effectiveWall) {
                        // Large glass front wall, brick sides
                        if (lz === bStartZ && y <= 8) this.setBlock(lx, y, lz, TYPES.GLASS_BLUE);
                        else this.setBlock(lx, y, lz, isWindow ? TYPES.GLASS_BLUE : TYPES.BRICK_RED);
                      } else if (y === 1) {
                        this.setBlock(lx, y, lz, TYPES.WOOD);
                      } else if (y === 2) {
                        // Display shelves along side walls
                        if ((lx === bStartX + 1 || lx === bStartX + bWidth - 2) && lz > bStartZ + 2 && lz < bStartZ + bDepth - 2) {
                          this.setBlock(lx, y, lz, TYPES.WOOD);
                        }
                        // Counter at back of store (shopkeeper stands behind this)
                        if (lz === bStartZ + bDepth - 4 && lx >= midX - 4 && lx <= midX + 4) {
                          this.setBlock(lx, y, lz, TYPES.STEEL);
                        }
                        // Center display tables
                        if (lz === midZ && (lx === midX - 2 || lx === midX + 2)) {
                          this.setBlock(lx, y, lz, TYPES.WOOD);
                        }
                      }
                      continue;
                    }

                    // === CARPARK ===
                    if (isCarpark) {
                      let floorLevels = [1, 6, 11, 16, 21, 26];
                      let isFloorSlab = floorLevels.includes(y);
                      let relX = lx - bStartX, relZ = lz - bStartZ;
                      // Pillars: grid of support columns every 4 blocks
                      let isPillar = (relX % 4 === 0 && relZ % 4 === 0);
                      // Outer walls: half-height barriers on each floor edge (open-air design)
                      let isOuterEdge = (lx === bStartX || lx === bStartX + bWidth - 1 || lz === bStartZ || lz === bStartZ + bDepth - 1);
                      let floorNum = Math.floor((y - 1) / 5);
                      let localY = (y - 1) % 5;
                      // Ramp: wider ramp in back-right corner, goes up 5 blocks over depth
                      let rampX1 = bStartX + bWidth - 6, rampX2 = bStartX + bWidth - 2;
                      let rampZ1 = bStartZ + 1, rampZ2 = bStartZ + bDepth - 2;
                      let inRamp = (lx >= rampX1 && lx <= rampX2 && lz >= rampZ1 && lz <= rampZ2);
                      let placed = false;
                      if (isPillar) {
                        this.setBlock(lx, y, lz, TYPES.STEEL); placed = true;
                      } else if (isOuterEdge) {
                        // Half-walls: only first 2 blocks above each floor level
                        if (localY === 0 || localY === 1) {
                          this.setBlock(lx, y, lz, TYPES.CONCRETE); placed = true;
                        }
                        // Yellow stripe at floor level
                        if (localY === 0 && y > 1) {
                          this.setBlock(lx, y, lz, TYPES.YELLOW); placed = true;
                        }
                      } else if (isFloorSlab && !inRamp) {
                        this.setBlock(lx, y, lz, TYPES.CONCRETE); placed = true;
                      } else if (y === buildingHeight) {
                        // Roof slab
                        this.setBlock(lx, y, lz, TYPES.CONCRETE); placed = true;
                      } else if (inRamp) {
                        // Ramp: gradual slope going up within each floor
                        let rampProgress = (lz - rampZ1) / (rampZ2 - rampZ1);
                        let baseFloor = floorLevels[floorNum] || 1;
                        let nextFloor = floorLevels[floorNum + 1] || (baseFloor + 5);
                        let rampBlockY = baseFloor + Math.floor(rampProgress * (nextFloor - baseFloor));
                        if (y === rampBlockY) {
                          this.setBlock(lx, y, lz, TYPES.CONCRETE); placed = true;
                        }
                      }
                      if (placed) carparkTotalBlocks++;
                      continue;
                    }

                    // Standard building shell
                    if (effectiveWall) {
                      if (y === buildingHeight || (y % 5 === 1 && y > 1)) {
                        this.setBlock(lx, y, lz, trimType);
                        if (y === buildingHeight) this.setBlock(lx, y + 1, lz, trimType);
                      } else {
                        this.setBlock(lx, y, lz, isWindow ? glassType : bType);
                      }
                    } else if (isFloor) {
                      // Alternating staircase positions per floor
                      let floorNum = Math.floor((y - 1) / 5);
                      let stairW = 4, stairD = 6, holeW = 5, holeD = 7;
                      let sx, sz;
                      if (floorNum % 2 === 0) {
                        sx = bStartX + 2; sz = bStartZ + 2;
                      } else {
                        sx = bStartX + bWidth - 2 - stairW; sz = bStartZ + bDepth - 2 - stairD;
                      }
                      let inHole = (lx >= sx - 1 && lx < sx + holeW && lz >= sz - 1 && lz < sz + holeD);
                      if (!inHole) this.setBlock(lx, y, lz, TYPES.WOOD);
                      // Interior furniture ‚Äî desks/tables
                      if (!inHole && lx % 7 === 0 && lz % 7 === 0 && lx > bStartX + 2 && lx < bStartX + bWidth - 2 && lz > bStartZ + 2 && lz < bStartZ + bDepth - 2) {
                        this.setBlock(lx, y + 1, lz, TYPES.WOOD);
                      }
                    } else {
                      // Alternating staircase ‚Äî goes up 1 block per Z step
                      let floorNum = Math.floor((y - 1) / 5);
                      let stairW = 4, stairD = 6;
                      let sx, sz;
                      if (floorNum % 2 === 0) {
                        sx = bStartX + 2; sz = bStartZ + 2;
                      } else {
                        sx = bStartX + bWidth - 2 - stairW; sz = bStartZ + bDepth - 2 - stairD;
                      }
                      if (lx >= sx && lx < sx + stairW && lz >= sz && lz < sz + stairD) {
                        let localY = (y - 1) % 5;
                        let stepZ;
                        if (floorNum % 2 === 0) {
                          stepZ = localY; // stairs go up along +Z
                        } else {
                          stepZ = stairD - 1 - localY; // stairs go up along -Z
                        }
                        if (lz - sz === stepZ) this.setBlock(lx, y, lz, TYPES.STEEL);
                        else if (lz - sz < stepZ && floorNum % 2 === 0) this.setBlock(lx, y, lz, TYPES.STEEL);
                        else if (lz - sz > stepZ && floorNum % 2 !== 0) this.setBlock(lx, y, lz, TYPES.STEEL);
                      }
                    }
                  }
                  // Suburban peaked roofs + front porches
                  if (zone === 'SUBURBAN' && !isBank && !isStore && !isCarpark && buildingHeight > 0) {
                    let roofPeak = buildingHeight + Math.floor(Math.min(bWidth, bDepth) / 3) + 1;
                    let isLongX = bWidth >= bDepth;
                    if (isLongX) {
                      let centerZ = Math.floor(bStartZ + bDepth / 2);
                      let dfc = Math.abs(lz - centerZ);
                      let maxD = Math.max(1, Math.floor(bDepth / 2));
                      let roofH = roofPeak - Math.floor((dfc / maxD) * (roofPeak - buildingHeight));
                      for (let ry = buildingHeight + 1; ry <= roofH; ry++) this.setBlock(lx, ry, lz, TYPES.BRICK_BROWN);
                    } else {
                      let centerX = Math.floor(bStartX + bWidth / 2);
                      let dfc = Math.abs(lx - centerX);
                      let maxD = Math.max(1, Math.floor(bWidth / 2));
                      let roofH = roofPeak - Math.floor((dfc / maxD) * (roofPeak - buildingHeight));
                      for (let ry = buildingHeight + 1; ry <= roofH; ry++) this.setBlock(lx, ry, lz, TYPES.BRICK_BROWN);
                    }
                    // Porch overhang at front door
                    if (lz >= bStartZ - 2 && lz < bStartZ && lx >= midX - 3 && lx <= midX + 3) {
                      this.setBlock(lx, buildingHeight, lz, TYPES.WOOD);
                      if ((lx === midX - 3 || lx === midX + 3) && lz === bStartZ - 2) {
                        for (let py = 1; py < buildingHeight; py++) this.setBlock(lx, py, lz, TYPES.WOOD);
                      }
                    }
                  }
                } else {
                  // Street furniture (lamp posts) - on sidewalk, not road
                  if (lx === margin && lz % 16 === 0 && zone !== 'SUBURBAN') {
                    for (let y = 1; y <= 5; y++) this.setBlock(lx, y, lz, TYPES.STEEL);
                    this.setBlock(lx, 6, lz, TYPES.LIGHT);
                  }
                  // Suburban yards - grass front yards with fences, trees, gardens, hills
                  if (zone === 'SUBURBAN' && !isSidewalk) {
                    // Suburban terrain hills (gentle rolling)
                    let subHill = Math.floor(smoothNoise(wx * 0.04, wz * 0.04) * 4);
                    let subHill2 = Math.floor(smoothNoise(wx * 0.08 + 30, wz * 0.08 + 30) * 2);
                    subHill = Math.max(0, subHill + subHill2);
                    for (let hy = 0; hy <= subHill; hy++) this.setBlock(lx, hy, lz, hy === subHill ? groundType : subSoilType);
                    if (subHill === 0) this.setBlock(lx, 0, lz, groundType);

                    let subType = hash2D(this.cx * 13, this.cz * 17);
                    // Front yard fence along sidewalk edge
                    let nearSidewalk = (rxMod === ROAD_WIDTH + 2 || rxMod === CHUNK_SIZE - 3 || rzMod === ROAD_WIDTH + 2 || rzMod === CHUNK_SIZE - 3);
                    if (nearSidewalk && hash2D(wx * 7, wz * 7) > 0.4) {
                      this.setBlock(lx, subHill + 1, lz, TYPES.WOOD);
                    }

                    // Farm chunks: crops, hay bales, silos
                    if (subType > 0.78 && subType <= 0.88) {
                      // Crop rows
                      if (lx > margin + 2 && lx < CHUNK_SIZE - margin - 2 && lz > margin + 2 && lz < CHUNK_SIZE - margin - 2) {
                        if (lx % 2 === 0 && hash2D(wx + 20, wz + 20) > 0.3) {
                          this.setBlock(lx, subHill + 1, lz, TYPES.LEAVES); // crops
                        }
                        // Hay bales
                        if (hash2D(wx * 5 + 1, wz * 5 + 1) > 0.995) {
                          this.setBlock(lx, subHill + 1, lz, TYPES.YELLOW);
                          this.setBlock(lx, subHill + 2, lz, TYPES.YELLOW);
                        }
                      }
                      // Silo
                      if (lx === margin + 4 && lz === margin + 4) {
                        for (let sy = subHill + 1; sy <= subHill + 8; sy++) {
                          for (let sox = -1; sox <= 1; sox++) for (let soz = -1; soz <= 1; soz++) {
                            if (lx+sox >= 0 && lx+sox < CHUNK_SIZE && lz+soz >= 0 && lz+soz < CHUNK_SIZE)
                              this.setBlock(lx+sox, sy, lz+soz, TYPES.STEEL);
                          }
                        }
                        // Silo dome
                        this.setBlock(lx, subHill + 9, lz, TYPES.STEEL);
                      }
                      // Farm animals - cows (white + black blocks), sheep (white), pigs (pink)
                      let animalHash = hash2D(wx * 3 + 77, wz * 3 + 77);
                      if (animalHash > 0.992 && lx > margin + 6 && lx < CHUNK_SIZE - margin - 6 && lz > margin + 6 && lz < CHUNK_SIZE - margin - 6) {
                        let animalType = Math.floor(animalHash * 1000) % 3;
                        let sh = subHill + 1;
                        if (animalType === 0) {
                          // Cow: 3 blocks long, 2 tall, black & white
                          this.setBlock(lx, sh, lz, TYPES.WHITE); this.setBlock(lx+1, sh, lz, TYPES.CONCRETE_DARK); this.setBlock(lx+2, sh, lz, TYPES.WHITE);
                          this.setBlock(lx, sh+1, lz, TYPES.WHITE); this.setBlock(lx+2, sh+1, lz, TYPES.CONCRETE_DARK); // head
                        } else if (animalType === 1) {
                          // Sheep: 2 blocks long, 2 tall, white fluffy
                          this.setBlock(lx, sh, lz, TYPES.WHITE); this.setBlock(lx+1, sh, lz, TYPES.WHITE);
                          this.setBlock(lx, sh+1, lz, TYPES.WHITE); this.setBlock(lx+1, sh+1, lz, TYPES.CONCRETE_DARK); // face
                        } else {
                          // Pig: 2 blocks long, 1.5 tall, pink
                          this.setBlock(lx, sh, lz, TYPES.PLASTER_WARM); this.setBlock(lx+1, sh, lz, TYPES.PLASTER_WARM);
                          this.setBlock(lx+1, sh+1, lz, TYPES.PLASTER_WARM); // head
                        }
                      }
                      // Tractor (red vehicle-like block structure)
                      if (lx === CHUNK_SIZE - margin - 4 && lz === CHUNK_SIZE - margin - 4) {
                        this.setBlock(lx, subHill + 1, lz, TYPES.CONCRETE_DARK); // wheels
                        this.setBlock(lx+1, subHill + 1, lz, TYPES.CONCRETE_DARK);
                        this.setBlock(lx, subHill + 2, lz, TYPES.RED); // body
                        this.setBlock(lx+1, subHill + 2, lz, TYPES.RED);
                        this.setBlock(lx, subHill + 3, lz, TYPES.GLASS); // cab
                      }
                      // Fence around farm perimeter
                      if ((lx === margin + 2 || lx === CHUNK_SIZE - margin - 2) && lz > margin + 2 && lz < CHUNK_SIZE - margin - 2 && lz % 2 === 0) {
                        this.setBlock(lx, subHill + 1, lz, TYPES.WOOD);
                      }
                      if ((lz === margin + 2 || lz === CHUNK_SIZE - margin - 2) && lx > margin + 2 && lx < CHUNK_SIZE - margin - 2 && lx % 2 === 0) {
                        this.setBlock(lx, subHill + 1, lz, TYPES.WOOD);
                      }
                    }

                    // School/Hospital chunks: playground, parking
                    if (subType > 0.88 && subType <= 0.95) {
                      let isSchool = subType <= 0.915;
                      // Playground / parking area
                      if (lx > margin + 8 && lx < CHUNK_SIZE - margin - 4 && lz > margin + 1 && lz < margin + 5) {
                        this.setBlock(lx, subHill, lz, TYPES.CONCRETE); // paved area
                        // Playground equipment / benches
                        if (hash2D(wx * 9, wz * 9) > 0.96) {
                          this.setBlock(lx, subHill + 1, lz, isSchool ? TYPES.RED : TYPES.BLUE);
                          this.setBlock(lx, subHill + 2, lz, TYPES.STEEL);
                        }
                      }
                      // Sign post
                      if (lx === margin + 1 && lz === margin + 1) {
                        for (let sy = subHill + 1; sy <= subHill + 3; sy++) this.setBlock(lx, sy, lz, TYPES.STEEL);
                        this.setBlock(lx, subHill + 3, lz, isSchool ? TYPES.YELLOW : TYPES.RED);
                      }
                    }

                    // Mansion chunks: gardens, pools
                    if (subType > 0.95) {
                      // Garden hedges
                      if ((lx === margin + 3 || lx === CHUNK_SIZE - margin - 4) && lz > margin + 3 && lz < CHUNK_SIZE - margin - 3) {
                        this.setBlock(lx, subHill + 1, lz, TYPES.LEAVES);
                        this.setBlock(lx, subHill + 2, lz, TYPES.LEAVES);
                      }
                      // Pool
                      if (lx > CHUNK_SIZE - margin - 10 && lx < CHUNK_SIZE - margin - 4 && lz > margin + 6 && lz < margin + 12) {
                        this.setBlock(lx, subHill, lz, TYPES.WATER);
                      }
                    }

                    // Varied yard trees (different sizes and types) - biome-specific
                    if (hash2D(wx + 10, wz + 10) > 0.975) {
                      if (biome === 'DESERT') {
                        // Cactus
                        let cH = 3 + Math.floor(hash2D(wx + 15, wz + 15) * 3);
                        for (let y = subHill + 1; y <= subHill + cH; y++) this.setBlock(lx, y, lz, TYPES.GREEN);
                        // Cactus arms
                        if (cH > 3 && lx > 0 && lx < CHUNK_SIZE - 1) {
                          this.setBlock(lx + 1, subHill + cH - 1, lz, TYPES.GREEN);
                          this.setBlock(lx + 1, subHill + cH, lz, TYPES.GREEN);
                          if (cH > 4) { this.setBlock(lx - 1, subHill + cH - 2, lz, TYPES.GREEN); this.setBlock(lx - 1, subHill + cH - 1, lz, TYPES.GREEN); }
                        }
                      } else {
                        let treeType = hash2D(wx + 50, wz + 50);
                        let th = treeType > 0.5 ? (4 + Math.floor(hash2D(wx + 15, wz + 15) * 3)) : (2 + Math.floor(hash2D(wx + 15, wz + 15) * 2));
                        for (let y = subHill + 1; y <= subHill + th; y++) this.setBlock(lx, y, lz, TYPES.WOOD);
                        let cr = treeType > 0.5 ? 2 : 1;
                        let leafType = biome === 'SNOW' ? TYPES.WHITE : TYPES.LEAVES;
                        for (let ox = -cr; ox <= cr; ox++) for (let oz = -cr; oz <= cr; oz++) {
                          if (Math.abs(ox) + Math.abs(oz) <= cr + 1 && lx + ox >= 0 && lx + ox < CHUNK_SIZE && lz + oz >= 0 && lz + oz < CHUNK_SIZE) {
                            this.setBlock(lx + ox, subHill + th, lz + oz, leafType);
                            this.setBlock(lx + ox, subHill + th + 1, lz + oz, leafType);
                          }
                        }
                        // Snow on ground under trees
                        if (biome === 'SNOW') this.setBlock(lx, subHill, lz, TYPES.SNOW);
                      }
                    }

                    // Flower gardens (random colored blocks)
                    if (hash2D(wx + 33, wz + 33) > 0.992) {
                      let flowerColors = [TYPES.RED, TYPES.YELLOW, TYPES.BLUE];
                      this.setBlock(lx, subHill + 1, lz, flowerColors[Math.floor(hash2D(wx + 44, wz + 44) * 3)]);
                    }

                    // Suburban lamp posts
                    if (lx === margin - 1 && lz % 24 === 0) {
                      for (let y = subHill + 1; y <= subHill + 3; y++) this.setBlock(lx, y, lz, TYPES.STEEL);
                      this.setBlock(lx, subHill + 4, lz, TYPES.LIGHT);
                    }
                  }
                }
              } else if (isPark || zone === 'RURAL' || zone === 'ISLAND' || biome === 'MOUNTAIN') {
                // Nature generation - larger terrain hills
                let hillScale = zone === 'RURAL' ? 12 : (zone === 'ISLAND' ? 5 : (zone === 'SUBURBAN' ? 5 : 3));

                // Mountain biome: massive terrain
                if (biome === 'MOUNTAIN') {
                  let mtDist = Math.sqrt((wx + 600) * (wx + 600) + (wz + 200) * (wz + 200));
                  let mtFactor = Math.max(0, 1 - mtDist / 120); // 1 at center, 0 at edge
                  hillScale = 15 + mtFactor * 55; // Up to 70 blocks tall at center
                }

                let hill = Math.floor(smoothNoise(wx * 0.06, wz * 0.06) * hillScale);
                // Extra hills using secondary noise for more terrain variation
                let hill2 = Math.floor(smoothNoise(wx * 0.12 + 50, wz * 0.12 + 50) * (hillScale * 0.5));
                hill = Math.max(hill, hill2);

                // Mountain biome: use stone and snow caps
                if (biome === 'MOUNTAIN') {
                  for (let hy = 1; hy <= hill; hy++) {
                    if (hy === hill && hill > 40) this.setBlock(lx, hy, lz, TYPES.SNOW); // Snow cap
                    else if (hy === hill && hill > 25) this.setBlock(lx, hy, lz, hy % 2 === 0 ? TYPES.SNOW : TYPES.STONE); // Partial snow
                    else if (hy === hill) this.setBlock(lx, hy, lz, TYPES.GRASS);
                    else if (hy > hill - 3) this.setBlock(lx, hy, lz, TYPES.STONE);
                    else this.setBlock(lx, hy, lz, TYPES.DIRT);
                  }
                  // Boulder details on mountains
                  if (hill > 15 && hash2D(wx * 7, wz * 7) > 0.97) {
                    this.setBlock(lx, hill + 1, lz, TYPES.STONE);
                    if (hash2D(wx * 11, wz * 11) > 0.5) this.setBlock(lx, hill + 2, lz, TYPES.STONE);
                  }
                } else {
                  for (let hy = 1; hy <= hill; hy++) this.setBlock(lx, hy, lz, hy === hill ? groundType : subSoilType);
                }

                // Waterfalls on tall hills
                if (hill >= 5 && (zone === 'RURAL' || zone === 'SUBURBAN' || biome === 'MOUNTAIN')) {
                  let adjHill = Math.floor(smoothNoise((wx + 1) * 0.06, wz * 0.06) * hillScale);
                  if (adjHill < hill - 2 && hash2D(wx * 3, wz * 3) > 0.92) {
                    for (let wy = adjHill + 1; wy <= hill; wy++) this.setBlock(lx, wy, lz, TYPES.WATER);
                  }
                }

                // Trees - biome-specific
                let treeChance = zone === 'RURAL' ? 0.975 : (zone === 'ISLAND' ? 0.91 : (zone === 'SUBURBAN' ? 0.98 : 0.95));
                if (biome === 'MOUNTAIN') treeChance = hill > 30 ? 1.0 : 0.99; // Very sparse on mountains, none above treeline
                if (biome === 'DESERT') treeChance = 0.995; // Very sparse in desert

                if (hash2D(wx, wz) > treeChance) {
                  if (biome === 'DESERT') {
                    // Cactus in desert
                    let cH = 3 + Math.floor(hash2D(wx + 5, wz + 5) * 4);
                    for (let y = hill + 1; y <= hill + cH; y++) this.setBlock(lx, y, lz, TYPES.GREEN);
                    if (cH > 3 && lx > 0 && lx < CHUNK_SIZE - 1) {
                      this.setBlock(lx + 1, hill + cH - 1, lz, TYPES.GREEN);
                      this.setBlock(lx + 1, hill + cH, lz, TYPES.GREEN);
                      if (cH > 4) { this.setBlock(lx - 1, hill + cH - 2, lz, TYPES.GREEN); this.setBlock(lx - 1, hill + cH - 1, lz, TYPES.GREEN); }
                    }
                  } else {
                    let treeH = 4 + Math.floor(hash2D(wx + 5, wz + 5) * 5);
                    for (let y = hill + 1; y <= hill + treeH; y++) this.setBlock(lx, y, lz, TYPES.WOOD);
                    let canopyR = treeH > 6 ? 3 : 2;
                    let leafType = biome === 'SNOW' ? TYPES.WHITE : TYPES.LEAVES;
                    for (let y = hill + treeH - 2; y <= hill + treeH + 2; y++) {
                      let r = (y === hill + treeH + 2) ? 1 : canopyR;
                      for (let ox = -r; ox <= r; ox++) {
                        for (let oz = -r; oz <= r; oz++) {
                          if (Math.abs(ox) + Math.abs(oz) < r + canopyR && lx + ox >= 0 && lx + ox < CHUNK_SIZE && lz + oz >= 0 && lz + oz < CHUNK_SIZE) {
                            let leafWX = wx + ox, leafWZ = wz + oz;
                            let isLeafInRoad = (Math.abs(leafWX) % CHUNK_SIZE < ROAD_WIDTH) || (Math.abs(leafWZ) % CHUNK_SIZE < ROAD_WIDTH);
                            if (!isLeafInRoad) this.setBlock(lx + ox, y, lz + oz, leafType);
                          }
                        }
                      }
                    }
                    // Snow layer under snowy trees
                    if (biome === 'SNOW' && hill === 0) this.setBlock(lx, 0, lz, TYPES.SNOW);
                  }
                }
                // Flowers/bushes - not in desert or mountain
                if (biome !== 'DESERT' && biome !== 'MOUNTAIN' && hash2D(wx + 3, wz + 3) > 0.98) this.setBlock(lx, hill + 1, lz, groundType === TYPES.SNOW ? TYPES.WHITE : TYPES.LEAVES);
                // Desert: tumbleweeds/dead bushes
                if (biome === 'DESERT' && hash2D(wx + 3, wz + 3) > 0.993) this.setBlock(lx, hill + 1, lz, TYPES.YELLOW);
                // Desert: occasional oasis
                if (biome === 'DESERT' && hash2D(wx * 2 + 7, wz * 2 + 7) > 0.998) {
                  for (let ox = -2; ox <= 2; ox++) for (let oz = -2; oz <= 2; oz++) {
                    if (Math.abs(ox) + Math.abs(oz) <= 2 && lx+ox >= 0 && lx+ox < CHUNK_SIZE && lz+oz >= 0 && lz+oz < CHUNK_SIZE)
                      this.setBlock(lx+ox, hill > 0 ? hill : 0, lz+oz, TYPES.WATER);
                  }
                  // Palm tree at oasis
                  for (let py = hill + 1; py <= hill + 6; py++) this.setBlock(lx, py, lz, TYPES.WOOD);
                  for (let ox = -2; ox <= 2; ox++) for (let oz = -2; oz <= 2; oz++) {
                    if (Math.abs(ox) + Math.abs(oz) <= 2 && lx+ox >= 0 && lx+ox < CHUNK_SIZE && lz+oz >= 0 && lz+oz < CHUNK_SIZE)
                      this.setBlock(lx+ox, hill + 7, lz+oz, TYPES.LEAVES);
                  }
                }
                // Rare fountain in parks
                if (hash2D(wx, wz) > 0.995 && zone !== 'RURAL' && biome === 'NORMAL') {
                  for (let fx = -2; fx <= 2; fx++) {
                    for (let fz = -2; fz <= 2; fz++) {
                      let d = Math.abs(fx) + Math.abs(fz);
                      if (d === 2 || d === 3) { if (lx+fx >= 0 && lx+fx < CHUNK_SIZE && lz+fz >= 0 && lz+fz < CHUNK_SIZE) this.setBlock(lx+fx, 1, lz+fz, TYPES.CONCRETE); }
                      else if (d < 2) { if (lx+fx >= 0 && lx+fx < CHUNK_SIZE && lz+fz >= 0 && lz+fz < CHUNK_SIZE) this.setBlock(lx+fx, 1, lz+fz, TYPES.WATER); }
                    }
                  }
                  this.setBlock(lx, 2, lz, TYPES.CONCRETE);
                  this.setBlock(lx, 3, lz, TYPES.WATER);
                }
              }
            }

            // Elevated rail line (runs north-south through downtown and urban zones)
            if (zone === 'DOWNTOWN' || zone === 'URBAN' || zone === 'SUBURBAN') {
              let railX = 60;
              if (Math.abs(wx - railX) < 2) {
                this.setBlock(lx, 20, lz, TYPES.RAIL);
                // Rail supports every 24 blocks
                if (wz % 24 === 0 && wx === railX) {
                  for (let ry = 1; ry < 20; ry++) {
                    if (!this.blocks.has(lx + "," + ry + "," + lz)) {
                      this.setBlock(lx, ry, lz, TYPES.STEEL);
                    }
                  }
                }
                // Platform at stations (every 192 blocks)
                if (Math.abs(wz % 192) < 8) {
                  for (let px = -3; px <= 3; px++) {
                    if (lx + px >= 0 && lx + px < CHUNK_SIZE) {
                      this.setBlock(lx + px, 20, lz, TYPES.CONCRETE);
                      if ((px === -3 || px === 3) && wz % 4 === 0) {
                        this.setBlock(lx + px, 21, lz, TYPES.STEEL);
                      }
                    }
                  }
                }
              }
            }

            // Highway overpasses (downtown and urban only)
            if (zone === 'DOWNTOWN' || zone === 'URBAN') {
              let hxMod = ((wx % 128) + 128) % 128, hzMod = ((wz % 128) + 128) % 128;
              let isHighwayX = hxMod < 8, isHighwayZ = hzMod < 8;
              // Ramp zones: gradual slope from y=0 to y=15 over ~15 blocks at each end
              let rampX = hxMod >= 8 && hxMod < 23, rampXdown = hxMod >= 113 && hxMod < 128;
              let rampZ = hzMod >= 8 && hzMod < 23, rampZdown = hzMod >= 113 && hzMod < 128;
              if (isHighwayX || isHighwayZ) {
                // Elevated highway deck with road markings
                this.setBlock(lx, 15, lz, TYPES.ROAD);
                // Barriers on edges
                let xEdge = isHighwayX && (hxMod === 0 || hxMod === 7);
                let zEdge = isHighwayZ && (hzMod === 0 || hzMod === 7);
                if (xEdge || zEdge) {
                  this.setBlock(lx, 16, lz, TYPES.CONCRETE);
                }
                // Support pillars
                if ((wx % 24 === 0 && isHighwayX && !isHighwayZ) || (wz % 24 === 0 && isHighwayZ && !isHighwayX)) {
                  if (!isWater && !isRoad) {
                    for (let y = 1; y < 15; y++) this.setBlock(lx, y, lz, TYPES.CONCRETE);
                  }
                }
              }
              // On-ramps (X direction highways) - offset to the side, not on the road
              if ((rampX || rampXdown) && hzMod >= 10 && hzMod < 14 && !isRoad) {
                let rampProgress = rampX ? (hxMod - 8) / 14.0 : (128 - hxMod) / 14.0;
                let rampY = Math.max(1, Math.floor(rampProgress * 15));
                this.setBlock(lx, rampY, lz, TYPES.ROAD);
                if (hzMod === 10 || hzMod === 13) this.setBlock(lx, rampY + 1, lz, TYPES.CONCRETE);
              }
              // Bridge connecting side ramp to highway deck (X direction)
              if ((rampX || rampXdown) && hzMod >= 6 && hzMod < 10) {
                let rampProgress = rampX ? (hxMod - 8) / 14.0 : (128 - hxMod) / 14.0;
                if (rampProgress > 0.75) {
                  this.setBlock(lx, 15, lz, TYPES.ROAD);
                  if (hzMod === 6 || hzMod === 9) this.setBlock(lx, 16, lz, TYPES.CONCRETE);
                }
              }
              // On-ramps (Z direction highways) - offset to the side
              if ((rampZ || rampZdown) && hxMod >= 10 && hxMod < 14 && !isRoad) {
                let rampProgress = rampZ ? (hzMod - 8) / 14.0 : (128 - hzMod) / 14.0;
                let rampY = Math.max(1, Math.floor(rampProgress * 15));
                this.setBlock(lx, rampY, lz, TYPES.ROAD);
                if (hxMod === 10 || hxMod === 13) this.setBlock(lx, rampY + 1, lz, TYPES.CONCRETE);
              }
              // Bridge connecting side ramp to highway deck (Z direction)
              if ((rampZ || rampZdown) && hxMod >= 6 && hxMod < 10) {
                let rampProgress = rampZ ? (hzMod - 8) / 14.0 : (128 - hzMod) / 14.0;
                if (rampProgress > 0.75) {
                  this.setBlock(lx, 15, lz, TYPES.ROAD);
                  if (hxMod === 6 || hxMod === 9) this.setBlock(lx, 16, lz, TYPES.CONCRETE);
                }
              }
            }
          }
        }
        // === UNDERGROUND LAYERS (5 blocks deep with ore clusters) ===
        for (let lx = 0; lx < CHUNK_SIZE; lx++) {
          for (let lz = 0; lz < CHUNK_SIZE; lz++) {
            let wx = startX + lx, wz = startZ + lz;
            // Check if there's a surface block at y=0 (not water/empty)
            let surfaceBlock = this.blocks.get(lx + ",0," + lz);
            if (!surfaceBlock || surfaceBlock === TYPES.WATER) continue;
            // Generate 4 underground layers (y=-1 to y=-4)
            for (let dy = -1; dy >= -4; dy--) {
              let oreRoll = hash2D(wx * 0.37 + dy * 13.7, wz * 0.41 + dy * 7.3);
              let blockType = (dy === -1) ? TYPES.DIRT : TYPES.STONE;
              // Ore clusters based on depth and noise
              if (dy <= -2) {
                if (oreRoll < 0.03) blockType = TYPES.DIAMOND_ORE; // Very rare
                else if (oreRoll < 0.08) blockType = TYPES.GOLD; // Rare
                else if (oreRoll < 0.18) blockType = TYPES.IRON_ORE; // Uncommon
                else if (oreRoll < 0.28) blockType = TYPES.COAL_ORE; // Common
              }
              this.setBlock(lx, dy, lz, blockType);
            }
          }
        }
      }
      setBlock(lx, y, lz, type) {
        let mapKey = lx + "," + y + "," + lz;
        this.blocks.set(mapKey, type);
        if (!this.typeCounts[type]) this.typeCounts[type] = 0;
        this.typeCounts[type]++;
      }
      buildMeshes() {
        const geo = new THREE.BoxGeometry(1, 1, 1);
        for (let type in this.typeCounts) {
          if (this.typeCounts[type] > 0) {
            let mesh = new THREE.InstancedMesh(geo, MATERIALS[type], this.typeCounts[type] + 100);
            mesh.castShadow = true; mesh.receiveShadow = true;
            this.group.add(mesh);
            this.meshesByType[type] = mesh;
          }
        }
        this.rebuildAll();
      }
      rebuildAll() {
        for (let type in this.meshesByType) this.meshesByType[type].count = 0;
        const matrix = new THREE.Matrix4();
        for (let [k, type] of this.blocks.entries()) {
          let parts = k.split(',');
          let lx = Number(parts[0]), y = Number(parts[1]), lz = Number(parts[2]);
          // Skip fully enclosed underground blocks (all 6 neighbors are solid)
          if (y < 0) {
            let exposed = false;
            let dirs = [[1,0,0],[-1,0,0],[0,1,0],[0,-1,0],[0,0,1],[0,0,-1]];
            for (let d of dirs) {
              let nlx = lx + d[0], ny = y + d[1], nlz = lz + d[2];
              let nk = nlx + "," + ny + "," + nlz;
              if (!this.blocks.has(nk)) { exposed = true; break; }
            }
            if (!exposed) continue; // Don't render fully enclosed blocks
          }
          matrix.setPosition(this.cx * CHUNK_SIZE + lx, y, this.cz * CHUNK_SIZE + lz);
          this.meshesByType[type].setMatrixAt(this.meshesByType[type].count++, matrix);
        }
        for (let type in this.meshesByType) this.meshesByType[type].instanceMatrix.needsUpdate = true;
      }
      destroyBlock(lx, y, lz) {
        let mapKey = lx + "," + y + "," + lz;
        let type = this.blocks.get(mapKey);
        if (type && y > -5) {
          this.blocks.delete(mapKey);
          this.rebuildAll();
          return type;
        }
        return null;
      }
      dispose() {
        scene.remove(this.group);
        this.group.children.forEach(c => c.dispose());
      }
    }

    function updateChunks() {
      let viewPos = (currentVehicle && !currentVehicle.isDead) ? currentVehicle.pos : player.pos;
      let px = Math.floor(viewPos.x / CHUNK_SIZE);
      let pz = Math.floor(viewPos.z / CHUNK_SIZE);
      // Increase view distance when driving for lookahead
      let vd = (currentVehicle && !currentVehicle.isDead) ? VIEW_DISTANCE + 2 : VIEW_DISTANCE;
      let keep = new Set();
      for (let x = px - vd; x <= px + vd; x++) {
        for (let z = pz - vd; z <= pz + vd; z++) {
          let mapKey = x + "," + z;
          keep.add(mapKey);
          if (!activeChunks.has(mapKey)) activeChunks.set(mapKey, new Chunk(x, z));
        }
      }
      // Also preload chunks in vehicle movement direction
      if (currentVehicle && !currentVehicle.isDead) {
        let vel = currentVehicle.vel;
        let speed = Math.sqrt(vel.x * vel.x + vel.z * vel.z);
        if (speed > 5) {
          let dirX = vel.x / speed, dirZ = vel.z / speed;
          for (let ahead = vd + 1; ahead <= vd + 3; ahead++) {
            let fx = px + Math.round(dirX * ahead);
            let fz = pz + Math.round(dirZ * ahead);
            let mapKey = fx + "," + fz;
            keep.add(mapKey);
            if (!activeChunks.has(mapKey)) activeChunks.set(mapKey, new Chunk(fx, fz));
          }
        }
      }
      for (let [mapKey, chunk] of activeChunks.entries()) {
        if (!keep.has(mapKey)) { chunk.dispose(); activeChunks.delete(mapKey); }
      }
    }

    function getBlock(wx, wy, wz) {
      wx = Math.round(wx); wy = Math.round(wy); wz = Math.round(wz);
      let cx = Math.floor(wx / CHUNK_SIZE), cz = Math.floor(wz / CHUNK_SIZE);
      let mapKey = cx + "," + cz, chunk = activeChunks.get(mapKey);
      if (chunk) return chunk.blocks.get((wx - (cx * CHUNK_SIZE)) + "," + wy + "," + (wz - (cz * CHUNK_SIZE))) || TYPES.EMPTY;
      return TYPES.EMPTY;
    }

    function triggerDestroy(wx, wy, wz, velDir, isPlayerAction = false) {
      wx = Math.round(wx); wy = Math.round(wy); wz = Math.round(wz);
      let cx = Math.floor(wx / CHUNK_SIZE), cz = Math.floor(wz / CHUNK_SIZE);
      // Perimeter barrier is indestructible
      let chCx = cx * CHUNK_SIZE + CHUNK_SIZE / 2, chCz = cz * CHUNK_SIZE + CHUNK_SIZE / 2;
      if (Math.sqrt(chCx * chCx + chCz * chCz) > 850) return false;
      let mapKey = cx + "," + cz, chunk = activeChunks.get(mapKey);
      if (chunk) {
        let type = chunk.destroyBlock(wx - (cx * CHUNK_SIZE), wy, wz - (cz * CHUNK_SIZE));
        if (type) {
          spawnPhysicsParticle(wx, wy, wz, type, velDir);
          // Drop block pickup from every destroyed block
          if (isPlayerAction) spawnBlockPickup(wx, wy, wz, type);
          if (isPlayerAction) {
            let pts = 10, ch = 2;
            if (type === TYPES.GLASS || type === TYPES.GLASS_BLUE || type === TYPES.GLASS_DARK) pts = 25;
            if (type === TYPES.GOLD || type === TYPES.BLUE || type === TYPES.RED) { pts = 200; ch = 50; }
            score += pts; addChaos(ch); updateHUD();
            if (mission.active && mission.state === 'GO_TO_BANK' && type === TYPES.GOLD) {
              if (wx > 48 && wx < 96 && wz > 48 && wz < 96) {
                // Secret gold found logic
              }
            }
            // Mission 5: Track carpark block destruction (200 block target ~5% of carpark)
            if (missionIndex === 4 && mission.state === 'DESTROY_CARPARK' && cx === 4 && cz === -1) {
              carparkBlocksDestroyed++;
              let target = 200;
              let pct = Math.min(Math.floor((carparkBlocksDestroyed / target) * 100), 100);
              document.getElementById('objective-text').innerText = 'DESTROY THE CAR PARK: ' + Math.min(carparkBlocksDestroyed, target) + '/' + target + ' blocks';
              document.getElementById('demo-fill').style.height = pct + '%';
              document.getElementById('demo-pct').innerText = Math.min(carparkBlocksDestroyed, target) + '/' + target;
              if (carparkBlocksDestroyed >= target) triggerMissionSuccess();
            }
          }
          return true;
        }
      }
      return false;
    }

    function getLaneDirection(pos) {
      let onXRoad = Math.abs(pos.x) % CHUNK_SIZE < ROAD_WIDTH;
      let onZRoad = Math.abs(pos.z) % CHUNK_SIZE < ROAD_WIDTH;
      if (onXRoad && !onZRoad) return (pos.x % CHUNK_SIZE) > 0 ? new THREE.Vector3(0, 0, 1) : new THREE.Vector3(0, 0, -1);
      if (onZRoad && !onXRoad) return (pos.z % CHUNK_SIZE) > 0 ? new THREE.Vector3(1, 0, 0) : new THREE.Vector3(-1, 0, 0);
      return null;
    }

    class Vehicle {
      constructor(type, x, z, color) {
        this.type = type; this.pos = new THREE.Vector3(x, type === 'PLANE' ? 4.0 : (type === 'TANK' ? 2.0 : 1.5), z);
        this.vel = new THREE.Vector3(); this.yaw = 0; this.planePitch = 0;
        this.health = type === 'TANK' ? 1500 : (type === 'ARMY' ? 800 : (type === 'COP' ? 600 : (type === 'PLANE' ? 500 : 500)));
        this.maxHealth = this.health;
        this.collisionHits = 0; // Track collision impacts for visual damage
        this.isDead = false; this.nos = 100; this.isFlying = false; this.parked = false;
        this.ramHits = 0; this.burning = false; this.lastRam = 0; this.driftAngle = 0;
        this.turretYaw = 0; this.lastTankShot = 0;
        let targetDir = getLaneDirection(this.pos);
        if (targetDir) this.yaw = Math.atan2(-targetDir.x, -targetDir.z);

        if (type === 'PLANE') {
          this.voxelGroup = new VoxelPlane(color);
        } else if (type === 'TANK') {
          this.voxelGroup = new VoxelTank();
        } else {
          let modelType = 'CAR';
          if (type === 'COP') modelType = 'COP_CAR';
          if (type === 'ARMY') modelType = 'ARMY_CAR';
          this.voxelGroup = new VoxelCar(modelType, color);
        }
        this.mesh = this.voxelGroup.group;
        scene.add(this.mesh);
      }
      updatePhysics(dt, inputAccel, inputSteer, useNOS) {
        if (this.isDead) {
          inputAccel = 0; inputSteer = 0;
          // Much less smoke/fire - only occasional puffs
          if (Math.random() < 0.03) spawnPhysicsParticle(this.pos.x, this.pos.y, this.pos.z, 'FIRE');
          if (Math.random() < 0.05) spawnPhysicsParticle(this.pos.x, this.pos.y + 1, this.pos.z, 'SMOKE', null, true);
        }

        // --- PLANE FLIGHT PHYSICS ---
        if (this.type === 'PLANE' && !this.isDead) {
          const fwd = new THREE.Vector3(-Math.sin(this.yaw), 0, -Math.cos(this.yaw));
          this.vel.add(fwd.clone().multiplyScalar(inputAccel * 20 * dt));
          let speed = Math.sqrt(this.vel.x * this.vel.x + this.vel.z * this.vel.z);
          // Cap plane speed so terrain has time to load
          if (speed > 25) { let s = 25 / speed; this.vel.x *= s; this.vel.z *= s; speed = 25; }
          this.isFlying = speed > 12 || this.pos.y > 5;
          if (speed > 2) this.yaw -= inputSteer * 2.5 * dt;
          // Lift & climb (Space key handled in game loop, useNOS for mouse/mobile)
          if (useNOS && this.isFlying) this.vel.y += 25 * dt;
          if (this.isFlying) {
            this.vel.y -= 12 * dt; // Gravity ‚Äî plane descends when not pressing Space
            if (speed > 15) this.vel.y += speed * 0.04 * dt; // Gentle speed-based lift
          } else {
            this.vel.y -= 30 * dt; // Ground gravity
          }
          // Drag
          this.vel.x *= 0.995; this.vel.z *= 0.995; this.vel.y *= 0.99;
          let stepX = this.vel.x * dt, stepZ = this.vel.z * dt;
          this.pos.x += stepX; this.pos.z += stepZ; this.pos.y += this.vel.y * dt;
          // Ground check
          let highest = -3;
          for (let y = Math.floor(this.pos.y + 2); y >= -3; y--) {
            let b = getBlock(this.pos.x, y, this.pos.z);
            if (b !== TYPES.EMPTY && b !== TYPES.WATER) { highest = y; break; }
          }
          if (this.pos.y - 1.5 <= highest) {
            this.pos.y = highest + 1.5; this.vel.y = Math.max(0, this.vel.y); this.isFlying = false;
            if (speed > 30) { // Crash landing damage
              this.takeDamage(Math.floor(speed), this === currentVehicle);
            }
          }
          // Building collision while flying
          if (this.isFlying) {
            let isPlayerAction = (this === currentVehicle);
            for (let bx = -1; bx <= 1; bx += 2) for (let bz = -1; bz <= 1; bz += 2) {
              let bt = getBlock(this.pos.x + bx, this.pos.y, this.pos.z + bz);
              if (bt !== TYPES.EMPTY && bt !== TYPES.ROAD && bt !== TYPES.WATER) {
                let blast = Math.min(5, Math.floor(speed / 8));
                for (let dx = -blast; dx <= blast; dx++) for (let dy = -blast; dy <= blast; dy++) for (let dz = -blast; dz <= blast; dz++)
                  triggerDestroy(this.pos.x + bx + dx, this.pos.y + dy, this.pos.z + bz + dz, this.vel, isPlayerAction);
                this.vel.multiplyScalar(0.5);
                this.takeDamage(50, isPlayerAction);
                if (isPlayerAction) camera.position.add(new THREE.Vector3((Math.random() - 0.5) * 4, (Math.random() - 0.5) * 4, 0));
              }
            }
          }
          this.mesh.position.copy(this.pos);
          this.mesh.rotation.y = this.yaw;
          this.mesh.rotation.x = this.isFlying ? -this.vel.y * 0.02 : 0;
          this.mesh.rotation.z = this.isFlying ? inputSteer * 0.4 : 0;
          return;
        }

        const forward = new THREE.Vector3(-Math.sin(this.yaw), 0, -Math.cos(this.yaw));
        const right = new THREE.Vector3(-Math.cos(this.yaw), 0, Math.sin(this.yaw));
        let blockBelow = getBlock(this.pos.x, this.pos.y - 0.5, this.pos.z);
        let inWater = (blockBelow === TYPES.WATER || getBlock(this.pos.x, this.pos.y, this.pos.z) === TYPES.WATER);
        let speedMult = inWater ? 0.3 : 1.0;
        // Flying car: space = fly upward
        if (this.isFlyingCar && useNOS) {
          this.vel.y += 30 * dt;
          this.isFlying = this.pos.y > 3;
        }
        if (this.isFlyingCar && this.pos.y > 3) {
          this.vel.y -= 12 * dt; // Gentle gravity for flying car
          this.isFlying = true;
        }
        // Sports car: extra speed
        let extraSpeed = this.isSportsCar ? 1.5 : 1.0;
        if (useNOS && this.nos > 0 && !inWater && !this.isFlyingCar) { speedMult = 2.0 * extraSpeed; this.nos -= 30 * dt; }
        else if (this.nos < 100) { this.nos += 10 * dt; }
        speedMult *= extraSpeed;

        this.vel.add(forward.clone().multiplyScalar(inputAccel * 50 * speedMult * dt));
        this.vel.x *= (inWater ? 0.8 : 0.94); this.vel.z *= (inWater ? 0.8 : 0.94);
        let fwdSpeed = this.vel.dot(forward), latSpeed = this.vel.dot(right);
        let speed = Math.sqrt(this.vel.x * this.vel.x + this.vel.z * this.vel.z);

        // Steering: gradual yaw change for smooth, controllable turning
        let steerAmount = inWater ? 1.2 : (2.2 + speed * 0.02);
        if (Math.abs(fwdSpeed) > 1 && !inWater) this.yaw -= inputSteer * steerAmount * dt * Math.sign(fwdSpeed);

        // Drift grip model: grip drops with speed + steering angle - more drifty
        let speedFactor = Math.min(speed / 20, 1.0);
        let steerFactor = Math.abs(inputSteer);
        let baseGrip = inWater ? 0.90 : 0.82;
        let grip = baseGrip - (steerFactor * 0.40 * speedFactor) - (speedFactor * 0.12);
        // Handbrake/NOS drift: using NOS while steering = powerslide
        if (useNOS && steerFactor > 0.3 && speed > 6) grip -= 0.20;
        grip = Math.max(0.30, Math.min(grip, 0.92));

        // Track drift amount for effects
        let driftAmount = Math.abs(latSpeed) * (1 - grip);
        this.driftAngle = latSpeed * (1 - grip) * 0.15; // Store for body roll

        latSpeed *= grip;
        let newVelXZ = forward.clone().multiplyScalar(fwdSpeed).add(right.clone().multiplyScalar(latSpeed));
        this.vel.x = newVelXZ.x; this.vel.z = newVelXZ.z;
        if (!this.isFlyingCar || !this.isFlying) this.vel.y -= (inWater ? 10 : 40) * dt;

        let highest = -3;
        for (let y = Math.floor(this.pos.y + 1.5); y >= -3; y--) {
          let b = getBlock(this.pos.x, y, this.pos.z);
          if (b !== TYPES.EMPTY && b !== TYPES.WATER) { highest = y; break; }
        }
        let onGround = Math.abs(this.pos.y - (highest + 0.5)) < 1.0;
        let isDrifting = Math.abs(latSpeed) > 2.0 || driftAmount > 1.5;

        if (isDrifting && onGround && !this.isDead && !inWater) {
          // Tyre smoke during drifts - intensity scales with drift severity
          let smokeChance = Math.min(0.6, driftAmount * 0.08);
          if (Math.random() < smokeChance) spawnPhysicsParticle(this.pos.x, this.pos.y - 0.5, this.pos.z, 'SMOKE', null, true);
          // Rear-left tyre mark
          let rlX = this.pos.x + Math.cos(this.yaw) * 0.7 + Math.sin(this.yaw) * 1.2;
          let rlZ = this.pos.z - Math.sin(this.yaw) * 0.7 + Math.cos(this.yaw) * 1.2;
          spawnSkidMark(rlX, rlZ, this.yaw, Math.min(driftAmount * 0.1, 0.7));
          // Rear-right tyre mark
          let rrX = this.pos.x - Math.cos(this.yaw) * 0.7 + Math.sin(this.yaw) * 1.2;
          let rrZ = this.pos.z + Math.sin(this.yaw) * 0.7 + Math.cos(this.yaw) * 1.2;
          spawnSkidMark(rrX, rrZ, this.yaw, Math.min(driftAmount * 0.1, 0.7));
        }
        // Regular driving tyre marks at high speed (lighter)
        if (speed > 18 && onGround && !this.isDead && !inWater && Math.random() < 0.15) {
          let rlX = this.pos.x + Math.cos(this.yaw) * 0.7 + Math.sin(this.yaw) * 1.2;
          let rlZ = this.pos.z - Math.sin(this.yaw) * 0.7 + Math.cos(this.yaw) * 1.2;
          spawnSkidMark(rlX, rlZ, this.yaw, 0.25);
        }
        
        let stepX = this.vel.x * dt, stepY = this.vel.y * dt, stepZ = this.vel.z * dt;
        let nextX = this.pos.x + stepX, nextY = this.pos.y + stepY, nextZ = this.pos.z + stepZ;
        if (nextY - 0.5 <= highest) { nextY = highest + 0.5; this.vel.y = 0; if (this.isFlyingCar) this.isFlying = false; }
        
        let hitBuilding = false, speedMag = Math.sqrt(this.vel.x * this.vel.x + this.vel.z * this.vel.z);
        let isPlayerAction = (this === currentVehicle);
        for (let bx = -1; bx <= 1; bx += 2) {
          for (let bz = -1; bz <= 1; bz += 2) {
            let bType = getBlock(nextX + bx, nextY + 1, nextZ + bz);
            if (bType !== TYPES.EMPTY && bType !== TYPES.ROAD && bType !== TYPES.WATER) {
              if (speedMag > 15) {
                let blast = Math.min(4, Math.floor(speedMag / 10));
                for (let dx = -blast; dx <= blast; dx++) {
                  for (let dy = 0; dy <= blast; dy++) {
                    for (let dz = -blast; dz <= blast; dz++) triggerDestroy(nextX + bx + dx, nextY + dy, nextZ + bz + dz, this.vel, isPlayerAction);
                  }
                }
                hitBuilding = true;
              } else {
                stepX = 0; stepZ = 0; this.vel.x = 0; this.vel.z = 0;
              }
            }
          }
        }
        if (hitBuilding) {
          this.vel.x *= 0.6; this.vel.z *= 0.6;
          // Only visually damage player's vehicle from building hits, not AI cars
          if (isPlayerAction) {
            this.voxelGroup.damageAtLocal(new THREE.Vector3(0, 0.5, -2.0), 1.5, this.mesh.matrixWorld, this.vel);
            this.takeDamage(10, isPlayerAction);
            camera.position.add(new THREE.Vector3((Math.random() - 0.5) * 3, (Math.random() - 0.5) * 3, 0));
          }
        }
        // Vehicle-to-vehicle collision
        for (let other of vehicles) {
          if (other === this || other.isDead) continue;
          // Don't let NPC cars damage parked planes
          if (other.type === 'PLANE' && other !== currentVehicle) continue;
          if (this.type === 'PLANE' && this !== currentVehicle) continue;
          let distSq = this.pos.distanceToSquared(other.pos);
          if (distSq < 8) {
            let pushDir = this.pos.clone().sub(other.pos);
            if (pushDir.lengthSq() < 0.01) pushDir.set(Math.random() - 0.5, 0, Math.random() - 0.5);
            pushDir.normalize();
            let overlap = 2.8 - Math.sqrt(distSq);
            // Separate vehicles
            this.pos.add(pushDir.clone().multiplyScalar(overlap * 0.5));
            other.pos.add(pushDir.clone().multiplyScalar(-overlap * 0.5));
            // Impact physics
            let relSpeed = Math.sqrt((this.vel.x - other.vel.x) ** 2 + (this.vel.z - other.vel.z) ** 2);
            if (relSpeed > 3) {
              // Bounce velocities
              this.vel.add(pushDir.clone().multiplyScalar(relSpeed * 0.3));
              other.vel.add(pushDir.clone().multiplyScalar(-relSpeed * 0.3));
              this.vel.multiplyScalar(0.7); other.vel.multiplyScalar(0.7);
              // Damage both vehicles ‚Äî gradual over ~5 hits
              let impactDmg = Math.floor(relSpeed * 2);
              this.collisionHits = (this.collisionHits || 0) + 1;
              other.collisionHits = (other.collisionHits || 0) + 1;
              // Visual: knock blocks off on impact point
              let dmgRadius = 0.5 + Math.min(this.collisionHits * 0.15, 1.5);
              this.voxelGroup.damageAtLocal(pushDir.clone().negate().multiplyScalar(0.5), dmgRadius, this.mesh.matrixWorld, this.vel);
              other.voxelGroup.damageAtLocal(pushDir.clone().multiplyScalar(0.5), dmgRadius, other.mesh.matrixWorld, other.vel);
              // Progressive darkening based on damage ratio
              if (this.voxelGroup.darkenByDamage) this.voxelGroup.darkenByDamage(this.health / this.maxHealth);
              if (other.voxelGroup.darkenByDamage) other.voxelGroup.darkenByDamage(other.health / other.maxHealth);
              this.takeDamage(impactDmg, isPlayerAction);
              other.takeDamage(impactDmg, other === currentVehicle);
              // Camera shake if player involved
              if (isPlayerAction || other === currentVehicle) {
                camera.position.add(new THREE.Vector3((Math.random() - 0.5) * 2, (Math.random() - 0.5) * 2, 0));
              }
            }
          }
        }
        for (let p of peds) {
          if (!p.isDead && this.pos.distanceToSquared(p.pos) < 6.25) {
            if (speedMag > 10) {
              p.takeDamage(100, p.pos, this.vel, isPlayerAction);
              if (isPlayerAction) camera.position.add(new THREE.Vector3((Math.random() - 0.5), (Math.random() - 0.5), 0));
            } else if (speedMag > 2) {
              p.vel.add(this.vel.clone().multiplyScalar(0.5)); p.vel.y = Math.max(p.vel.y, 5);
            }
          }
        }
        if (!isPlayerAction && !currentVehicle && this.pos.distanceToSquared(player.pos) < 6.25) {
          if (speedMag > 10) {
            takeDamage(15);
            if (playerHealth <= 0) gameOver();
            player.vel.add(this.vel.clone().multiplyScalar(0.5)); player.vel.y = Math.max(player.vel.y, 8);
            camera.position.add(new THREE.Vector3((Math.random() - 0.5) * 2, (Math.random() - 0.5) * 2, 0));
          } else if (speedMag > 2) {
            player.vel.add(this.vel.clone().multiplyScalar(0.5)); player.vel.y = Math.max(player.vel.y, 4);
          }
        }
        // Cop car ramming player's vehicle
        if (!isPlayerAction && currentVehicle && !currentVehicle.isDead && (this.type === 'COP' || this.type === 'ARMY' || this.type === 'TANK') && this.pos.distanceToSquared(currentVehicle.pos) < 10) {
          let now = Date.now();
          if (speedMag > 3 && now - this.lastRam > 500) {
            this.lastRam = now;
            let ramDmg = this.type === 'TANK' ? 25 : (this.type === 'ARMY' ? 15 : 8);
            currentVehicle.takeDamage(ramDmg, false);
            currentVehicle.voxelGroup.damageAtLocal(new THREE.Vector3(0, 0.3, 1.5), 1.0, currentVehicle.mesh.matrixWorld, this.vel);
            currentVehicle.ramHits++;
            // Nudge player's car and bounce cop back
            let pushDir = currentVehicle.pos.clone().sub(this.pos).normalize();
            currentVehicle.vel.add(pushDir.clone().multiplyScalar(speedMag * 0.5));
            currentVehicle.vel.y = Math.max(currentVehicle.vel.y, 2);
            this.vel.add(pushDir.clone().multiplyScalar(-speedMag * 0.3));
            // Camera shake
            camera.position.add(new THREE.Vector3((Math.random() - 0.5) * 2, (Math.random() - 0.5) * 2, 0));
            // Slow cop after ramming
            this.vel.multiplyScalar(0.3);
            // After 10 ram hits, car starts burning
            if (currentVehicle.ramHits >= 10 && !currentVehicle.burning) {
              currentVehicle.burning = true;
              showPhoneMessage("Your car is on fire! Get out NOW!", 5000);
            }
          }
        }
        this.pos.set(this.pos.x + stepX, nextY, this.pos.z + stepZ);
        this.mesh.position.copy(this.pos);
        this.mesh.rotation.y = this.yaw;
        this.mesh.rotation.x = this.vel.y * 0.02;
        // Body roll during drifts/turns
        let targetRoll = (this.driftAngle || 0) * -0.8;
        this.mesh.rotation.z = this.mesh.rotation.z * 0.85 + targetRoll * 0.15; // Smooth lerp
      }
      takeDamage(amount, isPlayerAction = false) {
        this.health -= amount;
        if (this.health <= 0 && !this.isDead) {
          this.isDead = true;
          if (isPlayerAction && this !== currentVehicle) { 
            score += 100; addChaos(this.type === 'COP' || this.type === 'ARMY' || this.type === 'TANK' ? 100 : 50);
            if (this.type === 'COP' || this.type === 'ARMY' || this.type === 'TANK') {
              copsKilled++;
              if (copsKilled >= 12 && wantedLevel < 5) setWantedLevel(5);
              else if (copsKilled >= 8 && wantedLevel < 4) setWantedLevel(4);
              else if (copsKilled >= 4 && wantedLevel < 3) setWantedLevel(3);
            }
            updateHUD();
          }
          this.voxelGroup.destroyCompletely();
          if (isPlayerAction && this !== currentVehicle) {
            spawnCashPickup(this.pos.x, this.pos.y, this.pos.z, 500);
            // Mission 4: Destroy 5 cars - any car counts
            if (missionIndex === 3 && mission.state === 'DESTROY_CARS') {
              carsDestroyedCount++;
              updateCarCounter();
              if (carsDestroyedCount >= CARS_NEEDED) triggerMissionSuccess();
            }
          }
          if (this === currentVehicle) {
            currentVehicle = null;
            player.pos.copy(this.pos).add(new THREE.Vector3(2, 2, 0));
            player.group.visible = true;
          }
        }
        if (this === currentVehicle) updateHUD();
      }
      dispose() { scene.remove(this.mesh); }
    }

    class Pedestrian extends RiggedCharacter {
      constructor(type, x, z) {
        super(type, type === 'COP' ? 0x0000ff : (type === 'ARMY' ? 0x3b4d2e : Math.random() * 0xffffff));
        this.pos = new THREE.Vector3(x, 1, z); this.vel = new THREE.Vector3();
        this.yaw = Math.random() * Math.PI * 2; this.pitch = 0;
        this.health = type === 'ARMY' ? 150 : (type === 'COP' ? 80 : 30); 
        this.isDead = false; this.lastShot = 0;
        scene.add(this.group);
      }
      update(dt) {
        if (this.isDead) return;
        let blockBelow = getBlock(this.pos.x, this.pos.y - 0.5, this.pos.z);
        let blockAt = getBlock(this.pos.x, this.pos.y, this.pos.z);
        let inWater = (blockBelow === TYPES.WATER || blockAt === TYPES.WATER);
        this.vel.y -= (inWater ? 5 : 40) * dt;
        
        let floorY = -5;
        for (let y = Math.floor(this.pos.y + 1); y >= -5; y--) {
          let b = getBlock(this.pos.x, y, this.pos.z);
          if (b !== TYPES.EMPTY && b !== TYPES.WATER) { floorY = y; break; }
        }
        
        if (this.type === 'COP' || this.type === 'ARMY') {
          let targetPos = currentVehicle ? currentVehicle.pos : player.pos;
          let distSq = this.pos.distanceToSquared(targetPos);
          let playerHidden = isPlayerHidden();

          if (wantedLevel > 0 && !playerHidden && distSq < 6400) {
            // Slow approach like Minecraft skeletons - shamble toward player
            if (distSq > 49) {
              let dir = targetPos.clone().sub(this.pos).normalize();
              let speed = inWater ? 2 : (this.type === 'ARMY' ? 5 : 3.5) * (isMobileDevice ? 0.65 : 1.0);
              this.vel.x = dir.x * speed; this.vel.z = dir.z * speed;
              this.yaw = Math.atan2(-dir.x, -dir.z);
            } else {
              // Stop and shoot when close enough
              this.vel.x *= 0.8; this.vel.z *= 0.8;
            }

            // Slow fire rate like skeleton arrows
            let fireRate = this.type === 'ARMY' ? 1800 : 2500;
            let fireRange = this.type === 'ARMY' ? 1600 : 900;
            let bulletDmg = this.type === 'ARMY' ? 80 : 40;
            if (Date.now() - this.lastShot > fireRate && distSq < fireRange) {
              let dir = targetPos.clone().sub(this.pos).normalize();
              // Add inaccuracy - cops don't have perfect aim
              dir.x += (Math.random() - 0.5) * 0.3;
              dir.z += (Math.random() - 0.5) * 0.3;
              dir.normalize();
              let bulletOrigin;
              if (this.gunGroup) { bulletOrigin = new THREE.Vector3(); this.gunGroup.children[0].getWorldPosition(bulletOrigin); }
              else { bulletOrigin = this.pos.clone().add(new THREE.Vector3(0, 1.5, 0)); }
              projectiles.push(new Projectile(bulletOrigin, dir, false, bulletDmg));
              this.lastShot = Date.now();
            }
          } else {
            // Wander aimlessly when no wanted level, player hidden, or player far away
            if (Math.random() < 0.015) this.yaw += (Math.random() - 0.5) * Math.PI;
            let fwd = new THREE.Vector3(-Math.sin(this.yaw), 0, -Math.cos(this.yaw));
            let wanderSpeed = inWater ? 1 : 2;
            this.vel.x = fwd.x * wanderSpeed; this.vel.z = fwd.z * wanderSpeed;
          }
        } else if (this.type === 'ROBBER' && this.state === 'ROBBING') {
          let dir = mission.target.clone().sub(this.pos).normalize();
          this.vel.x = dir.x * 12; this.vel.z = dir.z * 12;
          this.yaw = Math.atan2(-dir.x, -dir.z);
          if (this.pos.distanceToSquared(mission.target) < 16) {
            this.state = 'ESCAPED'; this.isDead = true; this.group.visible = false;
            triggerMissionSuccess();
          }
        } else if (this.stationary) {
          // Stationary NPC (bank teller, shopkeeper) - just stand in place
          this.vel.x = 0; this.vel.z = 0;
          this.animate(dt, 0);
          this.group.position.copy(this.pos);
          this.group.rotation.y = this.yaw;
          return;
        } else {
          // Civilians prefer sidewalks
          let pxMod = Math.abs(this.pos.x) % CHUNK_SIZE;
          let pzMod = Math.abs(this.pos.z) % CHUNK_SIZE;
          let onSidewalk = (pxMod >= ROAD_WIDTH && pxMod < ROAD_WIDTH + 2) || (pxMod > CHUNK_SIZE - 2) ||
                           (pzMod >= ROAD_WIDTH && pzMod < ROAD_WIDTH + 2) || (pzMod > CHUNK_SIZE - 2);

          if (onSidewalk) {
            // Walk along sidewalk direction with occasional turns
            if (Math.random() < 0.005) this.yaw += (Math.random() - 0.5) * Math.PI * 0.5;
          } else {
            // Try to find nearest sidewalk
            if (Math.random() < 0.04) {
              let nearestSidewalkX = Math.round(this.pos.x / CHUNK_SIZE) * CHUNK_SIZE + ROAD_WIDTH + 1;
              let dirToSidewalk = nearestSidewalkX - this.pos.x;
              if (Math.abs(dirToSidewalk) > 2) {
                this.yaw = dirToSidewalk > 0 ? -Math.PI / 2 : Math.PI / 2;
              }
            } else if (Math.random() < 0.02) {
              this.yaw += (Math.random() - 0.5) * Math.PI;
            }
          }
          let fwd = new THREE.Vector3(-Math.sin(this.yaw), 0, -Math.cos(this.yaw));
          let speed = inWater ? 1.5 : 2.5;
          this.vel.x = fwd.x * speed; this.vel.z = fwd.z * speed;
        }
        
        let stepX = this.vel.x * dt, stepZ = this.vel.z * dt;
        let pCheckY = Math.floor(this.pos.y + 0.5), hitWall = false;
        if (getBlock(this.pos.x + stepX, pCheckY, this.pos.z) !== TYPES.EMPTY) {
          if (getBlock(this.pos.x + stepX, pCheckY + 1, this.pos.z) === TYPES.EMPTY) this.pos.y += 1;
          else { stepX = 0; hitWall = true; this.yaw += Math.PI / 2; }
        }
        if (getBlock(this.pos.x, pCheckY, this.pos.z + stepZ) !== TYPES.EMPTY) {
          if (getBlock(this.pos.x, pCheckY + 1, this.pos.z + stepZ) === TYPES.EMPTY) this.pos.y += 1;
          else { stepZ = 0; hitWall = true; this.yaw += Math.PI / 2; }
        }
        // Cops no longer jump over walls aggressively - just turn around like normal peds
        if (hitWall && (this.type === 'COP' || this.type === 'ARMY') && Math.abs(this.vel.y) < 0.1) this.vel.y = 6;
        
        let nextY = this.pos.y + this.vel.y * dt;
        if (nextY - 0.5 <= floorY) { nextY = floorY + 0.5; this.vel.y = 0; }
        this.pos.set(this.pos.x + stepX, nextY, this.pos.z + stepZ);
        this.animate(dt, (Math.abs(stepX) > 0 || Math.abs(stepZ) > 0) ? 5 : 0);
        this.group.position.copy(this.pos); this.group.rotation.y = this.yaw;
      }
      takeDamage(amount, hitPos, hitVel, isPlayerAction = false) {
        this.health -= amount;
        if (this.health <= 0 && !this.isDead) {
          this.isDead = true;
          if (isPlayerAction) { 
            score += (this.type === 'COP' || this.type === 'ARMY' ? 50 : 10); 
            addChaos(this.type === 'COP' || this.type === 'ARMY' ? 100 : 10);

            if (this.type === 'COP' || this.type === 'ARMY') {
              copsKilled++;
              // Gradual escalation - killing lots of cops increases wanted
              if (copsKilled >= 12 && wantedLevel < 5) setWantedLevel(5);
              else if (copsKilled >= 8 && wantedLevel < 4) setWantedLevel(4);
              else if (copsKilled >= 4 && wantedLevel < 3) setWantedLevel(3);
            }
            updateHUD();
          }
          // Drop pickup ‚Äî cops drop guns, civilians drop cash
          if (isPlayerAction) {
            if (this.type === 'COP') {
              spawnWeaponPickup(this.pos.x, this.pos.y, this.pos.z, 'cop_pistol');
            } else if (this.type === 'ARMY') {
              spawnWeaponPickup(this.pos.x, this.pos.y, this.pos.z, 'army_rifle');
            } else {
              spawnCashPickup(this.pos.x, this.pos.y, this.pos.z, 50);
            }
          }
          this.spawnDeathParticles(this.pos, hitVel || new THREE.Vector3(0, 10, 0));
        }
      }
      dispose() { scene.remove(this.group); }
    }
    
    class Robber extends Pedestrian {
      constructor(x, z) { super('ROBBER', x, z); this.state = 'WAITING'; }
    }

    function spawnTraffic() {
      vehicles = vehicles.filter(v => {
        if (v === currentVehicle) return true; // Never cull the vehicle the player is driving
        if (v.type === 'PLANE') return true; // Never cull planes ‚Äî always available at airport
        let referencePos = currentVehicle ? currentVehicle.pos : player.pos;
        let maxDist = CHUNK_SIZE * CHUNK_SIZE * 9;
        if (v.pos.distanceToSquared(referencePos) > maxDist) { v.dispose(); return false; }
        return true;
      });
      peds = peds.filter(p => {
        if (p.stationary) return true; // Never cull stationary NPCs (teller, shopkeeper)
        if (p.pos.distanceToSquared(player.pos) > CHUNK_SIZE * CHUNK_SIZE * 9 || p.isDead) { p.dispose(); return false; }
        return true;
      });
      while (vehicles.length < 25) {
        let r = CHUNK_SIZE + Math.random() * CHUNK_SIZE * 2, angle = Math.random() * Math.PI * 2;
        let cx = player.pos.x + Math.cos(angle) * r, cz = player.pos.z + Math.sin(angle) * r;
        // Don't spawn civilian cars in airport zone
        let spawnZone = getZone(cx, cz);
        if (spawnZone === 'AIRPORT' || spawnZone === 'OCEAN') continue;
        let roadX = Math.round(cx / CHUNK_SIZE) * CHUNK_SIZE;
        let v = new Vehicle('CIVILIAN', roadX + (Math.random() > 0.5 ? 2 : -2), cz, Math.random() * 0xffffff);
        // 40% of spawned cars are parked (stationary, can be driven)
        if (Math.random() < 0.4) {
          v.parked = true;
          v.vel.set(0, 0, 0);
          // Park slightly off center of road
          v.pos.x = roadX + (Math.random() > 0.5 ? 4 : -4);
        }
        vehicles.push(v);
      }
      // Spawn planes at airport ‚Äî respawn dead ones too
      let alivePlanes = vehicles.filter(v => v.type === 'PLANE' && !v.isDead);
      // Remove dead planes
      vehicles.filter(v => v.type === 'PLANE' && v.isDead).forEach(dp => { dp.dispose(); });
      vehicles = vehicles.filter(v => !(v.type === 'PLANE' && v.isDead));
      if (alivePlanes.length < 3) {
        for (let i = alivePlanes.length; i < 3; i++) {
          let px = AIRPORT_X - 80 + i * 60;
          let pz = AIRPORT_Z + 9;
          let p = new Vehicle('PLANE', px, pz, 0xffffff);
          p.parked = true;
          vehicles.push(p);
        }
      }
      while (peds.filter(p => p.type === 'CIVILIAN').length < 20) {
        let r = CHUNK_SIZE / 2 + Math.random() * CHUNK_SIZE, angle = Math.random() * Math.PI * 2;
        peds.push(new Pedestrian('CIVILIAN', player.pos.x + Math.cos(angle) * r, player.pos.z + Math.sin(angle) * r));
      }
    }

    let carparkCarsSpawned = false;
    function spawnCarparkCars() {
      if (carparkCarsSpawned) return;
      let ck = '4,-1';
      if (!activeChunks.has(ck)) return;
      carparkCarsSpawned = true;
      let baseX = CARPARK_POS.x, baseZ = CARPARK_POS.z;
      let floors = [2, 7, 12, 17, 22, 27];
      let colors = [0xcc2222, 0x2244aa, 0xeeeeee, 0x222222, 0xffcc00, 0x44aa44, 0x884488, 0xdd8800, 0xff6600, 0x009999, 0x990099, 0xcccccc];
      for (let fi = 0; fi < floors.length; fi++) {
        // Multiple rows of cars per floor ‚Äî 2 rows along Z, each with cars spaced along X
        for (let row = 0; row < 2; row++) {
          let rowZ = baseZ + (row === 0 ? -6 : 4);
          for (let i = 0; i < 4; i++) {
            let carX = baseX - 8 + i * 5;
            let colorIdx = (fi * 8 + row * 4 + i) % colors.length;
            let car = new Vehicle('CIVILIAN', carX, rowZ, colors[colorIdx]);
            car.pos.y = floors[fi]; car.parked = true; car.vel.set(0, 0, 0);
            car.yaw = row === 0 ? 0 : Math.PI;
            car.mesh.position.copy(car.pos);
            if (car.mesh.rotation) car.mesh.rotation.y = car.yaw;
            vehicles.push(car);
          }
        }
      }
    }

    function spawnCop() {
      if (wantedLevel === 0) return;
      let type = wantedLevel >= 4 ? 'ARMY' : 'COP';
      let angle = Math.random() * Math.PI * 2, dist = currentVehicle ? 80 : 50;
      let cx = player.pos.x + Math.cos(angle) * dist, cz = player.pos.z + Math.sin(angle) * dist;
      let maxCopCars = wantedLevel * 2;
      let maxCopPeds = wantedLevel * 3;
      if (currentVehicle || Math.random() > 0.6) {
        if (vehicles.filter(v => v.type === 'COP' || v.type === 'ARMY' || v.type === 'TANK').length < maxCopCars) {
          if (wantedLevel >= 4) {
            vehicles.push(new Vehicle('TANK', Math.round(cx / CHUNK_SIZE) * CHUNK_SIZE + 2, cz, 0x3b4d2e));
          } else {
            vehicles.push(new Vehicle(type, Math.round(cx / CHUNK_SIZE) * CHUNK_SIZE + 2, cz, type === 'ARMY' ? 0x3b4d2e : 0x111111));
          }
        }
      } else {
        if (peds.filter(p => (p.type === 'COP' || p.type === 'ARMY') && !p.isDead).length < maxCopPeds) {
          peds.push(new Pedestrian(type, cx, cz));
        }
      }
    }

    function isCopNearby() {
      let targetPos = currentVehicle ? currentVehicle.pos : player.pos;
      for (let p of peds) { if ((p.type === 'COP' || p.type === 'ARMY') && !p.isDead && p.pos.distanceToSquared(targetPos) < 2500) return true; }
      for (let v of vehicles) { if ((v.type === 'COP' || v.type === 'ARMY' || v.type === 'TANK') && !v.isDead && v.pos.distanceToSquared(targetPos) < 2500) return true; }
      return false;
    }

    function isPlayerHidden() {
      // Player is hidden if inside a building (block above them) or underground
      let blockAbove = getBlock(player.pos.x, player.pos.y + 3, player.pos.z);
      let blockAbove2 = getBlock(player.pos.x, player.pos.y + 6, player.pos.z);
      if (blockAbove !== TYPES.EMPTY || blockAbove2 !== TYPES.EMPTY) return true;
      // Also hidden if enclosed by blocks on all 4 sides (player-built shelter)
      let px = player.pos.x, py = player.pos.y, pz = player.pos.z;
      let wallN = getBlock(px, py + 1, pz - 2) !== TYPES.EMPTY;
      let wallS = getBlock(px, py + 1, pz + 2) !== TYPES.EMPTY;
      let wallE = getBlock(px + 2, py + 1, pz) !== TYPES.EMPTY;
      let wallW = getBlock(px - 2, py + 1, pz) !== TYPES.EMPTY;
      if (wallN && wallS && wallE && wallW) return true;
      return false;
    }

    function showCrimeAlert() {
      let overlay = document.getElementById('crime-overlay'), text = document.getElementById('crime-text');
      overlay.style.display = 'block'; text.style.display = 'block';
      document.getElementById('wanted-level').classList.add('cop-flash');
      setTimeout(() => { overlay.style.display = 'none'; text.style.display = 'none'; }, 2000);
    }

    function showEvadeMessage() {
      if (evadingMessage) return;
      evadingMessage = true;
      showPhoneMessage("You've lost the cops! Laying low...", 4000);
      document.getElementById('wanted-level').classList.remove('cop-flash');
      setTimeout(() => { evadingMessage = false; }, 5000);
    }

    function setWantedLevel(level) {
      if (level > wantedLevel) showCrimeAlert();
      wantedLevel = level;
      wantedTimer = 25;
      updateHUD();
      // Don't mass-spawn cops - they arrive gradually via copSpawnTimer
    }

    function addChaos(amount) {
      // Only ignore very minor block destruction without witness
      let witnessed = isCopNearby();
      if (!witnessed && amount < 5) return;
      chaos += amount; let old = wantedLevel;
      if (chaos > 3000) wantedLevel = 5; else if (chaos > 1500) wantedLevel = 4;
      else if (chaos > 500) wantedLevel = 3; else if (chaos > 200) wantedLevel = 2; else if (chaos > 80) wantedLevel = 1;
      if (wantedLevel > old) {
        setWantedLevel(wantedLevel);
      }
    }

    function updateHUD() {
      document.getElementById('score-display').innerText = "$" + score;
      let healthPct = Math.max(0, (playerHealth / maxHealth) * 100);
      let healthFill = document.getElementById('health-fill');
      healthFill.style.width = healthPct + "%";
      healthFill.style.background = healthPct < 25 ? '#ff2222' : (healthPct < 50 ? '#ff6600' : '#e53935');
      healthFill.style.animation = healthPct < 25 ? 'pulse 0.5s infinite' : 'none';
      if (currentVehicle) {
        document.getElementById('car-hud').style.display = 'block';
        document.getElementById('car-health-fill').style.width = Math.max(0, (currentVehicle.health / currentVehicle.maxHealth) * 100) + "%";
        document.getElementById('nos-fill').style.width = currentVehicle.nos + "%";
      } else document.getElementById('car-hud').style.display = 'none';
      for (let i = 1; i <= 5; i++) document.getElementById("s" + i).style.color = (i <= wantedLevel) ? 'gold' : 'rgba(255,255,255,0.3)';
      // Crosshair: show only in shoot mode (not build mode, not in non-weapon vehicles)
      let ch = document.getElementById('crosshair');
      if (ch) {
        let showCrosshair = !buildMode && !isPaused && isPlaying;
        // In vehicle: only show for tank (has weapon), not for cars/planes
        if (currentVehicle && currentVehicle.type !== 'TANK') showCrosshair = false;
        ch.style.display = showCrosshair ? 'block' : 'none';
      }
      // Hide demolition progress when not in carpark mission
      if (!(mission.active && mission.state === 'DESTROY_CARPARK'))
        document.getElementById('demolition-progress').style.display = 'none';
      updateBlockCounter();
    }

    function interactVehicle() {
      if (currentVehicle) {
        player.pos.copy(currentVehicle.pos).add(new THREE.Vector3(3, 2, 0));
        player.yaw = currentVehicle.yaw;
        if (currentVehicle.type === 'PLANE') currentVehicle.parked = true;
        currentVehicle = null;
        updateHUD(); player.group.visible = true;
      } else {
        for (let v of vehicles) {
          let enterDist = v.type === 'PLANE' ? 625 : 25;
          if (!v.isDead && player.pos.distanceToSquared(v.pos) < enterDist) {
            currentVehicle = v; v.parked = false;
            updateHUD(); player.group.visible = false;
            if (v.type === 'TANK') { tankAimYaw = v.yaw; tankAimPitch = 0; }
            // Mission 2: steal car detection
            if (missionIndex === 1 && mission.state === 'STEAL_CAR') {
              mission.state = 'DRIVE_TO_ALLEY';
              mission.target.copy(ALLEY_POS);
              setWantedLevel(2);
              document.getElementById('objective-text').innerText = 'DRIVE TO THE SAFE ZONE';
              showPhoneMessage("Boss: Good, you got wheels. Floor it to the safe house out west. Lose those cops!", 15000);
            }
            // Mission 7: steal tank detection
            if (missionIndex === 6 && mission.state === 'STEAL_TANK' && v.type === 'TANK') {
              mission.state = 'DRIVE_TO_ISLAND';
              mission.target.set(ISLAND_X, 1, ISLAND_Z);
              document.getElementById('objective-text').innerText = 'DRIVE TANK TO THE ISLAND';
              showPhoneMessage("Boss: You got a tank! Now drive it to the island. Watch out for the army on your tail!", 15000);
            }
            // Mission 6: steal plane detection
            if (missionIndex === 5 && mission.state === 'GO_TO_AIRPORT' && v.type === 'PLANE') {
              mission.state = 'FLY_TO_ISLAND';
              mission.target.set(ISLAND_X, 1, ISLAND_Z);
              document.getElementById('objective-text').innerText = 'FLY TO THE ISLAND';
              showPhoneMessage("Boss: You're in! Fly to my private island! Follow the yellow marker.", 15000);
            }
            // Any plane entry: show controls overlay and hint
            if (v.type === 'PLANE' && !(missionIndex === 5 && mission.state === 'FLY_TO_ISLAND')) {
              if (missionIndex !== 5 || mission.state !== 'FLY_TO_ISLAND') {
                showPhoneMessage("Boss: Nice ride! Fly to the private island if you want!", 8000);
              }
            }
            if (v.type === 'PLANE') {
              // Show clear flight controls on screen
              showPlaneControls();
            }
            break;
          }
        }
      }
    }

    function gameOver() {
      // Don't show death screen if mission success is showing
      if (mission.state === 'SUCCESS') return;
      isPlaying = false; isPaused = true;
      try { document.exitPointerLock(); } catch(e) {}
      if (isMobileDevice) document.getElementById('mobile-controls').style.display = 'none';
      let restartMission = Math.max(0, missionIndex > 0 ? missionIndex - 1 : 0);
      // If current mission was in progress, restart it; if between missions restart last completed
      let restartIdx = mission.active ? missionIndex : restartMission;
      document.getElementById('start-screen').style.display = 'flex';
      document.getElementById('start-screen').innerHTML =
        '<h1 style="color:red; font-size:64px; text-shadow:4px 4px #000; letter-spacing: 5px;">WASTED</h1>' +
        '<p style="font-size: 24px;">Score: $' + score + ' <br> Wanted: ' + wantedLevel + ' Stars</p>' +
        '<button class="play-btn" id="retry-btn">RETRY MISSION ' + (restartIdx + 1) + '</button>';
      let retryHandler = () => {
        document.getElementById('start-screen').style.display = 'none';
        // Reset player state
        playerHealth = maxHealth; armorHP = 0;
        if (player.armorMesh) player.armorMesh.visible = false;
        wantedLevel = 0; chaos = 0; copsKilled = 0; wantedTimer = 20;
        if (currentVehicle) { currentVehicle = null; player.group.visible = true; }
        player.pos.set(0, 3, 0); player.vel.set(0, 0, 0);
        updateHUD();
        isPaused = false;
        isPlaying = true;
        startMission(restartIdx);
        if (!isMobileDevice) renderer.domElement.requestPointerLock();
        if (isMobileDevice) document.getElementById('mobile-controls').style.display = 'block';
      };
      document.getElementById('retry-btn').onclick = retryHandler;
      document.getElementById('retry-btn').addEventListener('touchstart', (e) => { e.preventDefault(); retryHandler(); });
    }

    let lookTouchId = null, lastLookX = 0, lastLookY = 0;

    function fireWeapon() {
      if (!isPlaying) return;
      if (currentVehicle && currentVehicle.type !== 'TANK') return;
      hideTutorial();

      // Tank shooting
      if (currentVehicle && currentVehicle.type === 'TANK') {
        let now = Date.now();
        if (now - lastTankShot < 500) return; // Fire rate limit
        lastTankShot = now;
        let camDir = new THREE.Vector3(); camera.getWorldDirection(camDir);
        let bulletOrigin = currentVehicle.voxelGroup.getBarrelTipWorld();
        let proj = new Projectile(bulletOrigin, camDir, true, 200);
        proj.isRocket = true;
        proj.mesh.scale.set(2, 2, 2);
        proj.mesh.material.color.setHex(0xff8800);
        projectiles.push(proj);
        camera.position.add(new THREE.Vector3((Math.random() - 0.5) * 1.5, (Math.random() - 0.5) * 0.5, 0));
        return;
      }

      // On-foot shooting ‚Äî use current weapon stats
      if (buildMode) return; // Can't shoot in build mode
      let now = Date.now();
      let wDef = weaponIndex >= 0 ? playerWeapons[weaponIndex] : null;
      let fireRate = wDef ? wDef.fireRate : 200;
      if (now - lastFireTime < fireRate) return;
      lastFireTime = now;

      let camDir = new THREE.Vector3(); camera.getWorldDirection(camDir);
      let hitPoint = camera.position.clone().add(camDir.multiplyScalar(60));
      let startPos = player.pos.clone().add(new THREE.Vector3(0, 1.5, 0));
      let trueAimDir = hitPoint.sub(startPos).normalize();
      startPos.add(trueAimDir.clone().multiplyScalar(0.8));
      let proj = new Projectile(startPos, trueAimDir, true);
      if (wDef && wDef.isRocket) {
        proj.isRocket = true;
        proj.mesh.scale.set(2, 2, 2);
        proj.mesh.material.color.setHex(wDef.projColor);
      }
      projectiles.push(proj);
    }

    let mouseDownTime = 0;
    function throwGrenade() {
      if (grenadeCount <= 0 || !isPlaying || currentVehicle) return;
      grenadeCount--;
      let camDir = new THREE.Vector3(); camera.getWorldDirection(camDir);
      let startPos = player.pos.clone().add(new THREE.Vector3(0, 2, 0));
      // Arc trajectory - throw upward and forward
      let throwDir = camDir.clone().add(new THREE.Vector3(0, 0.4, 0)).normalize();
      let proj = new Projectile(startPos, throwDir, true, 0);
      proj.isGrenade = true; proj.isRocket = true; // Explodes on impact
      proj.mesh.scale.set(1.2, 1.2, 1.2);
      proj.mesh.material.color.setHex(0x556b2f);
      proj.vel.multiplyScalar(0.5); // Slower than bullets
      proj.grenadeTimer = 2.0; // Explodes after 2s if no impact
      projectiles.push(proj);
      showFloatingText('GRENADE! (' + grenadeCount + ' left)', player.pos);
    }

    function setupInput() {
      document.addEventListener('pointerlockchange', () => {
        if (document.pointerLockElement !== renderer.domElement) {
          // If browser loses pointer lock natively (via Escape), auto-pause
          // But not if store is open, success screen is showing, or game is paused
          if (isPlaying && !isPaused && !storeOpen && mission.state !== 'SUCCESS') {
            togglePause();
          }
        }
      });
      
      // Click canvas to unpause/acquire lock
      document.getElementById('game-canvas').addEventListener('click', () => {
        if (isPlaying && isPaused && mission.state !== 'SUCCESS') {
          togglePause(); // Unpause by clicking canvas
        } else if (isPlaying && !isPaused && mission.state !== 'SUCCESS') {
          renderer.domElement.requestPointerLock();
        }
      });

      document.addEventListener('keydown', e => {
        if (!isPlaying) return;
        let k = e.key.toLowerCase();
        if (k === 'p') { togglePause(); return; }
        if (k === 'k') {
          dismissPhone();
          let planeOverlay = document.getElementById('plane-controls-overlay');
          if (planeOverlay) { planeOverlay.style.transition = 'opacity 0.3s'; planeOverlay.style.opacity = '0'; setTimeout(() => planeOverlay.remove(), 300); }
          return;
        }
        if (isPaused) return;

        if (k === 'w' || k === 'z' || k === 'arrowup') { keys.forward = true; hideTutorial(); }
        if (k === 's' || k === 'arrowdown') { keys.backward = true; hideTutorial(); }
        if (k === 'a' || k === 'q' || k === 'arrowleft') { keys.left = true; hideTutorial(); }
        if (k === 'd' || k === 'arrowright') { keys.right = true; hideTutorial(); }
        if (k === ' ') { keys.space = true; hideTutorial(); e.preventDefault(); }
        if (k === 'shift') {
          cycleWeapon();
        }
        // Number keys 1-9 for hotbar selection (only in build mode)
        if (k >= '1' && k <= '9' && buildMode && totalBlocks > 0) {
          selectHotbarSlot(parseInt(k) - 1);
        }
        // E/F keys to cycle block selection left/right in build mode
        if ((k === 'e' || k === 'f') && buildMode && totalBlocks > 0) {
          let dir = k === 'e' ? -1 : 1;
          let startIdx = hotbarIndex;
          for (let i = 0; i < 9; i++) {
            let nextIdx = ((hotbarIndex + dir) % 9 + 9) % 9;
            hotbarIndex = nextIdx;
            selectedBlockType = hotbarSlots[hotbarIndex];
            if (blockInventory[selectedBlockType] > 0) break;
          }
          selectedBlockType = hotbarSlots[hotbarIndex];
          updateBlockCounter(); updateHotbar();
          if (blockInventory[selectedBlockType] > 0) {
            showFloatingText(BLOCK_NAMES[selectedBlockType] + ' (' + blockInventory[selectedBlockType] + ')', player.pos);
          }
        }
        if (k === 'enter') {
          let px = player.pos.x, pz = player.pos.z;
          let inBank = px >= 60 && px <= 84 && pz >= 60 && pz <= 84;
          let inStore = px >= -85 && px <= -62 && pz >= 12 && pz <= 30;
          if (mission.state === 'GO_TO_BANK' && inBank) {
            robBank();
          } else if (inStore && (missionIndex >= 2 || playerInventory.has('store_unlocked'))) {
            openStore();
            if (missionIndex === 2 && (mission.state === 'GO_TO_STORE' || mission.state === 'ENTER_STORE')) mission.state = 'BUY_WEAPON';
          } else {
            interactVehicle();
          }
          hideTutorial();
        }
      });
      document.addEventListener('keyup', e => {
        let k = e.key.toLowerCase();
        if (k === 'w' || k === 'z' || k === 'arrowup') keys.forward = false;
        if (k === 's' || k === 'arrowdown') keys.backward = false;
        if (k === 'a' || k === 'q' || k === 'arrowleft') keys.left = false;
        if (k === 'd' || k === 'arrowright') keys.right = false;
        if (k === ' ') keys.space = false;
      });
      document.addEventListener('mousemove', e => {
        if (!isPlaying || isPaused) return;
        if (document.pointerLockElement === renderer.domElement || isMouseDown) {
          if (currentVehicle && currentVehicle.type === 'TANK') {
            tankAimYaw -= e.movementX * 0.002;
            tankAimPitch -= e.movementY * 0.002;
            tankAimPitch = Math.max(-Math.PI / 4, Math.min(Math.PI / 6, tankAimPitch));
          } else {
            player.yaw -= e.movementX * 0.002;
            player.pitch -= e.movementY * 0.002;
            player.pitch = Math.max(buildMode ? -1.565 : -Math.PI / 2.05, Math.min(buildMode ? 1.565 : Math.PI / 2.05, player.pitch));
          }
        }
      });
      document.addEventListener('mousedown', e => {
        if (isPaused) return;
        if (e.button === 0) {
          isMouseDown = true;
          mouseDownTime = Date.now();
          if (document.pointerLockElement === renderer.domElement) {
            if (buildMode && !currentVehicle) {
              // In build mode: left-click places a block
              placeBlock();
            }
            else if (currentVehicle && currentVehicle.type === 'TANK') fireWeapon();
            else if (!currentVehicle) fireWeapon();
          }
        }
      });
      document.addEventListener('mouseup', e => {
        if (isPaused) return;
        if (e.button === 0) {
          let holdTime = Date.now() - mouseDownTime;
          if (holdTime > 500 && grenadeCount > 0 && !currentVehicle && !buildMode) throwGrenade();
          isMouseDown = false;
          cancelMining();
        }
      });
      // Prevent right-click context menu
      document.addEventListener('contextmenu', e => { e.preventDefault(); });
      // Scroll wheel to cycle hotbar slots (only in build mode)
      document.addEventListener('wheel', e => {
        if (!isPlaying || isPaused || !buildMode || totalBlocks <= 0) return;
        let dir = e.deltaY > 0 ? 1 : -1;
        for (let i = 0; i < 9; i++) {
          hotbarIndex = ((hotbarIndex + dir) % 9 + 9) % 9;
          if (blockInventory[hotbarSlots[hotbarIndex]] > 0) break;
        }
        selectedBlockType = hotbarSlots[hotbarIndex];
        updateBlockCounter(); updateHotbar();
        showFloatingText(BLOCK_NAMES[selectedBlockType] + ' (' + blockInventory[selectedBlockType] + ')', player.pos);
      });
    }

    function setupTouch() {
      const joy = document.getElementById('joystick-area'), knob = document.getElementById('joystick-knob');
      joy.addEventListener('touchstart', handleTouch, { passive: false });
      joy.addEventListener('touchmove', handleTouch, { passive: false });
      joy.addEventListener('touchend', () => {
        touchMove.set(0, 0); knob.style.transform = "translate(0px,0px)";
      });
      function handleTouch(e) {
        e.preventDefault(); hideTutorial();
        const rect = joy.getBoundingClientRect(), touch = e.touches[0];
        let dx = touch.clientX - (rect.left + rect.width / 2), dy = touch.clientY - (rect.top + rect.height / 2);
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist > 35) { dx = (dx / dist) * 35; dy = (dy / dist) * 35; }
        knob.style.transform = "translate(" + dx + "px, " + dy + "px)";
        touchMove.x = dx / 35; touchMove.y = dy / 35;
      }
      const canvas = document.getElementById('game-canvas');
      let lookTouchStartX = 0, lookTouchStartY = 0, lookTouchStartTime = 0, lookTouchMoved = false;
      canvas.addEventListener('touchstart', (e) => {
        if (!isPlaying) return;
        for (let i = 0; i < e.changedTouches.length; i++) {
          let t = e.changedTouches[i];
          if (t.clientX > window.innerWidth / 2 && lookTouchId === null) {
            lookTouchId = t.identifier; lastLookX = t.clientX; lastLookY = t.clientY;
            lookTouchStartX = t.clientX; lookTouchStartY = t.clientY;
            lookTouchStartTime = Date.now(); lookTouchMoved = false;
          }
        }
      }, { passive: false });
      canvas.addEventListener('touchmove', (e) => {
        if (!isPlaying) return;
        e.preventDefault();
        for (let i = 0; i < e.changedTouches.length; i++) {
          let t = e.changedTouches[i];
          if (t.identifier === lookTouchId) {
            let dx = t.clientX - lookTouchStartX, dy = t.clientY - lookTouchStartY;
            if (Math.sqrt(dx * dx + dy * dy) > 10) lookTouchMoved = true;
            if (currentVehicle && currentVehicle.type === 'TANK') {
              tankAimYaw -= (t.clientX - lastLookX) * 0.01;
              tankAimPitch -= (t.clientY - lastLookY) * 0.01;
              tankAimPitch = Math.max(-Math.PI / 4, Math.min(Math.PI / 6, tankAimPitch));
            } else {
              player.yaw -= (t.clientX - lastLookX) * 0.01; player.pitch -= (t.clientY - lastLookY) * 0.01;
              player.pitch = Math.max(buildMode ? -1.565 : -Math.PI / 2.05, Math.min(buildMode ? 1.565 : Math.PI / 2.05, player.pitch));
            }
            lastLookX = t.clientX; lastLookY = t.clientY;
          }
        }
      }, { passive: false });
      canvas.addEventListener('touchend', (e) => {
        for (let i = 0; i < e.changedTouches.length; i++) {
          let t = e.changedTouches[i];
          if (t.identifier === lookTouchId) {
            // Tap-to-shoot or long-hold for grenade
            let touchDuration = Date.now() - lookTouchStartTime;
            if (!lookTouchMoved && touchDuration < 300) {
              if (buildMode && !currentVehicle) { placeBlock(); }
              else if (currentVehicle && currentVehicle.type === 'TANK') { fireWeapon(); }
              else if (currentVehicle) { /* NOS handled by isMouseDown in game loop */ }
              else { fireWeapon(); }
            } else if (!lookTouchMoved && touchDuration > 500 && grenadeCount > 0 && !currentVehicle && !buildMode) {
              throwGrenade();
            }
            lookTouchId = null;
          }
        }
      });
      document.getElementById('btn-interact').addEventListener('touchstart', (e) => {
        e.preventDefault(); hideTutorial();
        let px = player.pos.x, pz = player.pos.z;
        let inBank = px >= 60 && px <= 84 && pz >= 60 && pz <= 84;
        let inStore = px >= -85 && px <= -62 && pz >= 12 && pz <= 30;
        if (mission.state === 'GO_TO_BANK' && inBank) { robBank(); }
        else if (inStore && (missionIndex >= 2 || playerInventory.has('store_unlocked'))) {
          openStore();
          if (missionIndex === 2 && (mission.state === 'GO_TO_STORE' || mission.state === 'ENTER_STORE')) mission.state = 'BUY_WEAPON';
        } else { interactVehicle(); }
      });
      document.getElementById('btn-jump').addEventListener('touchstart', (e) => { e.preventDefault(); hideTutorial(); keys.space = true; });
      document.getElementById('btn-jump').addEventListener('touchend', (e) => { e.preventDefault(); keys.space = false; });
      // Mobile build button
      document.getElementById('btn-build').addEventListener('touchstart', (e) => {
        e.preventDefault();
        if (currentVehicle) return; // No build mode in vehicles
        if (totalBlocks > 0) {
          buildMode = !buildMode;
          // Auto-select first available block when entering build mode
          if (buildMode) {
            if (!blockInventory[selectedBlockType] || blockInventory[selectedBlockType] <= 0) {
              for (let i = 0; i < hotbarSlots.length; i++) {
                if (blockInventory[hotbarSlots[i]] > 0) {
                  hotbarIndex = i; selectedBlockType = hotbarSlots[i]; break;
                }
              }
            } else {
              let idx = hotbarSlots.indexOf(selectedBlockType);
              if (idx >= 0) hotbarIndex = idx;
            }
          }
          updateBlockCounter(); updateHotbar(); updateHUD();
          showFloatingText(buildMode ? 'BUILD: ' + (BLOCK_NAMES[selectedBlockType] || 'Block') : 'BUILD MODE OFF', player.pos);
        } else {
          showFloatingText('No blocks! Destroy buildings to collect.', player.pos);
        }
      });

    }

    function updateWaypointUI() {
      let distEl = document.getElementById('waypoint-dist');
      // Only show arrow when mission is active and phone has appeared (tutorial dismissed)
      let phoneShown = !pendingPhoneMessage && document.getElementById('tutorial-overlay').style.display === 'none';
      let noArrowState = mission.state === 'SUCCESS' || mission.state === 'DONE' || mission.state === 'LANDING_CINEMATIC' || (missionIndex === 3 && mission.state === 'DESTROY_CARS') || (missionIndex === 6 && (mission.state === 'CAUSE_CHAOS' || mission.state === 'STEAL_TANK')) || (missionIndex === 7 && (mission.state === 'COLLECT_BLOCKS' || mission.state === 'BUILD_BARRICADE')) || (missionIndex === 8 && mission.state === 'BUILD_MANSION');
      if (mission.active && !noArrowState && waypointArrow3D && phoneShown) {
        waypointArrow3D.visible = true;
        distEl.style.display = 'block';
        let playerPos = currentVehicle ? currentVehicle.pos : player.pos;
        let dist = Math.floor(mission.target.distanceTo(playerPos));
        distEl.innerText = dist + "m";

        // Update distance label on arrow sprite
        let dc = waypointArrow3D.userData.distCanvas;
        if (dc) {
          let ctx = dc.getContext('2d');
          ctx.clearRect(0, 0, 128, 64);
          ctx.fillStyle = 'rgba(0,0,0,0.7)';
          ctx.fillRect(4, 4, 120, 56);
          ctx.fillStyle = '#ffcc00'; ctx.font = 'bold 36px sans-serif';
          ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
          ctx.fillText(dist + 'm', 64, 34);
          waypointArrow3D.userData.distTex.needsUpdate = true;
        }

        // Position arrow in front of camera, slightly above center (HUD-like)
        let camDir = new THREE.Vector3();
        camera.getWorldDirection(camDir);
        let camRight = new THREE.Vector3();
        camRight.crossVectors(camDir, new THREE.Vector3(0, 1, 0)).normalize();
        let camUp = new THREE.Vector3();
        camUp.crossVectors(camRight, camDir).normalize();

        let arrowPos = camera.position.clone()
          .add(camDir.clone().multiplyScalar(2.5))
          .add(camUp.clone().multiplyScalar(0.7));
        waypointArrow3D.position.copy(arrowPos);
        waypointArrow3D.scale.setScalar(0.5);

        // Arrow model points along +Y; rotate to point toward target
        let dirToTarget = mission.target.clone().sub(arrowPos).normalize();
        let up = new THREE.Vector3(0, 1, 0);
        let quat = new THREE.Quaternion();
        quat.setFromUnitVectors(up, dirToTarget);
        waypointArrow3D.quaternion.copy(quat);
      } else {
        if (waypointArrow3D) waypointArrow3D.visible = false;
        distEl.style.display = 'none';
      }
    }

    function drawMinimap() {
      minimapCtx.clearRect(0, 0, 150, 150);
      const px = currentVehicle ? currentVehicle.pos.x : player.pos.x;
      const pz = currentVehicle ? currentVehicle.pos.z : player.pos.z;
      minimapCtx.save();
      minimapCtx.translate(75, 75);
      minimapCtx.rotate(currentVehicle ? -currentVehicle.yaw : -player.yaw);
      if (mission.active && mission.state === 'GO_TO_BANK') {
        let dx = mission.target.x - px, dz = mission.target.z - pz, dist = Math.sqrt(dx * dx + dz * dz);
        minimapCtx.fillStyle = 'yellow'; minimapCtx.strokeStyle = 'black'; minimapCtx.lineWidth = 2;
        if (dist < 75) {
          minimapCtx.beginPath(); minimapCtx.arc(dx, dz, 8, 0, Math.PI * 2); minimapCtx.fill(); minimapCtx.stroke();
        } else {
          let angle = Math.atan2(dz, dx);
          minimapCtx.save(); minimapCtx.translate(Math.cos(angle) * 68, Math.sin(angle) * 68); minimapCtx.rotate(angle);
          minimapCtx.beginPath(); minimapCtx.moveTo(10, 0); minimapCtx.lineTo(-10, -8); minimapCtx.lineTo(-10, 8);
          minimapCtx.fill(); minimapCtx.stroke(); minimapCtx.restore();
        }
      }
      minimapCtx.translate(-px, -pz);
      for (let x = px - 75; x <= px + 75; x += 3) {
        for (let z = pz - 75; z <= pz + 75; z += 3) {
          let bHigh = getBlock(x, 10, z), bLow = getBlock(x, 1, z), ground = getBlock(x, 0, z), bRail = getBlock(x, 20, z);
          if (bRail === TYPES.RAIL || bRail === TYPES.CONCRETE) { minimapCtx.fillStyle = '#666'; }
          else if (bHigh === TYPES.HIGHWAY) { minimapCtx.fillStyle = '#999'; }
          else if (bLow === TYPES.SIDEWALK) { minimapCtx.fillStyle = '#aaa'; }
          else if (bLow !== TYPES.EMPTY && bLow !== TYPES.ROAD) {
            if (bLow === TYPES.GOLD) minimapCtx.fillStyle = 'yellow';
            else if (bLow === TYPES.BLUE || bLow === TYPES.GLASS_BLUE) minimapCtx.fillStyle = '#5c9bd6';
            else if (bLow === TYPES.RED || bLow === TYPES.BRICK_RED) minimapCtx.fillStyle = '#b3473e';
            else minimapCtx.fillStyle = '#777';
          } else {
            if (ground === TYPES.WATER) minimapCtx.fillStyle = '#2980b9';
            else if (ground === TYPES.GRASS) minimapCtx.fillStyle = '#5c9e31';
            else if (ground === TYPES.ROAD) minimapCtx.fillStyle = '#2c2c2c';
            else continue;
          }
          minimapCtx.fillRect(x - 1.5, z - 1.5, 3, 3);
        }
      }
      let copColor = (Date.now() % 400 < 200) ? 'red' : 'blue';
      minimapCtx.fillStyle = copColor;
      vehicles.filter(v => v.type === 'COP' || v.type === 'ARMY' || v.type === 'TANK').forEach(c => { minimapCtx.beginPath(); minimapCtx.arc(c.pos.x, c.pos.z, 5, 0, Math.PI * 2); minimapCtx.fill(); });
      peds.filter(p => p.type === 'COP' || p.type === 'ARMY').forEach(c => { minimapCtx.beginPath(); minimapCtx.arc(c.pos.x, c.pos.z, 3, 0, Math.PI * 2); minimapCtx.fill(); });
      minimapCtx.restore();
      minimapCtx.fillStyle = 'lime'; minimapCtx.beginPath(); minimapCtx.moveTo(75, 65); minimapCtx.lineTo(82, 80); minimapCtx.lineTo(68, 80); minimapCtx.fill();
    }

    // --- Main Loop ---
    let clock = new THREE.Clock();
    let physicsAccumulator = 0;
    const FIXED_DT = 1 / 60;

    function animate() {
      requestAnimationFrame(animate);
      let frameTime = clock.getDelta();
      if (frameTime > 0.1) frameTime = 0.1;
      
      if (!isPaused) {
        physicsAccumulator += frameTime;
        customUniforms.time.value += frameTime;
        while (physicsAccumulator >= FIXED_DT) {
          if (isPlaying) updateGameLogic(FIXED_DT);
          physicsAccumulator -= FIXED_DT;
        }
      }
      
      // Pre-game cinematic camera spin
      if (!isPlaying) {
        let time = Date.now() * 0.001;
        let spinR = 40, spinH = 30;
        camera.position.set(Math.cos(time * 0.15) * spinR, spinH, Math.sin(time * 0.15) * spinR);
        camera.lookAt(0, 5, 0);
      }
      // Success screen cinematic camera (runs even when paused)
      if (isPlaying && mission.state === 'SUCCESS') {
        let spinDist = 8, spinSpeed = 0.5;
        let time = Date.now() * 0.001;
        let camX = player.pos.x + Math.cos(time * spinSpeed) * spinDist;
        let camZ = player.pos.z + Math.sin(time * spinSpeed) * spinDist;
        camera.position.set(camX, player.pos.y + 4, camZ);
        camera.lookAt(player.pos.clone().add(new THREE.Vector3(0, 2, 0)));
      }
      if (isPlaying && !isPaused) {
        skybox.position.copy(camera.position); drawMinimap();
        // Update dust particles to follow player
        if (window._dustParticles && window._dustPositions) {
          let pp = currentVehicle ? currentVehicle.pos : player.pos;
          window._dustParticles.position.set(pp.x, 0, pp.z);
          let dp = window._dustPositions;
          for (let i = 0; i < dp.length; i += 3) {
            dp[i + 1] += frameTime * (0.3 + Math.sin(i) * 0.2);
            if (dp[i + 1] > 35) dp[i + 1] = 2;
          }
          window._dustParticles.geometry.attributes.position.needsUpdate = true;
        }
      }

      // USE EFFECT COMPOSER INSTEAD OF STANDARD RENDERER
      if (composer) composer.render();
      else renderer.render(scene, camera);
    }

    function updateGameLogic(dt) {
      if (bankMarkerGroup) bankMarkerGroup.rotation.y += 1 * dt;
      if (storeMarkerGroup && storeMarkerGroup.visible) storeMarkerGroup.rotation.y += 1 * dt;
      if (alleyMarkerGroup && alleyMarkerGroup.visible) alleyMarkerGroup.rotation.y += 1 * dt;
      if (carparkMarkerGroup && carparkMarkerGroup.visible) carparkMarkerGroup.rotation.y += 1 * dt;
      // Rotate bank cash wad
      if (bankCashWad && bankCashWad.visible) {
        if (bankCashWad.userData.animating) {
          bankCashWad.userData.animTime += dt;
          let t = Math.min(1, bankCashWad.userData.animTime / 1.0);
          let target = (currentVehicle ? currentVehicle.pos : player.pos).clone().add(new THREE.Vector3(0, 1.5, 0));
          bankCashWad.position.lerpVectors(bankCashWad.userData.startPos, target, t);
          bankCashWad.scale.setScalar(1 - t * 0.8);
          if (t >= 1) { bankCashWad.visible = false; bankCashWad.userData.animating = false; }
        } else { bankCashWad.rotation.y += 2 * dt; bankCashWad.position.y = 6 + Math.sin(Date.now() * 0.002) * 0.3; }
      }
      // Update cash pickups
      updatePickups(dt);
      updateBlockPickups(dt);
      updateWeaponPickups(dt);
      updateGhostBlock();
      updateMining(dt);
      // Auto-fire for automatic weapons (hold mouse to rapid fire)
      if (isMouseDown && !buildMode && !currentVehicle && weaponIndex >= 0) {
        let wDef = playerWeapons[weaponIndex];
        if (wDef && wDef.auto) fireWeapon();
      }

      // Success state handled by animate() camera spin; skip game logic
      if (mission.state === 'SUCCESS') return;

      let moveZ = (keys.forward ? -1 : 0) + (keys.backward ? 1 : 0) + touchMove.y;
      let moveX = (keys.left ? -1 : 0) + (keys.right ? 1 : 0) + touchMove.x;
      if (mission.robber) mission.robber.update(dt);
      updateWaypointUI();

      let targetPos = currentVehicle ? currentVehicle.pos : player.pos;

      // Handle Wanted Decay - hiding, distance, or killing all nearby cops helps evade
      if (wantedLevel > 0) {
        let nearestCopDistSq = Infinity;
        let aliveCopsNearby = 0;
        peds.forEach(p => { if((p.type==='COP'||p.type==='ARMY') && !p.isDead) { let d = p.pos.distanceToSquared(targetPos); nearestCopDistSq = Math.min(nearestCopDistSq, d); if (d < 6400) aliveCopsNearby++; }});
        vehicles.forEach(v => { if((v.type==='COP'||v.type==='ARMY'||v.type==='TANK') && !v.isDead) { let d = v.pos.distanceToSquared(targetPos); nearestCopDistSq = Math.min(nearestCopDistSq, d); if (d < 6400) aliveCopsNearby++; }});

        let hidden = isPlayerHidden();

        if (hidden) {
          wantedTimer -= dt * 4; // Very fast decay when hiding in buildings
          if (!evadingMessage) showEvadeMessage();
        } else if (aliveCopsNearby === 0) {
          wantedTimer -= dt * 3; // Fast decay - killed all nearby cops
        } else if (nearestCopDistSq > 10000) {
          wantedTimer -= dt * 2; // Fast decay - far from cops
        } else if (nearestCopDistSq > 4000) {
          wantedTimer -= dt; // Normal decay
        } else {
          wantedTimer = Math.min(wantedTimer + dt * 0.5, 20); // Slowly build timer when cops close
        }

        // Animate stars flashing when evading
        if (wantedTimer < 15 && (hidden || nearestCopDistSq > 4000)) {
          let starEls = document.querySelectorAll('#wanted-level span');
          let flash = Math.floor(Date.now() / 500) % 2 === 0;
          for (let i = 0; i < wantedLevel; i++) {
            if (starEls[i]) starEls[i].style.opacity = flash ? '1' : '0.3';
          }
        }

        if (wantedTimer <= 0) {
          wantedLevel--;
          wantedTimer = 20;
          chaos = Math.max(0, chaos - 200); // Also reduce chaos
          updateHUD();
          // Despawn some cops/army when stars drop
          let copVehiclesToRemove = 2;
          vehicles = vehicles.filter(v => {
            if ((v.type === 'COP' || v.type === 'ARMY' || v.type === 'TANK') && v !== currentVehicle && copVehiclesToRemove > 0) {
              copVehiclesToRemove--; v.dispose(); return false;
            }
            return true;
          });
          let copPedsToRemove = 3;
          peds = peds.filter(p => {
            if ((p.type === 'COP' || p.type === 'ARMY') && !p.isDead && copPedsToRemove > 0) {
              copPedsToRemove--; p.dispose(); return false;
            }
            return true;
          });
          // Reset star opacity
          document.querySelectorAll('#wanted-level span').forEach(s => s.style.opacity = '1');
          if (wantedLevel === 0) {
            showPhoneMessage("Boss: Heat's dying down. Good work staying out of sight.", 6000);
            copsKilled = 0; chaos = 0; // Reset
            if (mission.state === 'DRIVE_TO_ALLEY') {
              // Mission 2 complete - arrived at alley and lost cops
              triggerMissionSuccess();
            }
          } else {
            showPhoneMessage("Losing the heat... keep it up!", 3000);
          }
        }
      }

      // Mission proximity checks
      let pPos = currentVehicle ? currentVehicle.pos : player.pos;
      // Mission 3: Store proximity phone message - remind to buy rocket launcher
      if (mission.active && mission.state === 'GO_TO_STORE' && !currentVehicle && pPos.distanceToSquared(STORE_POS) < 400) {
        showPhoneMessage(isMobileDevice ? "Boss: You're at the shop. Get inside and buy the Rocket Launcher! Press Shop to enter." : "Boss: You're at the shop. Get inside and buy the Rocket Launcher! Press Enter to enter.", 10000);
        mission.state = 'ENTER_STORE';
      }
      if (mission.active && mission.state === 'DRIVE_TO_ALLEY' && pPos.distanceToSquared(ALLEY_POS) < 225) {
        // Near safe house - set wanted to 0 instantly (safe zone)
        wantedLevel = 0; wantedTimer = 20; chaos = 0; copsKilled = 0; updateHUD();
        document.querySelectorAll('#wanted-level span').forEach(s => { s.style.opacity = '1'; s.style.animation = ''; });
        mission.state = 'AT_SAFE_HOUSE';
        showPhoneMessage("Great job, you made it to the safe house. Now lay low.", 10000);
        setTimeout(() => { if (mission.state === 'AT_SAFE_HOUSE') triggerMissionSuccess(); }, 10000);
      }
      // Mission 5: Carpark block destruction - proximity triggers the mission phase
      if (mission.active && mission.state === 'GO_TO_CARPARK' && pPos.distanceToSquared(CARPARK_POS) < 900) {
        mission.state = 'DESTROY_CARPARK';
        document.getElementById('objective-text').innerText = 'DESTROY THE CAR PARK: 0/200 blocks';
        document.getElementById('demolition-progress').style.display = 'block';
        document.getElementById('demo-fill').style.height = '0%';
        document.getElementById('demo-pct').innerText = '0/200';
        showPhoneMessage("Boss: You're at the carpark. Blast a hole in it! Use your rocket launcher and destroy 200 blocks!", 15000);
      }
      if (mission.active && mission.state === 'FLY_TO_ISLAND' && currentVehicle && currentVehicle.type === 'PLANE') {
        let islandDist = pPos.distanceToSquared(new THREE.Vector3(ISLAND_X, pPos.y, ISLAND_Z));
        // Show approach message when getting close
        if (islandDist < 40000 && !mission._approachShown) {
          mission._approachShown = true;
          showPhoneMessage("Boss: There's the island! Slow down and land on the runway. Descend gently!", 15000);
        }
        // Detect actual landing on island - plane must be low and near island
        let onIslandGround = islandDist < 10000 && currentVehicle.pos.y < 5 && !currentVehicle.isFlying;
        if (onIslandGround && !mission._landingTimer) {
          mission._landingTimer = Date.now();
          showPhoneMessage("Boss: You've touched down! Stay on the island...", 8000);
          document.getElementById('objective-text').innerText = 'STAY ON THE ISLAND - LANDING...';
        }
        if (mission._landingTimer && (islandDist > 10000 || currentVehicle.pos.y > 8)) {
          mission._landingTimer = null; // Left island, reset timer
        }
        if (mission._landingTimer && Date.now() - mission._landingTimer > 5000) {
          // Landed for 5 seconds - success!
          player.pos.copy(currentVehicle.pos).add(new THREE.Vector3(3, 0, 0));
          player.pos.y = currentVehicle.pos.y + 1;
          player.group.visible = true;
          currentVehicle = null;
          triggerMissionSuccess();
        }
      }
      // Mission 7: Tank Heist phases
      if (mission.active && missionIndex === 6) {
        if (mission.state === 'CAUSE_CHAOS' && wantedLevel >= 4) {
          mission.state = 'STEAL_TANK';
          document.getElementById('objective-text').innerText = isMobileDevice ? 'STEAL AN ARMY TANK (Press Drive)' : 'STEAL AN ARMY TANK (Press Enter)';
          showPhoneMessage("Boss: The army's rolling in with tanks! Jack one of those tanks!", 10000);
        }
        if (mission.state === 'STEAL_TANK' && currentVehicle && currentVehicle.type === 'TANK') {
          mission.state = 'DRIVE_TO_ISLAND';
          mission.target.set(ISLAND_X, 1, ISLAND_Z);
          document.getElementById('objective-text').innerText = 'DRIVE TANK TO THE ISLAND';
          showPhoneMessage("Boss: You got a tank! Now drive it to the island. Watch out for the army on your tail!", 15000);
        }
        if (mission.state === 'DRIVE_TO_ISLAND' && currentVehicle && currentVehicle.type === 'TANK') {
          let islandDist = pPos.distanceToSquared(new THREE.Vector3(ISLAND_X, pPos.y, ISLAND_Z));
          if (islandDist < 6400) triggerMissionSuccess();
        }
      }
      // Mission 8: Build a Barricade
      if (mission.active && missionIndex === 7) {
        if (mission.state === 'GO_TO_BARRICADE' && pPos.distanceToSquared(BARRICADE_POS) < 400) {
          mission.state = 'COLLECT_BLOCKS';
          blocksPlacedForMission = 0;
          document.getElementById('objective-text').innerText = 'COLLECT BLOCKS (destroy buildings) then BUILD BARRICADE: 0/20';
          showPhoneMessage("Boss: Good, you're at the spot. Now destroy some buildings to collect blocks, then build a wall across this road! Press SHIFT to swap to build mode, right-click to place blocks.", 20000);
          // Give some starter blocks if player has none
          if (totalBlocks < 5) {
            let starterTypes = [TYPES.BRICK, TYPES.CONCRETE, TYPES.STEEL];
            for (let st of starterTypes) { blockInventory[st] = (blockInventory[st] || 0) + 5; totalBlocks += 5; }
            updateBlockCounter();
            showFloatingText('+15 starter blocks!', player.pos);
          }
        }
        if (mission.state === 'COLLECT_BLOCKS' && totalBlocks >= 20) {
          mission.state = 'BUILD_BARRICADE';
          document.getElementById('objective-text').innerText = 'BUILD BARRICADE: 0/20 blocks';
          showPhoneMessage("Boss: You've got enough blocks! Now build that barricade across the road. Right-click to place blocks!", 15000);
        }
      }

      // Mission 9: Build Your Home
      if (mission.active && missionIndex === 8) {
        if (mission.state === 'GO_TO_ISLAND_BUILD' && !currentVehicle && pPos.distanceToSquared(new THREE.Vector3(ISLAND_X, pPos.y, ISLAND_Z)) < 10000) {
          mission.state = 'BUILD_MANSION';
          blocksPlacedForMission = 0;
          document.getElementById('objective-text').innerText = 'BUILD YOUR MANSION: 0/40 blocks';
          showPhoneMessage("Boss: Welcome home! Use " + (isMobileDevice ? "the Build button" : "SHIFT for build mode, E/F to pick blocks, right-click to place") + ". Build yourself something legendary!", 20000);
          // Give blocks for building
          if (totalBlocks < 40) {
            let buildTypes = [TYPES.BRICK, TYPES.CONCRETE, TYPES.STEEL, TYPES.WOOD, TYPES.GLASS];
            for (let bt of buildTypes) { blockInventory[bt] = (blockInventory[bt] || 0) + 20; totalBlocks += 20; }
            updateBlockCounter(); updateHotbar();
            showFloatingText('+100 building blocks!', player.pos);
          }
        }
      }

      // Victory: detect plane landing on island (any time, any mission)
      if (!gameWon && currentVehicle && currentVehicle.type === 'PLANE' && !currentVehicle.isFlying) {
        let islandDist = pPos.distanceToSquared(new THREE.Vector3(ISLAND_X, pPos.y, ISLAND_Z));
        if (islandDist < 8000) showVictoryScreen();
      }

      if (currentVehicle) {
        document.getElementById('action-msg').style.display = 'none';
        let mAct = document.getElementById('btn-interact');
        mAct.innerText = 'Exit'; mAct.style.display = 'flex';
        let buildBtnV = document.getElementById('btn-build');
        if (buildBtnV) buildBtnV.style.display = 'none';
        // Tank: click = shoot, no NOS. Other vehicles: click = NOS
        let useNOS = currentVehicle.type === 'TANK' ? false : isMouseDown;
        currentVehicle.updatePhysics(dt, -moveZ, moveX, useNOS);
        if (isMouseDown && currentVehicle.type !== 'TANK') updateHUD();
        // Burning car damages player
        if (currentVehicle && currentVehicle.burning) {
          takeDamage(40 * dt);
          if (Math.random() < 0.3) spawnPhysicsParticle(currentVehicle.pos.x + (Math.random() - 0.5) * 2, currentVehicle.pos.y + 0.5, currentVehicle.pos.z + (Math.random() - 0.5) * 2, 'FIRE');
          if (Math.random() < 0.15) spawnPhysicsParticle(currentVehicle.pos.x, currentVehicle.pos.y + 2, currentVehicle.pos.z, 'SMOKE', null, true);
          if (playerHealth <= 0) gameOver();
        }
        // Space makes the car hop/jump
        if (keys.space && currentVehicle.type !== 'PLANE' && Math.abs(currentVehicle.vel.y) < 0.5) {
          currentVehicle.vel.y = 12;
        }
        if (keys.space && currentVehicle.type === 'PLANE') {
          currentVehicle.vel.y += 25 * dt;
        }
        // S key actively descends the plane for landing
        if (keys.backward && currentVehicle.type === 'PLANE' && currentVehicle.isFlying) {
          currentVehicle.vel.y -= 15 * dt;
        }

        if (currentVehicle.type === 'TANK') {
          // Tank camera: mouse-aimed, independent of body
          let aimDir = new THREE.Vector3(
            -Math.sin(tankAimYaw) * Math.cos(tankAimPitch),
            Math.sin(tankAimPitch),
            -Math.cos(tankAimYaw) * Math.cos(tankAimPitch)
          ).normalize();
          let camDist = isMobileDevice ? 10 : 14, camTarget = currentVehicle.pos.clone().add(new THREE.Vector3(0, 3, 0));
          let idealCamPos = camTarget.clone().sub(aimDir.clone().multiplyScalar(camDist));
          idealCamPos = getCameraPos(camTarget, idealCamPos);
          camera.position.lerp(idealCamPos, Math.min(1.0, 10 * dt));
          camera.lookAt(camTarget.clone().add(aimDir.clone().multiplyScalar(50)));
          // Rotate turret to match aim
          if (currentVehicle.voxelGroup.turret) {
            currentVehicle.voxelGroup.turret.rotation.y = tankAimYaw - currentVehicle.yaw;
          }
        } else {
          let speed = currentVehicle.vel.length();
          let isPlane = currentVehicle.type === 'PLANE';
          let camDist = isPlane ? (20 + speed * 0.15) : (isMobileDevice ? (8 + speed * 0.06) : (12 + speed * 0.1));
          let camHeight = isPlane ? (8 + speed * 0.1) : (isMobileDevice ? (3.5 + speed * 0.03) : (5 + speed * 0.05));
          const camOffset = new THREE.Vector3(Math.sin(currentVehicle.yaw) * camDist, camHeight, Math.cos(currentVehicle.yaw) * camDist);
          let camTarget = currentVehicle.pos.clone().add(new THREE.Vector3(0, isPlane ? 3 : 2, 0));
          let idealCamPos = isPlane ? camTarget.clone().add(camOffset) : getCameraPos(camTarget, currentVehicle.pos.clone().add(camOffset));
          camera.position.lerp(idealCamPos, Math.min(1.0, (isPlane ? 6 : 10) * dt));
          camera.lookAt(camTarget);
        }
        updateChunks();
      } else {
        document.getElementById('action-msg').style.display = 'none';
        let mAct = document.getElementById('btn-interact');
        let showMobile = false;

        // Check for Bank Robbery, Store, or Vehicle Interaction
        let px = player.pos.x, pz = player.pos.z;
        let inBank = px >= 60 && px <= 84 && pz >= 60 && pz <= 84;
        let inStore = px >= -85 && px <= -62 && pz >= 12 && pz <= 30;
        if (mission.state === 'GO_TO_BANK' && inBank) {
           document.getElementById('action-msg').innerText = isMobileDevice ? "Press Rob" : "Press Enter to Rob Bank";
           document.getElementById('action-msg').style.display = 'block';
           mAct.innerText = 'Rob'; showMobile = true;
        } else if (inStore && (missionIndex >= 2 || playerInventory.has('store_unlocked'))) {
           document.getElementById('action-msg').innerText = isMobileDevice ? "Press Shop" : "Press Enter to Enter Shop";
           document.getElementById('action-msg').style.display = 'block';
           mAct.innerText = 'Shop'; showMobile = true;
        } else {
           for (let v of vehicles) {
             let enterDist = v.type === 'PLANE' ? 625 : 25;
             if (!v.isDead && player.pos.distanceToSquared(v.pos) < enterDist) {
               let label = v.type === 'PLANE' ? 'Fly Plane' : 'Drive';
               document.getElementById('action-msg').innerText = isMobileDevice ? ("Press " + (v.type === 'PLANE' ? 'Fly' : label)) : ("Press Enter to " + label);
               document.getElementById('action-msg').style.display = 'block';
               mAct.innerText = label; showMobile = true; break;
             }
           }
        }
        mAct.style.display = showMobile ? 'flex' : 'none';
        // Show/hide mobile build button
        let buildBtn = document.getElementById('btn-build');
        if (buildBtn) {
          buildBtn.style.display = 'flex';
          if (buildMode) {
            buildBtn.innerText = 'Shoot';
            buildBtn.style.background = '#cc2222';
          } else {
            buildBtn.innerText = 'Build';
            buildBtn.style.background = '#2255cc';
          }
        }

        let blockBelow = getBlock(player.pos.x, player.pos.y - 0.5, player.pos.z);
        let blockAt = getBlock(player.pos.x, player.pos.y, player.pos.z);
        let inWater = (blockBelow === TYPES.WATER || blockAt === TYPES.WATER);
        if (inWater) {
          player.vel.y -= 5 * dt; if (keys.space) player.vel.y = 8;
        } else player.vel.y -= 40 * dt;
        
        let floorY = -5;
        for (let y = Math.floor(player.pos.y + 1); y >= -5; y--) {
          let b = getBlock(player.pos.x, y, player.pos.z);
          if (b !== TYPES.EMPTY && b !== TYPES.WATER) { floorY = y; break; }
        }
        
        const dir = new THREE.Vector3(moveX, 0, moveZ);
        if (dir.lengthSq() > 0.01) dir.normalize(); else dir.set(0, 0, 0);
        dir.applyAxisAngle(_upVec, player.yaw);
        let pSpeed = inWater ? 6 : (isMobileDevice ? 10 : (buildMode ? 6 : 15));
        let stepX = dir.x * pSpeed * dt, stepZ = dir.z * pSpeed * dt;
        let pCheckY = Math.floor(player.pos.y + 0.5);
        // Step-up collision: try 1 block, then 2 blocks (for stairs/ramps)
        if (getBlock(player.pos.x + stepX, pCheckY, player.pos.z) !== TYPES.EMPTY) {
          if (getBlock(player.pos.x + stepX, pCheckY + 1, player.pos.z) === TYPES.EMPTY && !inWater) player.pos.y += 1;
          else if (getBlock(player.pos.x + stepX, pCheckY + 1, player.pos.z) !== TYPES.EMPTY &&
                   getBlock(player.pos.x + stepX, pCheckY + 2, player.pos.z) === TYPES.EMPTY && !inWater) player.pos.y += 2;
          else stepX = 0;
        }
        if (getBlock(player.pos.x, pCheckY, player.pos.z + stepZ) !== TYPES.EMPTY) {
          if (getBlock(player.pos.x, pCheckY + 1, player.pos.z + stepZ) === TYPES.EMPTY && !inWater) player.pos.y += 1;
          else if (getBlock(player.pos.x, pCheckY + 1, player.pos.z + stepZ) !== TYPES.EMPTY &&
                   getBlock(player.pos.x, pCheckY + 2, player.pos.z + stepZ) === TYPES.EMPTY && !inWater) player.pos.y += 2;
          else stepZ = 0;
        }
        player.vel.x = stepX / dt || 0; player.vel.z = stepZ / dt || 0;
        if (keys.space && player.pos.y - 1 <= floorY + 0.1 && !inWater) player.vel.y = 15;
        
        let nextY = player.pos.y + player.vel.y * dt;
        if (nextY - 0.5 <= floorY) { nextY = floorY + 0.5; player.vel.y = 0; }
        player.pos.set(player.pos.x + stepX, nextY, player.pos.z + stepZ);
        player.updatePlayerAnim(dt, moveX !== 0 || moveZ !== 0);
        // Hide player in build mode for first-person view
        player.group.visible = !buildMode;

        let aimDir = new THREE.Vector3(-Math.sin(player.yaw) * Math.cos(player.pitch), Math.sin(player.pitch), -Math.cos(player.yaw) * Math.cos(player.pitch)).normalize();
        let rightDir = new THREE.Vector3(-Math.cos(player.yaw), 0, Math.sin(player.yaw)).normalize();
        let camDist = buildMode ? 0.5 : (isMobileDevice ? 3 : 5);
        let targetCamFocus = player.pos.clone(); targetCamFocus.y += buildMode ? 2.5 : 2.0;
        let idealCamPos = targetCamFocus.clone().sub(aimDir.clone().multiplyScalar(camDist)).add(rightDir.clone().multiplyScalar(buildMode ? 0 : (isMobileDevice ? 0.8 : 1.5)));
        idealCamPos = getCameraPos(targetCamFocus, idealCamPos);
        camera.position.lerp(idealCamPos, Math.min(1.0, 15 * dt));
        camera.lookAt(targetCamFocus.clone().add(aimDir.clone().multiplyScalar(50)));
        updateChunks();
      }
      
      dirLight.position.copy(targetPos).add(_lightOffset);
      dirLight.target.position.copy(targetPos);
      let trafficLightIsRed = (Date.now() % 10000) < 5000;
      
      if (Math.random() < 0.01) { spawnTraffic(); spawnCarparkCars(); }
      
      // Manage Gradual Cop Spawning based on timer rather than instantly clustering
      if (wantedLevel > 0) {
        copSpawnTimer -= dt;
        if (copSpawnTimer <= 0) {
          let copVehicles = vehicles.filter(v => v.type === 'COP' || v.type === 'ARMY' || v.type === 'TANK').length;
          let copPeds = peds.filter(p => p.type === 'COP' || p.type === 'ARMY').length;
          let maxCops = wantedLevel * 3;
          if (copVehicles + copPeds < maxCops * 2) {
             spawnCop();
             copSpawnTimer = 4.0 / wantedLevel; // Cops arrive faster
          }
        }
      }
      
      vehicles.forEach(veh => {
        if (veh === currentVehicle || veh.isDead) return;
        let accel = 0, steer = 0, useNOS = false;
        if (veh.type === 'COP' || veh.type === 'ARMY' || veh.type === 'TANK') {
          if (wantedLevel > 0) {
            let dirToPlayer = targetPos.clone().sub(veh.pos).normalize();
            let fwd = new THREE.Vector3(-Math.sin(veh.yaw), 0, -Math.cos(veh.yaw));
            let distSq = veh.pos.distanceToSquared(targetPos);

            let copAccelMult = isMobileDevice ? 0.6 : 1.0;
            if (currentVehicle) {
              accel = 0.7 * copAccelMult; useNOS = false;
              steer = -Math.sign(fwd.cross(dirToPlayer).y) * 1.2;
              if (distSq < 100) accel = 0.4 * copAccelMult;
            } else {
              if (distSq > 900) {
                accel = 0.5 * copAccelMult; useNOS = false;
                steer = -Math.sign(fwd.cross(dirToPlayer).y) * 1.0;
              } else {
                accel = -0.2; steer = 0;
              }
            }
            // Tank AI: rotate turret toward player and fire
            if (veh.type === 'TANK' && veh.voxelGroup.turret) {
              let toPlayer = targetPos.clone().sub(veh.pos);
              veh.turretYaw = Math.atan2(-toPlayer.x, -toPlayer.z) - veh.yaw;
              veh.voxelGroup.turret.rotation.y = veh.turretYaw;
              if (distSq < 4900 && Math.random() < 0.015) {
                let bulletOrigin = veh.voxelGroup.getBarrelTipWorld();
                projectiles.push(new Projectile(bulletOrigin, dirToPlayer, false, 100));
              }
            } else if (distSq < 2500 && Math.random() < 0.008) {
              let carBulletDmg = veh.type === 'ARMY' ? 80 : 40;
              projectiles.push(new Projectile(veh.pos.clone().add(new THREE.Vector3(0, 1, 0)), dirToPlayer, false, carBulletDmg));
            }
          }
        } else if (!veh.parked) {
          accel = isMobileDevice ? 0.3 : 0.5;
          let onIntersection = (Math.abs(veh.pos.x) % CHUNK_SIZE < ROAD_WIDTH) && (Math.abs(veh.pos.z) % CHUNK_SIZE < ROAD_WIDTH);
          if (onIntersection && trafficLightIsRed) accel = -0.5;
          else {
            let laneDir = getLaneDirection(veh.pos);
            if (laneDir) {
              let fwd = new THREE.Vector3(-Math.sin(veh.yaw), 0, -Math.cos(veh.yaw));
              steer = -Math.sign(fwd.cross(laneDir).y) * 0.8;
            }
          }
        } else {
          // Parked car - no movement
          accel = 0; steer = 0;
        }
        veh.updatePhysics(dt, accel, steer, useNOS);
      });
      peds.forEach(p => p.update(dt));
      for (let i = projectiles.length - 1; i >= 0; i--) { if (projectiles[i].update(dt)) projectiles.splice(i, 1); }
      for (let p of particlePool) {
        if (p.active) {
          if (p.isSmoke) {
            p.vel.y += 2 * dt; p.mesh.scale.addScalar(dt * 0.3); p.life -= dt * 1.5; // Smoke fades much faster
          } else {
            p.vel.y -= 25 * dt; p.mesh.scale.setScalar(Math.max(0, p.life)); p.life -= dt;
          }
          p.mesh.position.add(p.vel.clone().multiplyScalar(dt));
          if (p.life <= 0) { p.active = false; p.mesh.visible = false; }
        }
      }
    }

    // Force init after DOM load to guarantee it fires correctly in the preview iframe
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', init);
    } else {
        init();
    }
  </script>
</body>
</html>
